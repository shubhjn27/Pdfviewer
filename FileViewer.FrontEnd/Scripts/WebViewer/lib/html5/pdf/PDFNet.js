(function (exports) {
	var PDFNet = {};
	PDFNet.Iterator = function(id, type)
	{
		this.id = id;
		this.name = "Iterator";
		this.type = type;
	}
	PDFNet.DictIterator = function(id)
	{
		this.id = id;
		this.name = "DictIterator";
	}
	PDFNet.Matrix2D = function(m_a, m_b, m_c, m_d, m_h, m_v)
	{
		this.m_a = 0;
		this.m_b = 0;
		this.m_c = 0;
		this.m_d = 0;
		this.m_h = 0;
		this.m_v = 0;
		if(m_a && typeof m_b === "undefined"){
			copyFunc(m_a, this);
		}
		else{
			if(typeof m_a !== "undefined") {this.m_a = m_a};
			if(typeof m_b !== "undefined") {this.m_b = m_b};
			if(typeof m_c !== "undefined") {this.m_c = m_c};
			if(typeof m_d !== "undefined") {this.m_d = m_d};
			if(typeof m_h !== "undefined") {this.m_h = m_h};
			if(typeof m_v !== "undefined") {this.m_v = m_v};
		}
	}
	PDFNet.Field = function(leaf_node, builder)
	{
		this.leaf_node = "0";
		this.builder = "0";
		if(leaf_node && typeof builder === "undefined"){
			copyFunc(leaf_node, this);
		}
		else{
			if(typeof leaf_node !== "undefined") {this.leaf_node = leaf_node};
			if(typeof builder !== "undefined") {this.builder = builder};
		}
	}
	PDFNet.FDFDoc = function(id)
	{
		this.id = id;
		this.name = "FDFDoc";
	}
	PDFNet.FDFField = function(mp_leaf_node, mp_root_array)
	{
		this.mp_leaf_node = "0";
		this.mp_root_array = "0";
		if(mp_leaf_node && typeof mp_root_array === "undefined"){
			copyFunc(mp_leaf_node, this);
		}
		else{
			if(typeof mp_leaf_node !== "undefined") {this.mp_leaf_node = mp_leaf_node};
			if(typeof mp_root_array !== "undefined") {this.mp_root_array = mp_root_array};
		}
	}
	PDFNet.Filter = function(id)
	{
		this.id = id;
		this.name = "Filter";
	}
	PDFNet.FilterReader = function(id)
	{
		this.id = id;
		this.name = "FilterReader";
	}
	PDFNet.FilterWriter = function(id)
	{
		this.id = id;
		this.name = "FilterWriter";
	}
	PDFNet.OCG = function(id)
	{
		this.id = id;
		this.name = "OCG";
	}
	PDFNet.OCGConfig = function(id)
	{
		this.id = id;
		this.name = "OCGConfig";
	}
	PDFNet.OCGContext = function(id)
	{
		this.id = id;
		this.name = "OCGContext";
	}
	PDFNet.OCMD = function(id)
	{
		this.id = id;
		this.name = "OCMD";
	}
	PDFNet.PDFACompliance = function(id)
	{
		this.id = id;
		this.name = "PDFACompliance";
	}
	PDFNet.AttrObj = function(id)
	{
		this.id = id;
		this.name = "AttrObj";
	}
	PDFNet.ClassMap = function(id)
	{
		this.id = id;
		this.name = "ClassMap";
	}
	PDFNet.ContentItem = function(o, p)
	{
		this.o = "0";
		this.p = "0";
		if(o && typeof p === "undefined"){
			copyFunc(o, this);
		}
		else{
			if(typeof o !== "undefined") {this.o = o};
			if(typeof p !== "undefined") {this.p = p};
		}
	}
	PDFNet.RoleMap = function(id)
	{
		this.id = id;
		this.name = "RoleMap";
	}
	PDFNet.SElement = function(obj, k)
	{
		this.obj = "0";
		this.k = "0";
		if(obj && typeof k === "undefined"){
			copyFunc(obj, this);
		}
		else{
			if(typeof obj !== "undefined") {this.obj = obj};
			if(typeof k !== "undefined") {this.k = k};
		}
	}
	PDFNet.STree = function(id)
	{
		this.id = id;
		this.name = "STree";
	}
	PDFNet.Action = function(id)
	{
		this.id = id;
		this.name = "Action";
	}
	PDFNet.Page = function(id)
	{
		this.id = id;
		this.name = "Page";
	}
	PDFNet.Annot = function(id)
	{
		this.id = id;
		this.name = "Annot";
	}
	PDFNet.AnnotBorderStyle = function(id)
	{
		this.id = id;
		this.name = "AnnotBorderStyle";
	}
	PDFNet.CaretAnnot = function(id)
	{
		this.id = id;
		this.name = "CaretAnnot";
	}
	PDFNet.LineAnnot = function(id)
	{
		this.id = id;
		this.name = "LineAnnot";
	}
	PDFNet.CircleAnnot = function(id)
	{
		this.id = id;
		this.name = "CircleAnnot";
	}
	PDFNet.FileAttachmentAnnot = function(id)
	{
		this.id = id;
		this.name = "FileAttachmentAnnot";
	}
	PDFNet.FreeTextAnnot = function(id)
	{
		this.id = id;
		this.name = "FreeTextAnnot";
	}
	PDFNet.HighlightAnnot = function(id)
	{
		this.id = id;
		this.name = "HighlightAnnot";
	}
	PDFNet.InkAnnot = function(id)
	{
		this.id = id;
		this.name = "InkAnnot";
	}
	PDFNet.LinkAnnot = function(id)
	{
		this.id = id;
		this.name = "LinkAnnot";
	}
	PDFNet.MarkupAnnot = function(id)
	{
		this.id = id;
		this.name = "MarkupAnnot";
	}
	PDFNet.MovieAnnot = function(id)
	{
		this.id = id;
		this.name = "MovieAnnot";
	}
	PDFNet.PolyLineAnnot = function(id)
	{
		this.id = id;
		this.name = "PolyLineAnnot";
	}
	PDFNet.PolygonAnnot = function(id)
	{
		this.id = id;
		this.name = "PolygonAnnot";
	}
	PDFNet.PopupAnnot = function(id)
	{
		this.id = id;
		this.name = "PopupAnnot";
	}
	PDFNet.RedactionAnnot = function(id)
	{
		this.id = id;
		this.name = "RedactionAnnot";
	}
	PDFNet.RubberStampAnnot = function(id)
	{
		this.id = id;
		this.name = "RubberStampAnnot";
	}
	PDFNet.ScreenAnnot = function(id)
	{
		this.id = id;
		this.name = "ScreenAnnot";
	}
	PDFNet.SoundAnnot = function(id)
	{
		this.id = id;
		this.name = "SoundAnnot";
	}
	PDFNet.SquareAnnot = function(id)
	{
		this.id = id;
		this.name = "SquareAnnot";
	}
	PDFNet.SquigglyAnnot = function(id)
	{
		this.id = id;
		this.name = "SquigglyAnnot";
	}
	PDFNet.StrikeOutAnnot = function(id)
	{
		this.id = id;
		this.name = "StrikeOutAnnot";
	}
	PDFNet.TextAnnot = function(id)
	{
		this.id = id;
		this.name = "TextAnnot";
	}
	PDFNet.UnderlineAnnot = function(id)
	{
		this.id = id;
		this.name = "UnderlineAnnot";
	}
	PDFNet.WatermarkAnnot = function(id)
	{
		this.id = id;
		this.name = "WatermarkAnnot";
	}
	PDFNet.TextMarkupAnnot = function(id)
	{
		this.id = id;
		this.name = "TextMarkupAnnot";
	}
	PDFNet.WidgetAnnot = function(id)
	{
		this.id = id;
		this.name = "WidgetAnnot";
	}
	PDFNet.Bookmark = function(id)
	{
		this.id = id;
		this.name = "Bookmark";
	}
	PDFNet.ColorPt = function(id)
	{
		this.id = id;
		this.name = "ColorPt";
	}
	PDFNet.ColorSpace = function(id)
	{
		this.id = id;
		this.name = "ColorSpace";
	}
	PDFNet.ContentReplacer = function(id)
	{
		this.id = id;
		this.name = "ContentReplacer";
	}
	PDFNet.DocumentConversion = function(id)
	{
		this.id = id;
		this.name = "DocumentConversion";
	}
	PDFNet.Convert = function(id)
	{
		this.id = id;
		this.name = "Convert";
	}
	PDFNet.ConversionMonitor = function(id)
	{
		this.id = id;
		this.name = "ConversionMonitor";
	}
	PDFNet.Date = function(year, month, day, hour, minute, second, UT, UT_hour, UT_minutes, mp_obj)
	{
		this.year = 0;
		this.month = 0;
		this.day = 0;
		this.hour = 0;
		this.minute = 0;
		this.second = 0;
		this.UT = 0;
		this.UT_hour = 0;
		this.UT_minutes = 0;
		this.mp_obj = "0";
		if(year && typeof month === "undefined"){
			copyFunc(year, this);
		}
		else{
			if(typeof year !== "undefined") {this.year = year};
			if(typeof month !== "undefined") {this.month = month};
			if(typeof day !== "undefined") {this.day = day};
			if(typeof hour !== "undefined") {this.hour = hour};
			if(typeof minute !== "undefined") {this.minute = minute};
			if(typeof second !== "undefined") {this.second = second};
			if(typeof UT !== "undefined") {this.UT = UT};
			if(typeof UT_hour !== "undefined") {this.UT_hour = UT_hour};
			if(typeof UT_minutes !== "undefined") {this.UT_minutes = UT_minutes};
			if(typeof mp_obj !== "undefined") {this.mp_obj = mp_obj};
		}
	}
	PDFNet.Destination = function(id)
	{
		this.id = id;
		this.name = "Destination";
	}
	PDFNet.GState = function(id)
	{
		this.id = id;
		this.name = "GState";
	}
	PDFNet.Element = function(id)
	{
		this.id = id;
		this.name = "Element";
	}
	PDFNet.ElementBuilder = function(id)
	{
		this.id = id;
		this.name = "ElementBuilder";
	}
	PDFNet.ElementReader = function(id)
	{
		this.id = id;
		this.name = "ElementReader";
	}
	PDFNet.ElementWriter = function(id)
	{
		this.id = id;
		this.name = "ElementWriter";
	}
	PDFNet.FileSpec = function(id)
	{
		this.id = id;
		this.name = "FileSpec";
	}
	PDFNet.Flattener = function(id)
	{
		this.id = id;
		this.name = "Flattener";
	}
	PDFNet.Font = function(id)
	{
		this.id = id;
		this.name = "Font";
	}
	PDFNet.Function = function(id)
	{
		this.id = id;
		this.name = "Function";
	}
	PDFNet.Highlights = function(id)
	{
		this.id = id;
		this.name = "Highlights";
	}
	PDFNet.HTML2PDF_Proxy = function(id)
	{
		this.id = id;
		this.name = "HTML2PDF_Proxy";
	}
	PDFNet.HTML2PDF_WebPageSettings = function(id)
	{
		this.id = id;
		this.name = "HTML2PDF_WebPageSettings";
	}
	PDFNet.HTML2PDF_TOCSettings = function(id)
	{
		this.id = id;
		this.name = "HTML2PDF_TOCSettings";
	}
	PDFNet.HTML2PDF = function(id)
	{
		this.id = id;
		this.name = "HTML2PDF";
	}
	PDFNet.Image = function(id)
	{
		this.id = id;
		this.name = "Image";
	}
	PDFNet.Optimizer = function(id)
	{
		this.id = id;
		this.name = "Optimizer";
	}
	PDFNet.PageLabel = function(mp_obj, m_first_page, m_last_page)
	{
		this.mp_obj = "0";
		this.m_first_page = 0;
		this.m_last_page = 0;
		if(mp_obj && typeof m_first_page === "undefined"){
			copyFunc(mp_obj, this);
		}
		else{
			if(typeof mp_obj !== "undefined") {this.mp_obj = mp_obj};
			if(typeof m_first_page !== "undefined") {this.m_first_page = m_first_page};
			if(typeof m_last_page !== "undefined") {this.m_last_page = m_last_page};
		}
	}
	PDFNet.PageSet = function(id)
	{
		this.id = id;
		this.name = "PageSet";
	}
	PDFNet.PatternColor = function(id)
	{
		this.id = id;
		this.name = "PatternColor";
	}
	PDFNet.PDFDoc = function(id)
	{
		this.id = id;
		this.name = "PDFDoc";
	}
	PDFNet.PDFDocInfo = function(id)
	{
		this.id = id;
		this.name = "PDFDocInfo";
	}
	PDFNet.PDFDocViewPrefs = function(id)
	{
		this.id = id;
		this.name = "PDFDocViewPrefs";
	}
	PDFNet.PDFRasterizer = function(id)
	{
		this.id = id;
		this.name = "PDFRasterizer";
	}
	PDFNet.ChunkRenderer = function(id)
	{
		this.id = id;
		this.name = "ChunkRenderer";
	}
	PDFNet.PDFDraw = function(id)
	{
		this.id = id;
		this.name = "PDFDraw";
	}
	PDFNet.PDFNet = function(id)
	{
		this.id = id;
		this.name = "PDFNet";
	}
	PDFNet.Rect = function(x1, y1, x2, y2, mp_rect)
	{
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.mp_rect = "0";
		if(x1 && typeof y1 === "undefined"){
			copyFunc(x1, this);
		}
		else{
			if(typeof x1 !== "undefined") {this.x1 = x1};
			if(typeof y1 !== "undefined") {this.y1 = y1};
			if(typeof x2 !== "undefined") {this.x2 = x2};
			if(typeof y2 !== "undefined") {this.y2 = y2};
			if(typeof mp_rect !== "undefined") {this.mp_rect = mp_rect};
		}
	}
	PDFNet.Redactor = function(id)
	{
		this.id = id;
		this.name = "Redactor";
	}
	PDFNet.RedactionAppearance = function(id)
	{
		this.id = id;
		this.name = "RedactionAppearance";
	}
	PDFNet.Shading = function(id)
	{
		this.id = id;
		this.name = "Shading";
	}
	PDFNet.Stamper = function(id)
	{
		this.id = id;
		this.name = "Stamper";
	}
	PDFNet.TextExtractor = function(id)
	{
		this.id = id;
		this.name = "TextExtractor";
	}
	PDFNet.TextExtractorStyle = function(mp_imp)
	{
		this.mp_imp = "0";
		if(typeof mp_imp !== "undefined") {this.mp_imp = mp_imp};
	}
	PDFNet.TextExtractorWord = function(line, word, end, uni, num, cur_num, mp_bld)
	{
		this.line = "0";
		this.word = "0";
		this.end = "0";
		this.uni = "0";
		this.num = 0;
		this.cur_num = 0;
		this.mp_bld = "0";
		if(line && typeof word === "undefined"){
			copyFunc(line, this);
		}
		else{
			if(typeof line !== "undefined") {this.line = line};
			if(typeof word !== "undefined") {this.word = word};
			if(typeof end !== "undefined") {this.end = end};
			if(typeof uni !== "undefined") {this.uni = uni};
			if(typeof num !== "undefined") {this.num = num};
			if(typeof cur_num !== "undefined") {this.cur_num = cur_num};
			if(typeof mp_bld !== "undefined") {this.mp_bld = mp_bld};
		}
	}
	PDFNet.TextExtractorLine = function(line, uni, num, cur_num, m_direction, mp_bld)
	{
		this.line = "0";
		this.uni = "0";
		this.num = 0;
		this.cur_num = 0;
		this.m_direction = 0;
		this.mp_bld = "0";
		if(line && typeof uni === "undefined"){
			copyFunc(line, this);
		}
		else{
			if(typeof line !== "undefined") {this.line = line};
			if(typeof uni !== "undefined") {this.uni = uni};
			if(typeof num !== "undefined") {this.num = num};
			if(typeof cur_num !== "undefined") {this.cur_num = cur_num};
			if(typeof m_direction !== "undefined") {this.m_direction = m_direction};
			if(typeof mp_bld !== "undefined") {this.mp_bld = mp_bld};
		}
	}
	PDFNet.TextSearch = function(id)
	{
		this.id = id;
		this.name = "TextSearch";
	}
	PDFNet.NameTree = function(id)
	{
		this.id = id;
		this.name = "NameTree";
	}
	PDFNet.NumberTree = function(id)
	{
		this.id = id;
		this.name = "NumberTree";
	}
	PDFNet.Obj = function(id)
	{
		this.id = id;
		this.name = "Obj";
	}
	PDFNet.ObjSet = function(id)
	{
		this.id = id;
		this.name = "ObjSet";
	}
	PDFNet.SDFDoc = function(id)
	{
		this.id = id;
		this.name = "SDFDoc";
	}
	PDFNet.SecurityHandler = function(id)
	{
		this.id = id;
		this.name = "SecurityHandler";
	}
	PDFNet.SignatureHandler = function(id)
	{
		this.id = id;
		this.name = "SignatureHandler";
	}
	PDFNet.ItrData = function(id)
	{
		this.id = id;
		this.name = "ItrData";
	}
	PDFNet.ProgressMonitor = function(id)
	{
		this.id = id;
		this.name = "ProgressMonitor";
	}
	PDFNet.FontCharCodeIterator = function(id)
	{
		this.id = id;
		this.name = "FontCharCodeIterator";
	}
	PDFNet.List = function(id)
	{
		this.id = id;
		this.name = "List";
	}
	PDFNet.PDFDC = function(id)
	{
		this.id = id;
		this.name = "PDFDC";
	}
	PDFNet.PDFDCEX = function(id)
	{
		this.id = id;
		this.name = "PDFDCEX";
	}
	PDFNet.SystemDrawingBitmap = function(id)
	{
		this.id = id;
		this.name = "SystemDrawingBitmap";
	}
	PDFNet.PDFView = function(id)
	{
		this.id = id;
		this.name = "PDFView";
	}
	PDFNet.PDFViewSelection = function(id)
	{
		this.id = id;
		this.name = "PDFViewSelection";
	}
	PDFNet.PDFViewCtrl = function(id)
	{
		this.id = id;
		this.name = "PDFViewCtrl";
	}
	PDFNet.DownloadContainer = function(id)
	{
		this.id = id;
		this.name = "DownloadContainer";
	}
	PDFNet.Redaction = function(id)
	{
		this.id = id;
		this.name = "Redaction";
	}
	PDFNet.QuadPoint = function(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y)
	{
		this.p1x = 0;
		this.p1y = 0;
		this.p2x = 0;
		this.p2y = 0;
		this.p3x = 0;
		this.p3y = 0;
		this.p4x = 0;
		this.p4y = 0;
		if(p1x && typeof p1y === "undefined"){
			copyFunc(p1y, this);
		}
		else{
			if(typeof p1x !== "undefined") {this.p1x = p1x};
			if(typeof p1y !== "undefined") {this.p1y = p1y};
			if(typeof p2x !== "undefined") {this.p2x = p2x};
			if(typeof p2y !== "undefined") {this.p2y = p2y};
			if(typeof p3x !== "undefined") {this.p3x = p3x};
			if(typeof p3y !== "undefined") {this.p3y = p3y};
			if(typeof p4x !== "undefined") {this.p4x = p4x};
			if(typeof p4y !== "undefined") {this.p4y = p4y};
		}
	}

	PDFNet.Point = function(x, y)
	{
		this.x = 0;
		this.y = 0;
		if(x && typeof y === "undefined"){
			copyFunc(x, this);
		}
		else{
			if(typeof x !== "undefined") {this.x = x};
			if(typeof y !== "undefined") {this.y = y};
		}
	}

	PDFNet.MarkupAnnot.prototype = new PDFNet.Annot();
	PDFNet.TextMarkupAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.CaretAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.LineAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.CircleAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.FileAttachmentAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.FreeTextAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.HighlightAnnot.prototype = new PDFNet.TextMarkupAnnot();
	PDFNet.InkAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.LinkAnnot.prototype = new PDFNet.Annot();
	PDFNet.MovieAnnot.prototype = new PDFNet.Annot();
	PDFNet.PolyLineAnnot.prototype = new PDFNet.LineAnnot();
	PDFNet.PolygonAnnot.prototype = new PDFNet.Annot();
	PDFNet.PopupAnnot.prototype = new PDFNet.Annot();
	PDFNet.RedactionAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.RubberStampAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.ScreenAnnot.prototype = new PDFNet.Annot();
	PDFNet.SoundAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.SquareAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.SquigglyAnnot.prototype = new PDFNet.TextMarkupAnnot();
	PDFNet.StrikeOutAnnot.prototype = new PDFNet.TextMarkupAnnot();
	PDFNet.TextAnnot.prototype = new PDFNet.MarkupAnnot();
	PDFNet.UnderlineAnnot.prototype = new PDFNet.TextMarkupAnnot();
	PDFNet.WatermarkAnnot.prototype = new PDFNet.Annot();
	PDFNet.WidgetAnnot.prototype = new PDFNet.Annot();
	PDFNet.Field.Type = {
		e_button : 0,
		e_check : 1,
		e_radio : 2,
		e_text : 3,
		e_choice : 4,
		e_signature : 5,
		e_null : 6
	}
	PDFNet.Field.Flag = {
		e_read_only : 0,
		e_required : 1,
		e_no_export : 2,
		e_pushbutton_flag : 3,
		e_radio_flag : 4,
		e_toggle_to_off : 5,
		e_radios_in_unison : 6,
		e_multiline : 7,
		e_password : 8,
		e_file_select : 9,
		e_no_spellcheck : 10,
		e_no_scroll : 11,
		e_comb : 12,
		e_rich_text : 13,
		e_combo : 14,
		e_edit : 15,
		e_sort : 16,
		e_multiselect : 17,
		e_commit_on_sel_change : 18
	}
	PDFNet.Field.TextJustification = {
		e_left_justified : 0,
		e_centered : 1,
		e_right_justified : 2
	}
	PDFNet.Filter.StdFileOpenMode = {
		e_read_mode : 0,
		e_write_mode : 1,
		e_append_mode : 2
	}
	PDFNet.Filter.ReferencePos = {
		e_begin : 0,
		e_end : 2,
		e_cur : 1
	}
	PDFNet.OCGContext.OCDrawMode = {
		e_VisibleOC : 0,
		e_AllOC : 1,
		e_NoOC : 2
	}
	PDFNet.OCMD.VisibilityPolicyType = {
		e_AllOn : 0,
		e_AnyOn : 1,
		e_AnyOff : 2,
		e_AllOff : 3
	}
	PDFNet.PDFACompliance.Conformance = {
		e_Level1A : 1,
		e_Level1B : 2,
		e_Level2A : 3,
		e_Level2B : 4,
		e_Level2U : 5,
		e_Level3A : 6,
		e_Level3B : 7,
		e_Level3U : 8
	}
	PDFNet.PDFACompliance.ErrorCode = {
		e_PDFA0_1_0 : 10,
		e_PDFA0_1_1 : 11,
		e_PDFA0_1_2 : 12,
		e_PDFA0_1_3 : 13,
		e_PDFA0_1_4 : 14,
		e_PDFA0_1_5 : 15,
		e_PDFA1_2_1 : 121,
		e_PDFA1_2_2 : 122,
		e_PDFA1_3_1 : 131,
		e_PDFA1_3_2 : 132,
		e_PDFA1_3_3 : 133,
		e_PDFA1_3_4 : 134,
		e_PDFA1_4_1 : 141,
		e_PDFA1_4_2 : 142,
		e_PDFA1_6_1 : 161,
		e_PDFA1_7_1 : 171,
		e_PDFA1_7_2 : 172,
		e_PDFA1_7_3 : 173,
		e_PDFA1_7_4 : 174,
		e_PDFA1_8_1 : 181,
		e_PDFA1_8_2 : 182,
		e_PDFA1_8_3 : 183,
		e_PDFA1_8_4 : 184,
		e_PDFA1_8_5 : 185,
		e_PDFA1_8_6 : 186,
		e_PDFA1_10_1 : 1101,
		e_PDFA1_11_1 : 1111,
		e_PDFA1_11_2 : 1112,
		e_PDFA1_12_1 : 1121,
		e_PDFA1_12_2 : 1122,
		e_PDFA1_12_3 : 1123,
		e_PDFA1_12_4 : 1124,
		e_PDFA1_12_5 : 1125,
		e_PDFA1_12_6 : 1126,
		e_PDFA1_13_1 : 1131,
		e_PDFA2_2_1 : 221,
		e_PDFA2_3_2 : 232,
		e_PDFA2_3_3 : 233,
		e_PDFA2_3_3_1 : 2331,
		e_PDFA2_3_3_2 : 2332,
		e_PDFA2_3_4_1 : 2341,
		e_PDFA2_4_1 : 241,
		e_PDFA2_4_2 : 242,
		e_PDFA2_4_3 : 243,
		e_PDFA2_4_4 : 244,
		e_PDFA2_5_1 : 251,
		e_PDFA2_5_2 : 252,
		e_PDFA2_6_1 : 261,
		e_PDFA2_7_1 : 271,
		e_PDFA2_8_1 : 281,
		e_PDFA2_9_1 : 291,
		e_PDFA2_10_1 : 2101,
		e_PDFA3_2_1 : 321,
		e_PDFA3_3_1 : 331,
		e_PDFA3_3_2 : 332,
		e_PDFA3_3_3_1 : 3331,
		e_PDFA3_3_3_2 : 3332,
		e_PDFA3_4_1 : 341,
		e_PDFA3_5_1 : 351,
		e_PDFA3_5_2 : 352,
		e_PDFA3_5_3 : 353,
		e_PDFA3_5_4 : 354,
		e_PDFA3_5_5 : 355,
		e_PDFA3_5_6 : 356,
		e_PDFA3_6_1 : 361,
		e_PDFA3_7_1 : 371,
		e_PDFA3_7_2 : 372,
		e_PDFA3_7_3 : 373,
		e_PDFA4_1 : 41,
		e_PDFA4_2 : 42,
		e_PDFA4_3 : 43,
		e_PDFA4_4 : 44,
		e_PDFA4_5 : 45,
		e_PDFA4_6 : 46,
		e_PDFA5_2_1 : 521,
		e_PDFA5_2_2 : 522,
		e_PDFA5_2_3 : 523,
		e_PDFA5_2_4 : 524,
		e_PDFA5_2_5 : 525,
		e_PDFA5_2_6 : 526,
		e_PDFA5_2_7 : 527,
		e_PDFA5_2_8 : 528,
		e_PDFA5_2_9 : 529,
		e_PDFA5_2_10 : 5210,
		e_PDFA5_2_11 : 5211,
		e_PDFA5_3_1 : 531,
		e_PDFA5_3_2_1 : 5321,
		e_PDFA5_3_2_2 : 5322,
		e_PDFA5_3_2_3 : 5323,
		e_PDFA5_3_2_4 : 5324,
		e_PDFA5_3_2_5 : 5325,
		e_PDFA5_3_3_1 : 5331,
		e_PDFA5_3_3_2 : 5332,
		e_PDFA5_3_3_3 : 5333,
		e_PDFA5_3_3_4 : 5334,
		e_PDFA5_3_4_0 : 5340,
		e_PDFA5_3_4_1 : 5341,
		e_PDFA5_3_4_2 : 5342,
		e_PDFA5_3_4_3 : 5343,
		e_PDFA6_1_1 : 611,
		e_PDFA6_1_2 : 612,
		e_PDFA6_2_1 : 621,
		e_PDFA6_2_2 : 622,
		e_PDFA6_2_3 : 623,
		e_PDFA7_2_1 : 721,
		e_PDFA7_2_2 : 722,
		e_PDFA7_2_3 : 723,
		e_PDFA7_2_4 : 724,
		e_PDFA7_2_5 : 725,
		e_PDFA7_3_1 : 731,
		e_PDFA7_3_2 : 732,
		e_PDFA7_3_3 : 733,
		e_PDFA7_3_4 : 734,
		e_PDFA7_3_5 : 735,
		e_PDFA7_3_6 : 736,
		e_PDFA7_3_7 : 737,
		e_PDFA7_3_8 : 738,
		e_PDFA7_3_9 : 739,
		e_PDFA7_5_1 : 751,
		e_PDFA7_8_1 : 781,
		e_PDFA7_8_2 : 782,
		e_PDFA7_8_3 : 783,
		e_PDFA7_8_4 : 784,
		e_PDFA7_8_5 : 785,
		e_PDFA7_8_6 : 786,
		e_PDFA7_8_7 : 787,
		e_PDFA7_8_8 : 788,
		e_PDFA7_8_9 : 789,
		e_PDFA7_8_10 : 7810,
		e_PDFA7_8_11 : 7811,
		e_PDFA7_8_12 : 7812,
		e_PDFA7_8_13 : 7813,
		e_PDFA7_8_14 : 7814,
		e_PDFA7_8_15 : 7815,
		e_PDFA7_8_16 : 7816,
		e_PDFA7_8_17 : 7817,
		e_PDFA7_8_18 : 7818,
		e_PDFA7_8_19 : 7819,
		e_PDFA7_8_20 : 7820,
		e_PDFA7_8_21 : 7821,
		e_PDFA7_8_22 : 7822,
		e_PDFA7_8_23 : 7823,
		e_PDFA7_8_24 : 7824,
		e_PDFA7_8_25 : 7825,
		e_PDFA7_8_26 : 7826,
		e_PDFA7_8_27 : 7827,
		e_PDFA7_8_28 : 7828,
		e_PDFA7_8_29 : 7829,
		e_PDFA7_8_30 : 7830,
		e_PDFA7_8_31 : 7831,
		e_PDFA7_11_1 : 7111,
		e_PDFA7_11_2 : 7112,
		e_PDFA7_11_3 : 7113,
		e_PDFA7_11_4 : 7114,
		e_PDFA7_11_5 : 7115,
		e_PDFA9_1 : 91,
		e_PDFA9_2 : 92,
		e_PDFA9_3 : 93,
		e_PDFA9_4 : 94,
		e_PDFA3_8_1 : 381,
		e_PDFA8_2_2 : 822,
		e_PDFA8_3_3_1 : 8331,
		e_PDFA8_3_3_2 : 8332,
		e_PDFA8_3_4_1 : 8341,
		e_PDFA1_2_3 : 123,
		e_PDFA1_10_2 : 1102,
		e_PDFA1_10_3 : 1103,
		e_PDFA1_12_10 : 11210,
		e_PDFA1_13_5 : 1135,
		e_PDFA2_3_10 : 2310,
		e_PDFA2_4_2_10 : 24220,
		e_PDFA2_4_2_11 : 24221,
		e_PDFA2_4_2_12 : 24222,
		e_PDFA2_4_2_13 : 24223,
		e_PDFA2_5_10 : 2510,
		e_PDFA2_5_11 : 2511,
		e_PDFA2_5_12 : 2512,
		e_PDFA2_8_3_1 : 2831,
		e_PDFA2_8_3_2 : 2832,
		e_PDFA2_8_3_3 : 2833,
		e_PDFA2_8_3_4 : 2834,
		e_PDFA2_8_3_5 : 2835,
		e_PDFA2_10_20 : 21020,
		e_PDFA2_10_21 : 21021,
		e_PDFA11_0_0 : 11000,
		e_PDFA6_2_11_8 : 62118,
		e_PDFA8_1 : 81,
		e_PDFA_3E1 : 1,
		e_PDFA_3E2 : 2,
		e_PDFA_3E3 : 3,
		e_PDFA_LAST : 4
	}
	PDFNet.ContentItem.Type = {
		e_MCR : 0,
		e_MCID : 1,
		e_OBJR : 2,
		e_Unknown : 3
	}
	PDFNet.Action.Type = {
		e_GoTo : 0,
		e_GoToR : 1,
		e_GoToE : 2,
		e_Launch : 3,
		e_Thread : 4,
		e_URI : 5,
		e_Sound : 6,
		e_Movie : 7,
		e_Hide : 8,
		e_Named : 9,
		e_SubmitForm : 10,
		e_ResetForm : 11,
		e_ImportData : 12,
		e_JavaScript : 13,
		e_SetOCGState : 14,
		e_Rendition : 15,
		e_Trans : 16,
		e_GoTo3DView : 17,
		e_RichMediaExecute : 18,
		e_Unknown : 19
	}
	PDFNet.Action.FormFlag = {
		e_exclude : 0,
		e_include_no_value_fields : 1,
		e_export_format : 2,
		e_get_method : 3,
		e_submit_coordinates : 4,
		e_xfdf : 5,
		e_include_append_saves : 6,
		e_include_annotations : 7,
		e_submit_pdf : 8,
		e_canonical_format : 9,
		e_excl_non_user_annots : 10,
		e_excl_F_key : 11,
		e_embed_form : 13
	}
	PDFNet.Page.Box = {
		e_media : 0,
		e_crop : 1,
		e_bleed : 2,
		e_trim : 3,
		e_art : 4
	}
	PDFNet.Page.Rotate = {
		e_0 : 0,
		e_90 : 1,
		e_180 : 2,
		e_270 : 3
	}
	PDFNet.Annot.Type = {
		e_Text : 0,
		e_Link : 1,
		e_FreeText : 2,
		e_Line : 3,
		e_Square : 4,
		e_Circle : 5,
		e_Polygon : 6,
		e_Polyline : 7,
		e_Highlight : 8,
		e_Underline : 9,
		e_Squiggly : 10,
		e_StrikeOut : 11,
		e_Stamp : 12,
		e_Caret : 13,
		e_Ink : 14,
		e_Popup : 15,
		e_FileAttachment : 16,
		e_Sound : 17,
		e_Movie : 18,
		e_Widget : 19,
		e_Screen : 20,
		e_PrinterMark : 21,
		e_TrapNet : 22,
		e_Watermark : 23,
		e_3D : 24,
		e_Redact : 25,
		e_Projection : 26,
		e_RichMedia : 27,
		e_Unknown : 28
	}
	PDFNet.Annot.Flag = {
		e_invisible : 0,
		e_hidden : 1,
		e_print : 2,
		e_no_zoom : 3,
		e_no_rotate : 4,
		e_no_view : 5,
		e_annot_read_only : 6,
		e_locked : 7,
		e_toggle_no_view : 8,
		e_locked_contents : 9
	}
	PDFNet.AnnotBorderStyle.Style = {
		e_solid : 0,
		e_dashed : 1,
		e_beveled : 2,
		e_inset : 3,
		e_underline : 4
	}
	PDFNet.Annot.State = {
		e_normal : 0,
		e_rollover : 1,
		e_down : 2
	}
	PDFNet.LineAnnot.EndingStyle = {
		e_Square : 0,
		e_Circle : 1,
		e_Diamond : 2,
		e_OpenArrow : 3,
		e_ClosedArrow : 4,
		e_Butt : 5,
		e_ROpenArrow : 6,
		e_RClosedArrow : 7,
		e_Slash : 8,
		e_None : 9,
		e_Unknown : 10
	}
	PDFNet.LineAnnot.IntentType = {
		e_LineArrow : 0,
		e_LineDimension : 1,
		e_null : 2
	}
	PDFNet.LineAnnot.CapPos = {
		e_Inline : 0,
		e_Top : 1
	}
	PDFNet.FileAttachmentAnnot.Icon = {
		e_Graph : 0,
		e_PushPin : 1,
		e_Paperclip : 2,
		e_Tag : 3,
		e_Unknown : 4
	}
	PDFNet.FreeTextAnnot.IntentName = {
		e_FreeText : 0,
		e_FreeTextCallout : 1,
		e_FreeTextTypeWriter : 2,
		e_Unknown : 3
	}
	PDFNet.LinkAnnot.HighlightingMode = {
		e_none : 0,
		e_invert : 1,
		e_outline : 2,
		e_push : 3
	}
	PDFNet.MarkupAnnot.BorderEffect = {
		e_None : 0,
		e_Cloudy : 1
	}
	PDFNet.PolyLineAnnot.IntentType = {
		e_PolygonCloud : 0,
		e_PolyLineDimension : 1,
		e_PolygonDimension : 2,
		e_Unknown : 3
	}
	PDFNet.RedactionAnnot.QuadForm = {
		e_LeftJustified : 0,
		e_Centered : 1,
		e_RightJustified : 2,
		e_None : 3
	}
	PDFNet.RubberStampAnnot.Icon = {
		e_Approved : 0,
		e_Experimental : 1,
		e_NotApproved : 2,
		e_AsIs : 3,
		e_Expired : 4,
		e_NotForPublicRelease : 5,
		e_Confidential : 6,
		e_Final : 7,
		e_Sold : 8,
		e_Departmental : 9,
		e_ForComment : 10,
		e_TopSecret : 11,
		e_ForPublicRelease : 12,
		e_Draft : 13,
		e_Unknown : 14
	}
	PDFNet.ScreenAnnot.ScaleType = {
		e_Anamorphic : 0,
		e_Proportional : 1
	}
	PDFNet.ScreenAnnot.ScaleCondition = {
		e_Always : 0,
		e_WhenBigger : 1,
		e_WhenSmaller : 2,
		e_Never : 3
	}
	PDFNet.ScreenAnnot.IconCaptionRelation = {
		e_NoIcon : 0,
		e_NoCaption : 1,
		e_CBelowI : 2,
		e_CAboveI : 3,
		e_CRightILeft : 4,
		e_CLeftIRight : 5,
		e_COverlayI : 6
	}
	PDFNet.SoundAnnot.Icon = {
		e_Speaker : 0,
		e_Mic : 1,
		e_Unknown : 2
	}
	PDFNet.TextAnnot.Icon = {
		e_Comment : 0,
		e_Key : 1,
		e_Help : 2,
		e_NewParagraph : 3,
		e_Paragraph : 4,
		e_Insert : 5,
		e_Note : 6,
		e_Unknown : 7
	}
	PDFNet.WidgetAnnot.HighlightingMode = {
		e_none : 0,
		e_invert : 1,
		e_outline : 2,
		e_push : 3,
		e_toggle : 4
	}
	PDFNet.WidgetAnnot.ScaleType = {
		e_Anamorphic : 0,
		e_Proportional : 1
	}
	PDFNet.WidgetAnnot.IconCaptionRelation = {
		e_NoIcon : 0,
		e_NoCaption : 1,
		e_CBelowI : 2,
		e_CAboveI : 3,
		e_CRightILeft : 4,
		e_CLeftIRight : 5,
		e_COverlayI : 6
	}
	PDFNet.WidgetAnnot.ScaleCondition = {
		e_Always : 0,
		e_WhenBigger : 1,
		e_WhenSmaller : 2,
		e_Never : 3
	}
	PDFNet.ColorSpace.Type = {
		e_device_gray : 0,
		e_device_rgb : 1,
		e_device_cmyk : 2,
		e_cal_gray : 3,
		e_cal_rgb : 4,
		e_lab : 5,
		e_icc : 6,
		e_indexed : 7,
		e_pattern : 8,
		e_separation : 9,
		e_device_n : 10,
		e_null : 11
	}
	PDFNet.DocumentConversion._Result = {
		e_Success : 0,
		e_Incomplete : 1,
		e_Failure : 2
	}
	PDFNet.Destination.FitType = {
		e_XYZ : 0,
		e_Fit : 1,
		e_FitH : 2,
		e_FitV : 3,
		e_FitR : 4,
		e_FitB : 5,
		e_FitBH : 6,
		e_FitBV : 7
	}
	PDFNet.GState.Attribute = {
		e_transform : 0,
		e_rendering_intent : 1,
		e_stroke_cs : 2,
		e_stroke_color : 3,
		e_fill_cs : 4,
		e_fill_color : 5,
		e_line_width : 6,
		e_line_cap : 7,
		e_line_join : 8,
		e_flatness : 9,
		e_miter_limit : 10,
		e_dash_pattern : 11,
		e_char_spacing : 12,
		e_word_spacing : 13,
		e_horizontal_scale : 14,
		e_leading : 15,
		e_font : 16,
		e_font_size : 17,
		e_text_render_mode : 18,
		e_text_rise : 19,
		e_text_knockout : 20,
		e_text_pos_offset : 21,
		e_blend_mode : 22,
		e_opacity_fill : 23,
		e_opacity_stroke : 24,
		e_alpha_is_shape : 25,
		e_soft_mask : 26,
		e_smoothnes : 27,
		e_auto_stoke_adjust : 28,
		e_stroke_overprint : 29,
		e_fill_overprint : 30,
		e_overprint_mode : 31,
		e_transfer_funct : 32,
		e_BG_funct : 33,
		e_UCR_funct : 34,
		e_halftone : 35,
		e_null : 36
	}
	PDFNet.GState.LineCap = {
		e_butt_cap : 0,
		e_round_cap : 1,
		e_square_cap : 2
	}
	PDFNet.GState.LineJoin = {
		e_miter_join : 0,
		e_round_join : 1,
		e_bevel_join : 2
	}
	PDFNet.GState.TextRenderingMode = {
		e_fill_text : 0,
		e_stroke_text : 1,
		e_fill_stroke_text : 2,
		e_invisible_text : 3,
		e_fill_clip_text : 4,
		e_stroke_clip_text : 5,
		e_fill_stroke_clip_text : 6,
		e_clip_text : 7
	}
	PDFNet.GState.RenderingIntent = {
		e_absolute_colorimetric : 0,
		e_relative_colorimetric : 1,
		e_saturation : 2,
		e_perceptual : 3
	}
	PDFNet.GState.BlendMode = {
		e_bl_compatible : 0,
		e_bl_normal : 1,
		e_bl_multiply : 2,
		e_bl_screen : 3,
		e_bl_difference : 4,
		e_bl_darken : 5,
		e_bl_lighten : 6,
		e_bl_color_dodge : 7,
		e_bl_color_burn : 8,
		e_bl_exclusion : 9,
		e_bl_hard_light : 10,
		e_bl_overlay : 11,
		e_bl_soft_light : 12,
		e_bl_luminosity : 13,
		e_bl_hue : 14,
		e_bl_saturation : 15,
		e_bl_color : 16
	}
	PDFNet.Element.Type = {
		e_null : 0,
		e_path : 1,
		e_text_begin : 2,
		e_text : 3,
		e_text_new_line : 4,
		e_text_end : 5,
		e_image : 6,
		e_inline_image : 7,
		e_shading : 8,
		e_form : 9,
		e_group_begin : 10,
		e_group_end : 11,
		e_marked_content_begin : 12,
		e_marked_content_end : 13,
		e_marked_content_point : 14
	}
	PDFNet.Element.PathSegmentType = {
		e_moveto : 1,
		e_lineto : 2,
		e_cubicto : 3,
		e_conicto : 4,
		e_rect : 5,
		e_closepath : 6
	}
	PDFNet.ElementWriter.WriteMode = {
		e_underlay : 0,
		e_overlay : 1,
		e_replacement : 2
	}
	PDFNet.Flattener.Threshold = {
		e_threshold_very_strict : 0,
		e_threshold_strict : 1,
		e_threshold_default : 2,
		e_threshold_keep_most : 3,
		e_threshold_keep_all : 4
	}
	PDFNet.Flattener.Mode = {
		e_mode_simple : 0,
		e_mode_fast : 1
	}
	PDFNet.Font.StandardType1 = {
		e_times_roman : 0,
		e_times_bold : 1,
		e_times_italic : 2,
		e_times_bold_italic : 3,
		e_helvetica : 4,
		e_helvetica_bold : 5,
		e_helvetica_oblique : 6,
		e_helvetica_bold_oblique : 7,
		e_courier : 8,
		e_courier_bold : 9,
		e_courier_oblique : 10,
		e_courier_bold_oblique : 11,
		e_symbol : 12,
		e_zapf_dingbats : 13,
		e_null : 14
	}
	PDFNet.Font.Encoding = {
		e_IdentityH : 0,
		e_Indices : 1
	}
	PDFNet.Font.Type = {
		e_Type1 : 0,
		e_TrueType : 1,
		e_MMType1 : 2,
		e_Type3 : 3,
		e_Type0 : 4,
		e_CIDType0 : 5,
		e_CIDType2 : 6
	}
	PDFNet.Function.Type = {
		e_sampled : 0,
		e_exponential : 2,
		e_stitching : 3,
		e_postscript : 4
	}
	PDFNet.HTML2PDF._WebPageSettings_ErrorHandling = {
		e_WebPageSettings_abort : 0,
		e_WebPageSettings_skip : 1,
		e_WebPageSettings_ignore : 2
	}
	PDFNet.HTML2PDF._Proxy_Type = {
		e_Proxy_default : 0,
		e_Proxy_none : 1,
		e_Proxy_http : 2,
		e_Proxy_socks5 : 3
	}
	PDFNet.Image.InputFilter = {
		e_none : 0,
		e_jpeg : 1,
		e_jp2 : 2,
		e_flate : 3,
		e_g3 : 4,
		e_g4 : 5,
		e_ascii_hex : 6
	}
	PDFNet.Optimizer._ImageSettings_CompressionMode = {
		e_ImageSettings_retain : 0,
		e_ImageSettings_flate : 1,
		e_ImageSettings_jpeg : 2,
		e_ImageSettings_jpeg2000 : 3,
		e_ImageSettings_none : 4
	}
	PDFNet.Optimizer._ImageSettings_DownsampleMode = {
		e_ImageSettings_off : 0,
		e_ImageSettings_default : 1
	}
	PDFNet.Optimizer._MonoImageSettings_CompressionMode = {
		e_MonoImageSettings_jbig2 : 0,
		e_MonoImageSettings_flate : 1,
		e_MonoImageSettings_none : 2
	}
	PDFNet.Optimizer._MonoImageSettings_DownsampleMode = {
		e_MonoImageSettings_off : 0,
		e_MonoImageSettings_default : 1
	}
	PDFNet.PageLabel.Style = {
		e_decimal : 0,
		e_roman_uppercase : 1,
		e_roman_lowercase : 2,
		e_alphabetic_uppercase : 3,
		e_alphabetic_lowercase : 4,
		e_none : 5
	}
	PDFNet.PageSet.Filter = {
		e_all : 0,
		e_even : 1,
		e_odd : 2
	}
	PDFNet.PatternColor.Type = {
		e_uncolored_tiling_pattern : 0,
		e_colored_tiling_pattern : 1,
		e_shading : 2,
		e_null : 3
	}
	PDFNet.PatternColor.TilingType = {
		e_constant_spacing : 0,
		e_no_distortion : 1,
		e_constant_spacing_fast_fill : 2
	}
	PDFNet.PDFDoc.InsertFlag = {
		e_none : 0,
		e_insert_bookmark : 1
	}
	PDFNet.PDFDoc.ExtractFlag = {
		e_forms_only : 0,
		e_annots_only : 1,
		e_both : 2
	}
	PDFNet.PDFDocViewPrefs.PageMode = {
		e_UseNone : 0,
		e_UseThumbs : 1,
		e_UseBookmarks : 2,
		e_FullScreen : 3,
		e_UseOC : 4,
		e_UseAttachments : 5
	}
	PDFNet.PDFDocViewPrefs.PageLayout = {
		e_Default : 0,
		e_SinglePage : 1,
		e_OneColumn : 2,
		e_TwoColumnLeft : 3,
		e_TwoColumnRight : 4,
		e_TwoPageLeft : 5,
		e_TwoPageRight : 6
	}
	PDFNet.PDFDocViewPrefs.ViewerPref = {
		e_HideToolbar : 0,
		e_HideMenubar : 1,
		e_HideWindowUI : 2,
		e_FitWindow : 3,
		e_CenterWindow : 4,
		e_DisplayDocTitle : 5
	}
	PDFNet.PDFRasterizer.Type = {
		e_BuiltIn : 0,
		e_GDIPlus : 1
	}
	PDFNet.PDFRasterizer.OverprintPreviewMode = {
		e_op_off : 0,
		e_op_on : 1,
		e_op_pdfx_on : 2
	}
	PDFNet.PDFRasterizer.ColorPostProcessMode = {
		e_postprocess_none : 0,
		e_postprocess_invert : 1
	}
	PDFNet.PDFDraw.PixelFormat = {
		e_rgba : 0,
		e_bgra : 1,
		e_rgb : 2,
		e_bgr : 3,
		e_gray : 4,
		e_gray_alpha : 5,
		e_cmyk : 6
	}
	PDFNet.PDFNet.CloudErrorCode = {
		e_STATUS_ERR : 0,
		e_STATUS_OK : 1,
		e_STATUS_NETWORK_ERR : 2,
		e_STATUS_BAD_CREDENTIALS : 3,
		e_STATUS_SERVICE_DOWN : 4,
		e_STATUS_INVALID_OPERATION : 5,
		e_STATUS_NUM : 6
	}
	PDFNet.PDFNet.CMSType = {
		e_lcms : 0,
		e_icm : 1,
		e_no_cms : 2
	}
	PDFNet.PDFNet.CharacterOrdering = {
		e_Identity : 0,
		e_Japan1 : 1,
		e_Japan2 : 2,
		e_GB1 : 3,
		e_CNS1 : 4,
		e_Korea1 : 5
	}
	PDFNet.PDFNet.LogLevel = {
		e_LogLevel_Off : -1,
		e_LogLevel_Fatal : 5,
		e_LogLevel_Error : 4,
		e_LogLevel_Warning : 3,
		e_LogLevel_Info : 2,
		e_LogLevel_Trace : 1,
		e_LogLevel_Debug : 0
	}
	PDFNet.Shading.Type = {
		e_function_shading : 0,
		e_axial_shading : 1,
		e_radial_shading : 2,
		e_free_gouraud_shading : 3,
		e_lattice_gouraud_shading : 4,
		e_coons_shading : 5,
		e_tensor_shading : 6,
		e_null : 7
	}
	PDFNet.Stamper.SizeType = {
		e_relative_scale : 1,
		e_absolute_size : 2,
		e_font_size : 3
	}
	PDFNet.Stamper.TextAlignment = {
		e_align_left : -1,
		e_align_center : 0,
		e_align_right : 1
	}
	PDFNet.Stamper.HorizontalAlignment = {
		e_horizontal_left : -1,
		e_horizontal_center : 0,
		e_horizontal_right : 1
	}
	PDFNet.Stamper.VerticalAlignment = {
		e_vertical_bottom : -1,
		e_vertical_center : 0,
		e_vertical_top : 1
	}
	PDFNet.TextExtractor.ProcessingFlags = {
		e_no_ligature_exp : 1,
		e_no_dup_remove : 2,
		e_punct_break : 4,
		e_remove_hidden_text : 8,
		e_no_invisible_text : 16
	}
	PDFNet.TextExtractor.XMLOutputFlags = {
		e_words_as_elements : 1,
		e_output_bbox : 2,
		e_output_style_info : 4
	}
	PDFNet.TextSearch.ResultCode = {
		e_done : 0,
		e_page : 1,
		e_found : 2
	}
	PDFNet.TextSearch.Mode = {
		e_reg_expression : 1,
		e_case_sensitive : 2,
		e_whole_word : 4,
		e_search_up : 8,
		e_page_stop : 16,
		e_highlight : 32,
		e_ambient_string : 64
	}
	PDFNet.Obj.Type = {
		e_null : 0,
		e_bool : 1,
		e_number : 2,
		e_name : 3,
		e_string : 4,
		e_dict : 5,
		e_array : 6,
		e_stream : 7
	}
	PDFNet.SDFDoc.SaveOptions = {
		e_incremental : 1,
		e_remove_unused : 2,
		e_hex_strings : 4,
		e_omit_xref : 8,
		e_linearized : 16,
		e_compatibility : 32
	}
	PDFNet.SecurityHandler.Permission = {
		e_owner : 1,
		e_doc_open : 2,
		e_doc_modify : 3,
		e_print : 4,
		e_print_high : 5,
		e_extract_content : 6,
		e_mod_annot : 7,
		e_fill_forms : 8,
		e_access_support : 9,
		e_assemble_doc : 10
	}
	PDFNet.SecurityHandler.AlgorithmType = {
		e_RC4_40 : 1,
		e_RC4_128 : 2,
		e_AES : 3
	}

		PDFNet.Iterator.prototype.hasNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasNext'. Expected "+0+" arguments. Function Signature: hasNext()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.hasNext', {"itr": this.id}, this.userPriority);
	},

		PDFNet.Iterator.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.next', {"itr": this.id}, this.userPriority);
	},

		PDFNet.Iterator.prototype.assign = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+0+" arguments. Function Signature: assign()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.assign', {"right": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

		PDFNet.Iterator.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.destroy', {"itr": this.id}, this.userPriority);
	},

		PDFNet.DictIterator.prototype.hasNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasNext'. Expected "+0+" arguments. Function Signature: hasNext()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.hasNext', {"itr": this.id}, this.userPriority);
	},

		PDFNet.DictIterator.prototype.key = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'key'. Expected "+0+" arguments. Function Signature: key()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.key', {"itr": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.DictIterator.prototype.value = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'value'. Expected "+0+" arguments. Function Signature: value()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.value', {"itr": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.DictIterator.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.next', {"itr": this.id}, this.userPriority);
	},

		PDFNet.DictIterator.prototype.assign = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+0+" arguments. Function Signature: assign()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.assign', {"right": this.id}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

		PDFNet.DictIterator.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('DictIterator.destroy', {"itr": this.id}, this.userPriority);
	},

		PDFNet.Matrix2D.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'copy'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.copy', {"m": this}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* The Set method sets the elements of this matrix.
	*
	* @param a the matrix element in the first row, first column.
	* @param b the matrix element in the first row, second column.
	* @param c the matrix element in the second row, first column.
	* @param d the matrix element in the second row, second column.
	* @param h the matrix element in the third row, first column.
	* @param v the matrix element in the third row, second column.
	*/
		PDFNet.Matrix2D.prototype.set = function(a, b, c, d, h, v)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'set'. Expected "+6+" arguments. Function Signature: set(number, number, number, number, number, number)")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'set' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("2nd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("2nd input argument '"+b+"' in function 'set' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("3rd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("3rd input argument '"+c+"' in function 'set' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("4th input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("4th input argument '"+d+"' in function 'set' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("5th input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("5th input argument '"+h+"' in function 'set' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("6th input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("6th input argument '"+v+"' in function 'set' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: set(number, number, number, number, number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'set'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Matrix2D.set"; // TRN_Matrix2D* matrix
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.set', {"matrix": this, "a": a, "b": b, "c": c, "d": d, "h": h, "v": v}, this.userPriority).then(function(id){
			copyFunc(id.matrix, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* the Concat method updates this matrix with the product of itself and another matrix
	* specified through an argument list.
	*
	* @param a the matrix element in the first row, first column.
	* @param b the matrix element in the first row, second column.
	* @param c the matrix element in the second row, first column.
	* @param d the matrix element in the second row, second column.
	* @param h the matrix element in the third row, first column.
	* @param v the matrix element in the third row, second column.
	*/
		PDFNet.Matrix2D.prototype.concat = function(a, b, c, d, h, v)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'concat'. Expected "+6+" arguments. Function Signature: concat(number, number, number, number, number, number)")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'concat' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("2nd input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("2nd input argument '"+b+"' in function 'concat' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("3rd input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("3rd input argument '"+c+"' in function 'concat' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("4th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("4th input argument '"+d+"' in function 'concat' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("5th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("5th input argument '"+h+"' in function 'concat' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("6th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("6th input argument '"+v+"' in function 'concat' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'concat'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Matrix2D.concat"; // TRN_Matrix2D* matrix
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.concat', {"matrix": this, "a": a, "b": b, "c": c, "d": d, "h": h, "v": v}, this.userPriority).then(function(id){
			copyFunc(id.matrix, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.Matrix2D.prototype.equals = function(m2)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'equals'. Expected "+1+" argument. Function Signature: equals(Matrix2D)")};
		if(m2 instanceof Promise) {throw new TypeError("1st input argument in function 'equals' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(m2 instanceof PDFNet.Matrix2D) && m2.name != "Matrix2D") {
			if(typeof m2 == "object") {throw new TypeError("1st input argument in function 'equals' is of type '"+m2.name+"'. Expected type 'Matrix2D'. Function Signature: equals(Matrix2D).");}
			else {throw new TypeError("1st input argument '"+m2+"' in function 'equals' is of type '"+(typeof m2)+"'. Expected type 'Matrix2D'. Function Signature: equals(Matrix2D).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'equals'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof m2.yieldFunction != "undefined") {throw new Error("Function '"+m2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'equals'. Perhaps a yield statement is required for '"+m2.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.equals', {"m1": this, "m2": m2}, this.userPriority);
	},

		PDFNet.Matrix2D.prototype.mult = function(in_out_x, in_out_y)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'mult'. Expected "+2+" arguments. Function Signature: mult(number, number)")};
		if(in_out_x instanceof Promise) {throw new TypeError("1st input argument in function 'mult' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_out_x != "number") {throw new TypeError("1st input argument '"+in_out_x+"' in function 'mult' is of type '"+(typeof in_out_x)+"'. Expected type 'number'. Function Signature: mult(number, number).");}
		if(in_out_y instanceof Promise) {throw new TypeError("2nd input argument in function 'mult' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_out_y != "number") {throw new TypeError("2nd input argument '"+in_out_y+"' in function 'mult' is of type '"+(typeof in_out_y)+"'. Expected type 'number'. Function Signature: mult(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'mult'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.mult', {"matrix": this, "in_out_x": in_out_x, "in_out_y": in_out_y}, this.userPriority);
	},

	/**
	* @return A promise that resolves to if this matrix is invertible, the Inverse method returns its inverse matrix.
	*/
		PDFNet.Matrix2D.prototype.inverse = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'inverse'. Expected "+0+" arguments. Function Signature: inverse()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'inverse'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.inverse', {"matrix": this}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* The Translate method updates this matrix with the product of itself and a
	* translation matrix (i.e. it is equivalent to this.m_h += h; this.m_v += v).
	*
	* @param h the horizontal component of the translation.
	* @param v the vertical component of the translation.
	*
	* @return A promise that resolves to updated this matrix
	*/
		PDFNet.Matrix2D.prototype.translate = function(h, v)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'translate'. Expected "+2+" arguments. Function Signature: translate(number, number)")};
		if(h instanceof Promise) {throw new TypeError("1st input argument in function 'translate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("1st input argument '"+h+"' in function 'translate' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: translate(number, number).");}
		if(v instanceof Promise) {throw new TypeError("2nd input argument in function 'translate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("2nd input argument '"+v+"' in function 'translate' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: translate(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'translate'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Matrix2D.translate"; // TRN_Matrix2D* matrix
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.translate', {"matrix": this, "h": h, "v": v}, this.userPriority).then(function(id){
			copyFunc(id.matrix, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* The Scale method updates this matrix with the product of itself and a scaling matrix.
	* @param h the horizontal scale factor.
	* @param v the vertical scale factor
	*
	* @return A promise that resolves to updated this matrix
	*/
		PDFNet.Matrix2D.prototype.scale = function(h, v)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'scale'. Expected "+2+" arguments. Function Signature: scale(number, number)")};
		if(h instanceof Promise) {throw new TypeError("1st input argument in function 'scale' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("1st input argument '"+h+"' in function 'scale' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: scale(number, number).");}
		if(v instanceof Promise) {throw new TypeError("2nd input argument in function 'scale' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("2nd input argument '"+v+"' in function 'scale' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: scale(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'scale'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Matrix2D.scale"; // TRN_Matrix2D* matrix
		return PDFNet.messageHandler.sendWithPromise('Matrix2D.scale', {"matrix": this, "h": h, "v": v}, this.userPriority).then(function(id){
			copyFunc(id.matrix, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Create zero matrix (0 0 0 0 0 0)
	*/
		PDFNet.Matrix2D.createZeroMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createZeroMatrix'. Expected "+0+" arguments. Function Signature: createZeroMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('matrix2DCreateZeroMatrix', {}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* Create identity matrix (1 0 0 1 0 0)
	*/
		PDFNet.Matrix2D.createIdentityMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIdentityMatrix'. Expected "+0+" arguments. Function Signature: createIdentityMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('matrix2DCreateIdentityMatrix', {}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to a rotation matrix for a given angle.
	* @param angle the angle of rotation in radians.
	* Positive values specify clockwise rotation.
	*/
		PDFNet.Matrix2D.createRotationMatrix = function(angle)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createRotationMatrix'. Expected "+1+" argument. Function Signature: createRotationMatrix(number)")};
		if(angle instanceof Promise) {throw new TypeError("1st input argument in function 'createRotationMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof angle != "number") {throw new TypeError("1st input argument '"+angle+"' in function 'createRotationMatrix' is of type '"+(typeof angle)+"'. Expected type 'number'. Function Signature: createRotationMatrix(number).");}
		return PDFNet.messageHandler.sendWithPromise('matrix2DCreateRotationMatrix', {"angle": angle}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* construct a PDF::Field from a SDF dictionary representing a terminal field node.
	*/
		PDFNet.Field.create = function(field_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(field_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(field_dict instanceof PDFNet.Obj)) {
			if(typeof field_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+field_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+field_dict+"' in function 'create' is of type '"+(typeof field_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fieldCreate', {"field_dict": field_dict.id}, this.userPriority).then(function(id){
			//there is a return type Field
			if(id == "0"){
				return null;
			}
			return new PDFNet.Field(id);
		});
	},

		PDFNet.Field.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Field)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Field) && right.name != "Field") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Field'. Function Signature: assign(Field).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Field'. Function Signature: assign(Field).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Field.assign"; // TRN_Field* left
		return PDFNet.messageHandler.sendWithPromise('Field.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Field.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'destroy'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.destroy"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.destroy', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to whether this is a valid (non-null) Field. If the
	* function returns false the underlying SDF/Cos object is null and
	* the Field object should be treated as null as well.
	*/
		PDFNet.Field.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.isValid', {"field": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the field's value, whose type/format varies depending on the field type.
	* See the descriptions of individual field types for further information.
	*/
		PDFNet.Field.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getType'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getType', {"field": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
	* value is not specified.
	*
	* The format of field's value varies depending on the field type.
	*/
		PDFNet.Field.prototype.getValue = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getValue'. Expected "+0+" arguments. Function Signature: getValue()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getValue'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getValue"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getValue', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

		PDFNet.Field.prototype.getValueAsString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getValueAsString'. Expected "+0+" arguments. Function Signature: getValueAsString()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getValueAsString'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getValueAsString"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getValueAsString', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to the default value to which the field reverts when a reset-form action
	* is executed or NULL if the default value is not specified.
	*
	* The format of field's value varies depending on the field type.
	*/
		PDFNet.Field.prototype.getDefaultValueAsString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDefaultValueAsString'. Expected "+0+" arguments. Function Signature: getDefaultValueAsString()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getDefaultValueAsString'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getDefaultValueAsString"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getDefaultValueAsString', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* sets the value of the field (i.e. the value of the field's /V key).
	* The format of field's value varies depending on the field type.
	*
	* @param value the new field value.
	*
	* @note in order to remove/erase the existing value use pass a SDF::Null
	* object to SetValue().
	*
	* @note <p>In PDF, Field's value is separate from its annotation (i.e. how the
	* field appears on the page). After you modify Field's value you need to
	* refresh Field's appearance using RefreshAppearance() method.
	* </p><p>
	* Alternatively, you can delete "AP" entry from the Widget annotation and set
	* "NeedAppearances" flag in AcroForm dictionary (i.e.
	* doc.GetAcroForm().Put("NeedAppearances", Obj.CreateBool(true)); )
	* This will force viewer application to auto-generate new field appearances
	* every time the document is opened.
	* </p><p>
	* Yet another option is to generate a custom annotation appearance using
	* ElementBuilder and ElementWriter and then set the "AP" entry in the widget
	* dictionary to the new appearance stream. This functionality is useful in
	* applications that need advanced control over how the form fields are rendered.
	* </p>
	*/
		PDFNet.Field.prototype.setValueAsString = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setValueAsString'. Expected "+1+" argument. Function Signature: setValueAsString(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setValueAsString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setValueAsString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setValueAsString(string).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setValueAsString'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setValueAsString"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setValueAsString', {"field": this, "value": value}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.Field.prototype.setValue = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setValue'. Expected "+1+" argument. Function Signature: setValue(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setValue' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setValue' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setValue(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setValue' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setValue(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setValue'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setValue"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setValue', {"field": this, "value": value.id}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* sets the value of a check-box or radio-button field.
	* @param value If true, the filed will be set to 'True', if false the field will
	* be set to 'False'.
	*
	* @note This method is usually for check-box and radio button fields.
	*/
		PDFNet.Field.prototype.setValueAsBool = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setValueAsBool'. Expected "+1+" argument. Function Signature: setValueAsBool(boolean)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setValueAsBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("1st input argument '"+value+"' in function 'setValueAsBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: setValueAsBool(boolean).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setValueAsBool'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setValueAsBool"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setValueAsBool', {"field": this, "value": value}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to field value as a boolean.
	* @note This method is usually for check-box and radio button fields.
	*/
		PDFNet.Field.prototype.getValueAsBool = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getValueAsBool'. Expected "+0+" arguments. Function Signature: getValueAsBool()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getValueAsBool'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getValueAsBool', {"field": this}, this.userPriority);
	},

	/**
	* regenerates the appearance stream for the Widget Annotation containing
	* variable text. Call this method if you modified field's value and would
	* like to update field's appearance.
	*
	* @note If this field contains text, and has been added to a rotated page, the text in
	* the field may be rotated. If RefreshAppearance is called *after* the field is added
	* to a rotated page, then any text will be rotated in the opposite direction of the page
	* rotation. If this method is called *before* the field is added to any rotated page, then
	* no counter rotation will be applied. If you wish to call RefreshAppearance on a field
	* already added to a rotated page, but you don't want the text to be rotated, you can do one
	* of the following; temporarily un-rotate the page, or, temporarily remove the "P" object
	* from the field.
	*/
		PDFNet.Field.prototype.refreshAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'refreshAppearance'. Expected "+0+" arguments. Function Signature: refreshAppearance()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'refreshAppearance'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.refreshAppearance"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.refreshAppearance', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* removes any appearances associated with the field.
	*/
		PDFNet.Field.prototype.eraseAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'eraseAppearance'. Expected "+0+" arguments. Function Signature: eraseAppearance()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'eraseAppearance'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.eraseAppearance"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.eraseAppearance', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.Field.prototype.getDefaultValue = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDefaultValue'. Expected "+0+" arguments. Function Signature: getDefaultValue()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getDefaultValue'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getDefaultValue"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getDefaultValue', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* @return A promise that resolves to a string representing the fully qualified name of the field
	* (e.g. "employee.name.first").
	*/
		PDFNet.Field.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getName'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getName"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getName', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to a string representing the partial name of the field (e.g.
	* "first" when "employee.name.first" is fully qualified name).
	*/
		PDFNet.Field.prototype.getPartialName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPartialName'. Expected "+0+" arguments. Function Signature: getPartialName()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getPartialName'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getPartialName"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getPartialName', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* modifies the field name.
	*
	* @param field_name a string representing the fully qualified name of
	* the field (e.g. "employee.name.first").
	*/
		PDFNet.Field.prototype.rename = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'rename'. Expected "+1+" argument. Function Signature: rename(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'rename' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'rename' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: rename(string).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'rename'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.rename"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.rename', {"field": this, "field_name": field_name}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to true if this Field is a Widget Annotation
	*
	* Determines whether or not this Field is an Annotation.
	*/
		PDFNet.Field.prototype.isAnnot = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isAnnot'. Expected "+0+" arguments. Function Signature: isAnnot()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isAnnot'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.isAnnot', {"field": this}, this.userPriority);
	},

	/**
	* Sets the signature handler to use for adding a signature to this field. If the signature handler is not found
	* in PDFDoc's signature handlers list, this field will not be signed. To add signature handlers, use PDFDoc.AddSignatureHandler
	* method.
	*
	* If a signature handler is already assigned to this field and this method is called once again, the associate signature
	* handler for this field will be updated with the new handler.
	*
	* @param signature_handler_id The unique id of the SignatureHandler to use for adding signature in this field.
	*
	* @return A promise that resolves to the signature dictionary created using the SignatureHandler, or NULL pointer if the signature handler is not found.
	*/
		PDFNet.Field.prototype.useSignatureHandler = function(signature_handler_id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'useSignatureHandler'. Expected "+1+" argument. Function Signature: useSignatureHandler(number)")};
		if(signature_handler_id instanceof Promise) {throw new TypeError("1st input argument in function 'useSignatureHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof signature_handler_id != "number") {throw new TypeError("1st input argument '"+signature_handler_id+"' in function 'useSignatureHandler' is of type '"+(typeof signature_handler_id)+"'. Expected type 'number'. Function Signature: useSignatureHandler(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'useSignatureHandler'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.useSignatureHandler"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.useSignatureHandler', {"field": this, "signature_handler_id": signature_handler_id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* @return A promise that resolves to the value of given field flag
	*/
		PDFNet.Field.prototype.getFlag = function(flag)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFlag'. Expected "+1+" argument. Function Signature: getFlag(number)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'getFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'getFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: getFlag(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFlag'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getFlag', {"field": this, "flag": flag}, this.userPriority);
	},

	/**
	* set the value of given FieldFlag.
	*
	* @note You can use this method to set the field as read-only.
	* An alternative approach to set the field as read only is using Page.Flatten(...)
	* method. Unlike Flatten(...), the result of SetFlag(...) can be programatically
	* reversed.
	*/
		PDFNet.Field.prototype.setFlag = function(flag, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setFlag'. Expected "+2+" arguments. Function Signature: setFlag(number, boolean)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'setFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'setFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: setFlag(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'setFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'setFlag' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: setFlag(number, boolean).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setFlag'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setFlag"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setFlag', {"field": this, "flag": flag, "value": value}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the form of quadding (justification) to be used in displaying
	* the text fields.
	*/
		PDFNet.Field.prototype.getJustification = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getJustification'. Expected "+0+" arguments. Function Signature: getJustification()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getJustification'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getJustification"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getJustification', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* sets the justification to be used in displaying the text field.
	* @note This method is specific to a text field.
	*/
		PDFNet.Field.prototype.setJustification = function(j)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setJustification'. Expected "+1+" argument. Function Signature: setJustification(number)")};
		if(j instanceof Promise) {throw new TypeError("1st input argument in function 'setJustification' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof j != "number") {throw new TypeError("1st input argument '"+j+"' in function 'setJustification' is of type '"+(typeof j)+"'. Expected type 'number'. Function Signature: setJustification(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setJustification'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setJustification"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setJustification', {"field": this, "j": j}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* sets the maximum length of the field's text, in characters.
	* @note This method is specific to a text field.
	*/
		PDFNet.Field.prototype.setMaxLen = function(max_len)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMaxLen'. Expected "+1+" argument. Function Signature: setMaxLen(number)")};
		if(max_len instanceof Promise) {throw new TypeError("1st input argument in function 'setMaxLen' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof max_len != "number") {throw new TypeError("1st input argument '"+max_len+"' in function 'setMaxLen' is of type '"+(typeof max_len)+"'. Expected type 'number'. Function Signature: setMaxLen(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setMaxLen'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.setMaxLen"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.setMaxLen', {"field": this, "max_len": max_len}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the maximum length of the field's text, in characters, or a
	* negative number if the length is not limited.
	* @note This method is specific to a text field.
	*/
		PDFNet.Field.prototype.getMaxLen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMaxLen'. Expected "+0+" arguments. Function Signature: getMaxLen()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getMaxLen'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getMaxLen', {"field": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the default graphics state that should be used in formatting the
	* text. The state corresponds to /DA entry in the field dictionary.
	*/
		PDFNet.Field.prototype.getDefaultAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDefaultAppearance'. Expected "+0+" arguments. Function Signature: getDefaultAppearance()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getDefaultAppearance'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.getDefaultAppearance"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.getDefaultAppearance', {"field": this}, this.userPriority).then(function(id){
			//there is a return type GState
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return new PDFNet.GState(id.result);
		});
	},

	/**
	* @return A promise that resolves to the rectangle that should be refreshed after changing a field.
	*/
		PDFNet.Field.prototype.getUpdateRect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUpdateRect'. Expected "+0+" arguments. Function Signature: getUpdateRect()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getUpdateRect'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getUpdateRect', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* Flatten/Merge existing form field appearances with the page content and
	* remove widget annotation.
	*
	* Form 'flattening' refers to the operation that changes active form fields
	* into a static area that is part of the PDF document, just like the other
	* text and images in the document. A completely flattened PDF form does not
	* have any widget annotations or interactive fields.
	*
	* @note an alternative approach to set the field as read only is using
	* Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
	* the result of Flatten() operation can not be programatically reversed.
	*/
		PDFNet.Field.prototype.flatten = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'flatten'. Expected "+1+" argument. Function Signature: flatten(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'flatten' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'flatten' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: flatten(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'flatten' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: flatten(Page).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'flatten'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Field.flatten"; // TRN_Field* field
		return PDFNet.messageHandler.sendWithPromise('Field.flatten', {"field": this, "page": page.id}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Some of the Field attributes are designated as inheritable.
	* If such an attribute is omitted from a Field object, its value is inherited
	* from an ancestor node in the Field tree. If the attribute is a required one,
	* a value must be supplied in an ancestor node; if it is optional and no
	* inherited value is specified, the default value should be used.
	*
	* The function walks up the Field inheritance tree in search for specified
	* attribute.
	*
	* @return A promise that resolves to the attribute value if the given attribute name was found
	* or a NULL object if the given attribute name was not found.
	*
	*  Resources dictionary (Required; inheritable)
	*  MediaBox rectangle (Required; inheritable)
	*  CropBox rectangle (Optional; inheritable)
	*  Rotate integer (Optional; inheritable)
	*/
		PDFNet.Field.prototype.findInheritedAttribute = function(attrib)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'findInheritedAttribute'. Expected "+1+" argument. Function Signature: findInheritedAttribute(string)")};
		if(attrib instanceof Promise) {throw new TypeError("1st input argument in function 'findInheritedAttribute' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof attrib != "string") {throw new TypeError("1st input argument '"+attrib+"' in function 'findInheritedAttribute' is of type '"+(typeof attrib)+"'. Expected type 'string'. Function Signature: findInheritedAttribute(string).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'findInheritedAttribute'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.findInheritedAttribute', {"field": this, "attrib": attrib}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object.
	*/
		PDFNet.Field.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getSDFObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getSDFObj', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Returns the total number of options in a list or combo box.
	*/
		PDFNet.Field.prototype.getOptCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOptCount'. Expected "+0+" arguments. Function Signature: getOptCount()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getOptCount'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getOptCount', {"field": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the string of the option at the givent index.
	* @note The index must be less than the value returned by GetOptCount().
	*/
		PDFNet.Field.prototype.getOpt = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getOpt'. Expected "+1+" argument. Function Signature: getOpt(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getOpt' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getOpt' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getOpt(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getOpt'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Field.getOpt', {"field": this, "index": index}, this.userPriority);
	},

		PDFNet.FDFDoc.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreate', {}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Create a FDF document from an existing SDF/Cos document.
	*
	* @param sdfdoc An SDF document. FDFDoc will take the ownership of the low-level document.
	* @note the SDFDoc will become invalid.  If you would
	* like to access the low level document use GetSDFDoc
	*/
		PDFNet.FDFDoc.createFromSDFDoc = function(sdfdoc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromSDFDoc'. Expected "+1+" argument. Function Signature: createFromSDFDoc(SDFDoc)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromSDFDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createFromSDFDoc' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromSDFDoc(SDFDoc).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createFromSDFDoc' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createFromSDFDoc(SDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromSDFDoc', {"sdfdoc": sdfdoc.id}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Open an existing FDF document
	*
	* @param filepath - pathname to the file.
	*/
		PDFNet.FDFDoc.createFromFilePath = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFilePath'. Expected "+1+" argument. Function Signature: createFromFilePath(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFilePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromFilePath' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromFilePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromFilePath', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

		PDFNet.FDFDoc.createFromUFilePath = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromUFilePath'. Expected "+1+" argument. Function Signature: createFromUFilePath(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromUFilePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromUFilePath' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromUFilePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromUFilePath', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Open an existing FDF document
	*
	* @param stream - input stream containing a serialized document. The input stream may be a
	* random-access file, memory buffer, slow HTTP connection etc.
	*
	* @note if the input stream doesn't support Seek() operation the document will load whole
	* data stream in memory before parsing. In case of linearized FDF, the document may be parsed
	* on-the-fly while it is being loaded in memory. Note that since StdFile implements Seek()
	* interface, the document does not have to be fully in memory before it is used.
	*
	* @note Make sure to call InitSecurityHandler() after FDFDoc(...) for encrypted documents.
	*/
		PDFNet.FDFDoc.createFromStream = function(stream)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromStream'. Expected "+1+" argument. Function Signature: createFromStream(Filter)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Filter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'createFromStream' is of type '"+stream.name+"'. Expected type 'Filter'. Function Signature: createFromStream(Filter).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'createFromStream' is of type '"+(typeof stream)+"'. Expected type 'Filter'. Function Signature: createFromStream(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromStream', {"stream": stream.id}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Open a SDF/Cos document from a memory buffer.
	* @note the document should be fully loaded in the memory buffer.
	* @note the buffer ownership is not transfered to the Document so the user should
	* clean-up if necessary.
	*
	* @param buf - a memory buffer containing the serialized document
	* @param buf_size - the size of memory buffer.
	*/
		PDFNet.FDFDoc.createFromMemoryBuffer = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromMemoryBuffer'. Expected "+1+" argument. Function Signature: createFromMemoryBuffer(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'createFromMemoryBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'createFromMemoryBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemoryBuffer(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'createFromMemoryBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemoryBuffer(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromMemoryBuffer', {"buf": buf.buffer}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

		PDFNet.FDFDoc.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.destroy', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - true if document was modified, false otherwise
	*/
		PDFNet.FDFDoc.prototype.isModified = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isModified'. Expected "+0+" arguments. Function Signature: isModified()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.isModified', {"doc": this.id}, this.userPriority);
	},

	/**
	* Saves the document to a file.
	*
	* If a full save is requested to the original path, the file is saved to a file
	* system-determined temporary file, the old file is deleted, and the temporary file
	* is renamed to path.
	*
	* A full save with remove unused or linearization option may re-arrange object in
	* the cross reference table. Therefore all pointers and references to document objects
	* and resources should be re acquired in order to continue document editing.
	*
	* In order to use incremental save the specified path must match original path and
	* e_incremental flag bit should be set.
	*
	* @param path - The full path name to which the file is saved.
	*
	* @exception - if the file can't be opened for saving or if there is a problem during Save
	*	an Exception object will be thrown.
	*/
		PDFNet.FDFDoc.prototype.save = function(path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'save'. Expected "+1+" argument. Function Signature: save(string)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'save' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: save(string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.save', {"doc": this.id, "path": path}, this.userPriority);
	},

		PDFNet.FDFDoc.prototype.saveMemoryBuffer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'saveMemoryBuffer'. Expected "+0+" arguments. Function Signature: saveMemoryBuffer()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.saveMemoryBuffer', {"doc": this.id}, this.userPriority).then(function(id){
			return new Uint8Array(id);
		});
	},

	/**
	* @return A promise that resolves to - A dictionary representing the Cos root of the document (document's trailer)
	*/
		PDFNet.FDFDoc.prototype.getTrailer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTrailer'. Expected "+0+" arguments. Function Signature: getTrailer()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getTrailer', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to - A dictionary representing the Cos root of the document (/Root entry
	* within the trailer dictionary)
	*/
		PDFNet.FDFDoc.prototype.getRoot = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRoot'. Expected "+0+" arguments. Function Signature: getRoot()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getRoot', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the FDF dictionary located in "/Root" or NULL if dictionary is not present.
	*/
		PDFNet.FDFDoc.prototype.getFDF = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFDF'. Expected "+0+" arguments. Function Signature: getFDF()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getFDF', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Get the PDF document file that this FDF file was exported from or is intended
	* to be imported into.
	*
	* @return A promise that resolves to a String with the PDF document file name.
	*/
		PDFNet.FDFDoc.prototype.getPDFFileName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPDFFileName'. Expected "+0+" arguments. Function Signature: getPDFFileName()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getPDFFileName', {"doc": this.id}, this.userPriority);
	},

	/**
	* Set the PDF document file that this FDF file was exported from or is intended
	* to be imported into.
	*
	* @param filepath - pathname to the file.
	*/
		PDFNet.FDFDoc.prototype.setPDFFileName = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPDFFileName'. Expected "+1+" argument. Function Signature: setPDFFileName(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'setPDFFileName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'setPDFFileName' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: setPDFFileName(string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.setPDFFileName', {"doc": this.id, "filepath": filepath}, this.userPriority);
	},

	/**
	* Get the ID entry from "/Root/FDF" dictionary.
	*
	* @return A promise that resolves to - An object representing the ID entry in "/Root/FDF" dictionary.
	*/
		PDFNet.FDFDoc.prototype.getID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getID'. Expected "+0+" arguments. Function Signature: getID()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getID', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set the ID entry in "/Root/FDF" dictionary.
	*
	* @param id - ID array object.
	*/
		PDFNet.FDFDoc.prototype.setID = function(id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setID'. Expected "+1+" argument. Function Signature: setID(Obj)")};
		if(id instanceof Promise) {throw new TypeError("1st input argument in function 'setID' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(id instanceof PDFNet.Obj)) {
			if(typeof id == "object") {throw new TypeError("1st input argument in function 'setID' is of type '"+id.name+"'. Expected type 'Obj'. Function Signature: setID(Obj).");}
			else {throw new TypeError("1st input argument '"+id+"' in function 'setID' is of type '"+(typeof id)+"'. Expected type 'Obj'. Function Signature: setID(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.setID', {"doc": this.id, "id": id.id}, this.userPriority);
	},

	/**
	* An interactive form (sometimes referred to as an AcroForm) is a
	* collection of fields for gathering information interactively from
	* the user. A FDF document may contain any number of fields appearing
	* on any combination of pages, all of which make up a single, global
	* interactive form spanning the entire document.
	*
	* The following methods are used to access and manipulate Interactive form
	* fields (sometimes referred to as AcroForms).
	*
	* @return A promise that resolves to an iterator to the first Filed in the document.
	* @note if the document has no AcroForms, HasNext()
	* will return false.
	*/
		PDFNet.FDFDoc.prototype.getFieldIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIteratorBegin'. Expected "+0+" arguments. Function Signature: getFieldIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getFieldIteratorBegin', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* field_name - a string representing the fully qualified name of
	* the field (e.g. "employee.name.first").
	*
	* @return A promise that resolves to a FDFField associated with the given field_name or invalid
	* field (null) if the field is not found.
	*/
		PDFNet.FDFDoc.prototype.getFieldIterator = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIterator'. Expected "+1+" argument. Function Signature: getFieldIterator(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getFieldIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'getFieldIterator' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: getFieldIterator(string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getFieldIterator', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

		PDFNet.FDFDoc.prototype.getField = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getField'. Expected "+1+" argument. Function Signature: getField(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'getField' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: getField(string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getField', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			//there is a return type FDFField
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFField(id);
		});
	},

	/**
	* Create a new interactive form FDFField.
	* @return A promise that resolves to
	* @exception
	*/
		PDFNet.FDFDoc.prototype.fieldCreate = function(field_name, type, field_value)
	{
		if(typeof field_value === "undefined") {field_value = new PDFNet.Obj("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'fieldCreate'. Expected "+2+" to "+3+" arguments. Function Signature: fieldCreate(string, number, Obj)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'fieldCreate' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: fieldCreate(string, number, Obj).");}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'fieldCreate' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: fieldCreate(string, number, Obj).");}
		if(field_value instanceof Promise) {throw new TypeError("3rd input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(field_value instanceof PDFNet.Obj)) {
			if(typeof field_value == "object") {throw new TypeError("3rd input argument in function 'fieldCreate' is of type '"+field_value.name+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj).");}
			else {throw new TypeError("3rd input argument '"+field_value+"' in function 'fieldCreate' is of type '"+(typeof field_value)+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.fieldCreate', {"doc": this.id, "field_name": field_name, "type": type, "field_value": field_value.id}, this.userPriority).then(function(id){
			//there is a return type FDFField
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFField(id);
		});
	},

		PDFNet.FDFDoc.prototype.fieldCreateFromString = function(field_name, type, field_value)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'fieldCreateFromString'. Expected "+3+" arguments. Function Signature: fieldCreateFromString(string, number, string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'fieldCreateFromString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'fieldCreateFromString' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: fieldCreateFromString(string, number, string).");}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'fieldCreateFromString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'fieldCreateFromString' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: fieldCreateFromString(string, number, string).");}
		if(field_value instanceof Promise) {throw new TypeError("3rd input argument in function 'fieldCreateFromString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_value != "string") {throw new TypeError("3rd input argument '"+field_value+"' in function 'fieldCreateFromString' is of type '"+(typeof field_value)+"'. Expected type 'string'. Function Signature: fieldCreateFromString(string, number, string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.fieldCreateFromString', {"doc": this.id, "field_name": field_name, "type": type, "field_value": field_value}, this.userPriority).then(function(id){
			//there is a return type FDFField
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFField(id);
		});
	},

	/**
	* @return A promise that resolves to document's SDF/Cos document
	*/
		PDFNet.FDFDoc.prototype.getSDFDoc = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFDoc'. Expected "+0+" arguments. Function Signature: getSDFDoc()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getSDFDoc', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

	/**
	* Create a new FDFDoc from XFDF input. Input can be either a XFDF file path, or the XFDF data itself.
	* @param xfdf - string containing either the file path to a XFDF file, or the XML buffer containing the XFDF.
	* @return A promise that resolves to a new FDFDoc.
	*/
		PDFNet.FDFDoc.createFromXFDF = function(file_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromXFDF'. Expected "+1+" argument. Function Signature: createFromXFDF(string)")};
		if(file_name instanceof Promise) {throw new TypeError("1st input argument in function 'createFromXFDF' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_name != "string") {throw new TypeError("1st input argument '"+file_name+"' in function 'createFromXFDF' is of type '"+(typeof file_name)+"'. Expected type 'string'. Function Signature: createFromXFDF(string).");}
		return PDFNet.messageHandler.sendWithPromise('fdfDocCreateFromXFDF', {"file_name": file_name}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* export FDF file as an XFDF file
	* @param filepath - the filepath of the exported XFDF file
	*/
		PDFNet.FDFDoc.prototype.saveAsXFDF = function(file_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'saveAsXFDF'. Expected "+1+" argument. Function Signature: saveAsXFDF(string)")};
		if(file_name instanceof Promise) {throw new TypeError("1st input argument in function 'saveAsXFDF' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_name != "string") {throw new TypeError("1st input argument '"+file_name+"' in function 'saveAsXFDF' is of type '"+(typeof file_name)+"'. Expected type 'string'. Function Signature: saveAsXFDF(string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.saveAsXFDF', {"doc": this.id, "file_name": file_name}, this.userPriority);
	},

	/**
	* Export FDF file as a XFDF string
	* @return A promise that resolves to a UString containing the XFDF representation of the FDF file
	*/
		PDFNet.FDFDoc.prototype.saveAsXFDFAsString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'saveAsXFDFAsString'. Expected "+0+" arguments. Function Signature: saveAsXFDFAsString()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.saveAsXFDFAsString', {"doc": this.id}, this.userPriority);
	},

	/**
	* Merge the annotations from XFDF file into FDF file
	*
	* @param command_file - string containing the xml command file path or xml string of the command
	* @param permitted_user - optional user name of the permitted user
	*/
		PDFNet.FDFDoc.prototype.mergeAnnots = function(command_file, permitted_user)
	{
		if(typeof permitted_user === "undefined") {permitted_user = "";};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'mergeAnnots'. Expected "+1+" to "+2+" arguments. Function Signature: mergeAnnots(string, string)")};
		if(command_file instanceof Promise) {throw new TypeError("1st input argument in function 'mergeAnnots' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof command_file != "string") {throw new TypeError("1st input argument '"+command_file+"' in function 'mergeAnnots' is of type '"+(typeof command_file)+"'. Expected type 'string'. Function Signature: mergeAnnots(string, string).");}
		if(permitted_user instanceof Promise) {throw new TypeError("2nd input argument in function 'mergeAnnots' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof permitted_user != "string") {throw new TypeError("2nd input argument '"+permitted_user+"' in function 'mergeAnnots' is of type '"+(typeof permitted_user)+"'. Expected type 'string'. Function Signature: mergeAnnots(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.mergeAnnots', {"doc": this.id, "command_file": command_file, "permitted_user": permitted_user}, this.userPriority);
	},

	/**
	* construct a FDF::FDFField from a SDF dictionary representing a terminal field node.
	*/
		PDFNet.FDFField.create = function(field_dict, fdf_dict)
	{
		if(typeof field_dict === "undefined") {field_dict = new PDFNet.Obj("0");};
		if(typeof fdf_dict === "undefined") {fdf_dict = new PDFNet.Obj("0");};
		if(arguments.length > 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+2+" arguments. Function Signature: create(Obj, Obj)")};
		if(field_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(field_dict instanceof PDFNet.Obj)) {
			if(typeof field_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+field_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj, Obj).");}
			else {throw new TypeError("1st input argument '"+field_dict+"' in function 'create' is of type '"+(typeof field_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj, Obj).");}
		}
		if(fdf_dict instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(fdf_dict instanceof PDFNet.Obj)) {
			if(typeof fdf_dict == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+fdf_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj, Obj).");}
			else {throw new TypeError("2nd input argument '"+fdf_dict+"' in function 'create' is of type '"+(typeof fdf_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fdfFieldCreate', {"field_dict": field_dict.id, "fdf_dict": fdf_dict.id}, this.userPriority).then(function(id){
			//there is a return type FDFField
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFField(id);
		});
	},

		PDFNet.FDFField.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(FDFField)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.FDFField) && right.name != "FDFField") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'FDFField'. Function Signature: assign(FDFField).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'FDFField'. Function Signature: assign(FDFField).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "FDFField.assign"; // TRN_FDFField* left
		return PDFNet.messageHandler.sendWithPromise('FDFField.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
	* value is not specified.
	* The format of field's value varies depending on the field type.
	*/
		PDFNet.FDFField.prototype.getValue = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getValue'. Expected "+0+" arguments. Function Signature: getValue()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getValue'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "FDFField.getValue"; // TRN_FDFField* field
		return PDFNet.messageHandler.sendWithPromise('FDFField.getValue', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* Sets the value of the FDFField (the value of the field's /V key).
	* @return A promise that resolves to the value of the field (the value of its /V key) or NULL if the
	* value is not specified.
	* The format of field's value varies depending on the field type.
	*
	* @note in order to remove/erase the existing value use SetValue(SDF::Null)
	*/
		PDFNet.FDFField.prototype.setValue = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setValue'. Expected "+1+" argument. Function Signature: setValue(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setValue' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setValue' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setValue(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setValue' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setValue(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setValue'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "FDFField.setValue"; // TRN_FDFField* field
		return PDFNet.messageHandler.sendWithPromise('FDFField.setValue', {"field": this, "value": value.id}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to a string representing the fully qualified name of the field
	* (e.g. "employee.name.first").
	*/
		PDFNet.FDFField.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getName'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "FDFField.getName"; // TRN_FDFField* field
		return PDFNet.messageHandler.sendWithPromise('FDFField.getName', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to a string representing the partial name of the field (e.g.
	* "first" when "employee.name.first" is fully qualified name).
	*/
		PDFNet.FDFField.prototype.getPartialName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPartialName'. Expected "+0+" arguments. Function Signature: getPartialName()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getPartialName'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "FDFField.getPartialName"; // TRN_FDFField* field
		return PDFNet.messageHandler.sendWithPromise('FDFField.getPartialName', {"field": this}, this.userPriority).then(function(id){
			copyFunc(id.field, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to the object to the underlying SDF/Cos object.
	*/
		PDFNet.FDFField.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getSDFObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('FDFField.getSDFObj', {"field": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* The function returns the specified attribute.
	*
	* @return A promise that resolves to return the attribute value if the given attribute name
	* was found or a NULL object if the given attribute name was not found.
	*/
		PDFNet.FDFField.prototype.findAttribute = function(attrib)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'findAttribute'. Expected "+1+" argument. Function Signature: findAttribute(string)")};
		if(attrib instanceof Promise) {throw new TypeError("1st input argument in function 'findAttribute' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof attrib != "string") {throw new TypeError("1st input argument '"+attrib+"' in function 'findAttribute' is of type '"+(typeof attrib)+"'. Expected type 'string'. Function Signature: findAttribute(string).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'findAttribute'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('FDFField.findAttribute', {"field": this, "attrib": attrib}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.Filter.prototype.createASCII85Encode = function(line_width, buf_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createASCII85Encode'. Expected "+2+" arguments. Function Signature: createASCII85Encode(number, number)")};
		if(line_width instanceof Promise) {throw new TypeError("1st input argument in function 'createASCII85Encode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof line_width != "number") {throw new TypeError("1st input argument '"+line_width+"' in function 'createASCII85Encode' is of type '"+(typeof line_width)+"'. Expected type 'number'. Function Signature: createASCII85Encode(number, number).");}
		if(buf_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'createASCII85Encode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof buf_sz != "number") {throw new TypeError("2nd input argument '"+buf_sz+"' in function 'createASCII85Encode' is of type '"+(typeof buf_sz)+"'. Expected type 'number'. Function Signature: createASCII85Encode(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.createASCII85Encode', {"input_filter": this.id, "line_width": line_width, "buf_sz": buf_sz}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.prototype.createFlateEncode = function(compression_level, buf_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFlateEncode'. Expected "+2+" arguments. Function Signature: createFlateEncode(number, number)")};
		if(compression_level instanceof Promise) {throw new TypeError("1st input argument in function 'createFlateEncode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof compression_level != "number") {throw new TypeError("1st input argument '"+compression_level+"' in function 'createFlateEncode' is of type '"+(typeof compression_level)+"'. Expected type 'number'. Function Signature: createFlateEncode(number, number).");}
		if(buf_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'createFlateEncode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof buf_sz != "number") {throw new TypeError("2nd input argument '"+buf_sz+"' in function 'createFlateEncode' is of type '"+(typeof buf_sz)+"'. Expected type 'number'. Function Signature: createFlateEncode(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.createFlateEncode', {"input_filter": this.id, "compression_level": compression_level, "buf_sz": buf_sz}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createMemoryFilter = function(buf_sz, is_input)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createMemoryFilter'. Expected "+2+" arguments. Function Signature: createMemoryFilter(number, boolean)")};
		if(buf_sz instanceof Promise) {throw new TypeError("1st input argument in function 'createMemoryFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof buf_sz != "number") {throw new TypeError("1st input argument '"+buf_sz+"' in function 'createMemoryFilter' is of type '"+(typeof buf_sz)+"'. Expected type 'number'. Function Signature: createMemoryFilter(number, boolean).");}
		if(is_input instanceof Promise) {throw new TypeError("2nd input argument in function 'createMemoryFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof is_input != "boolean") {throw new TypeError("2nd input argument '"+is_input+"' in function 'createMemoryFilter' is of type '"+(typeof is_input)+"'. Expected type 'boolean'. Function Signature: createMemoryFilter(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('filterCreateMemoryFilter', {"buf_sz": buf_sz, "is_input": is_input}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGBFromElement = function(elem)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGBFromElement'. Expected "+1+" argument. Function Signature: createImage2RGBFromElement(Element)")};
		if(elem instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGBFromElement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(elem instanceof PDFNet.Element)) {
			if(typeof elem == "object") {throw new TypeError("1st input argument in function 'createImage2RGBFromElement' is of type '"+elem.name+"'. Expected type 'Element'. Function Signature: createImage2RGBFromElement(Element).");}
			else {throw new TypeError("1st input argument '"+elem+"' in function 'createImage2RGBFromElement' is of type '"+(typeof elem)+"'. Expected type 'Element'. Function Signature: createImage2RGBFromElement(Element).");}
		}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGBFromElement', {"elem": elem.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGBFromObj = function(obj)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGBFromObj'. Expected "+1+" argument. Function Signature: createImage2RGBFromObj(Obj)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGBFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'createImage2RGBFromObj' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: createImage2RGBFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'createImage2RGBFromObj' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: createImage2RGBFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGBFromObj', {"obj": obj.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGB = function(img)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGB'. Expected "+1+" argument. Function Signature: createImage2RGB(Image)")};
		if(img instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGB' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("1st input argument in function 'createImage2RGB' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: createImage2RGB(Image).");}
			else {throw new TypeError("1st input argument '"+img+"' in function 'createImage2RGB' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: createImage2RGB(Image).");}
		}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGB', {"img": img.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGBAFromElement = function(elem, premultiply)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGBAFromElement'. Expected "+2+" arguments. Function Signature: createImage2RGBAFromElement(Element, boolean)")};
		if(elem instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGBAFromElement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(elem instanceof PDFNet.Element)) {
			if(typeof elem == "object") {throw new TypeError("1st input argument in function 'createImage2RGBAFromElement' is of type '"+elem.name+"'. Expected type 'Element'. Function Signature: createImage2RGBAFromElement(Element, boolean).");}
			else {throw new TypeError("1st input argument '"+elem+"' in function 'createImage2RGBAFromElement' is of type '"+(typeof elem)+"'. Expected type 'Element'. Function Signature: createImage2RGBAFromElement(Element, boolean).");}
		}
		if(premultiply instanceof Promise) {throw new TypeError("2nd input argument in function 'createImage2RGBAFromElement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof premultiply != "boolean") {throw new TypeError("2nd input argument '"+premultiply+"' in function 'createImage2RGBAFromElement' is of type '"+(typeof premultiply)+"'. Expected type 'boolean'. Function Signature: createImage2RGBAFromElement(Element, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGBAFromElement', {"elem": elem.id, "premultiply": premultiply}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGBAFromObj = function(obj, premultiply)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGBAFromObj'. Expected "+2+" arguments. Function Signature: createImage2RGBAFromObj(Obj, boolean)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGBAFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'createImage2RGBAFromObj' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: createImage2RGBAFromObj(Obj, boolean).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'createImage2RGBAFromObj' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: createImage2RGBAFromObj(Obj, boolean).");}
		}
		if(premultiply instanceof Promise) {throw new TypeError("2nd input argument in function 'createImage2RGBAFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof premultiply != "boolean") {throw new TypeError("2nd input argument '"+premultiply+"' in function 'createImage2RGBAFromObj' is of type '"+(typeof premultiply)+"'. Expected type 'boolean'. Function Signature: createImage2RGBAFromObj(Obj, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGBAFromObj', {"obj": obj.id, "premultiply": premultiply}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Filter.createImage2RGBA = function(img, premultiply)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createImage2RGBA'. Expected "+2+" arguments. Function Signature: createImage2RGBA(Image, boolean)")};
		if(img instanceof Promise) {throw new TypeError("1st input argument in function 'createImage2RGBA' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("1st input argument in function 'createImage2RGBA' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: createImage2RGBA(Image, boolean).");}
			else {throw new TypeError("1st input argument '"+img+"' in function 'createImage2RGBA' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: createImage2RGBA(Image, boolean).");}
		}
		if(premultiply instanceof Promise) {throw new TypeError("2nd input argument in function 'createImage2RGBA' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof premultiply != "boolean") {throw new TypeError("2nd input argument '"+premultiply+"' in function 'createImage2RGBA' is of type '"+(typeof premultiply)+"'. Expected type 'boolean'. Function Signature: createImage2RGBA(Image, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('filterCreateImage2RGBA', {"img": img.id, "premultiply": premultiply}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Filter.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.destroy', {"filter": this.id}, this.userPriority);
	},

	/**
	* Attaches a filter to the this filter. If this filter owns another
	* filter it will be deleted. This filter then becomes the owner of the
	* attached filter.
	*/
		PDFNet.Filter.prototype.attachFilter = function(attach_filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'attachFilter'. Expected "+1+" argument. Function Signature: attachFilter(Filter)")};
		if(attach_filter instanceof Promise) {throw new TypeError("1st input argument in function 'attachFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(attach_filter instanceof PDFNet.Filter)) {
			if(typeof attach_filter == "object") {throw new TypeError("1st input argument in function 'attachFilter' is of type '"+attach_filter.name+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
			else {throw new TypeError("1st input argument '"+attach_filter+"' in function 'attachFilter' is of type '"+(typeof attach_filter)+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Filter.attachFilter', {"filter": this.id, "attach_filter": attach_filter.id}, this.userPriority);
	},

	/**
	* Release the ownership of the attached filter. After the attached filter is
	* released this filter points to NULL filter.
	*
	* @return A promise that resolves to - Previously attached filter.
	*/
		PDFNet.Filter.prototype.releaseAttachedFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'releaseAttachedFilter'. Expected "+0+" arguments. Function Signature: releaseAttachedFilter()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.releaseAttachedFilter', {"filter": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to - returns attached Filter or a NULL filter if no filter is attached.
	*/
		PDFNet.Filter.prototype.getAttachedFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAttachedFilter'. Expected "+0+" arguments. Function Signature: getAttachedFilter()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.getAttachedFilter', {"filter": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to - returns the first filter in the chain (usually a file filter)
	*/
		PDFNet.Filter.prototype.getSourceFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSourceFilter'. Expected "+0+" arguments. Function Signature: getSourceFilter()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.getSourceFilter', {"filter": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to - descriptive name of the filter.
	*/
		PDFNet.Filter.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.getName', {"filter": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - string representing the name of corresponding decode filter as
	* it should appear in document (e.g. both ASCIIHexDecode and ASCIIHexEncode
	* should return ASCIIHexDecode).
	*/
		PDFNet.Filter.prototype.getDecodeName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDecodeName'. Expected "+0+" arguments. Function Signature: getDecodeName()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.getDecodeName', {"filter": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - beginning of the buffer of Size() bytes that can be used to
	* read or write data.
	*/
		PDFNet.Filter.prototype.begin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+0+" arguments. Function Signature: begin()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.begin', {"filter": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - the size of buffer returned by Begin(). If the Size() returns 0
	* end of data has been reached.
	*/
		PDFNet.Filter.prototype.size = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'size'. Expected "+0+" arguments. Function Signature: size()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.size', {"filter": this.id}, this.userPriority);
	},

	/**
	* Moves the Begin() pointer num_bytes forward.
	*
	* @param num_bytes - number of bytes to consume. num_bytes must be less than or
	* equal to Size().
	*/
		PDFNet.Filter.prototype.consume = function(num_bytes)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'consume'. Expected "+1+" argument. Function Signature: consume(number)")};
		if(num_bytes instanceof Promise) {throw new TypeError("1st input argument in function 'consume' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num_bytes != "number") {throw new TypeError("1st input argument '"+num_bytes+"' in function 'consume' is of type '"+(typeof num_bytes)+"'. Expected type 'number'. Function Signature: consume(number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.consume', {"filter": this.id, "num_bytes": num_bytes}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - the number of bytes consumed since opening the filter or
	*   the last Seek operation
	*/
		PDFNet.Filter.prototype.count = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'count'. Expected "+0+" arguments. Function Signature: count()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.count', {"filter": this.id}, this.userPriority);
	},

	/**
	* Sets a new counting point for the current filter. All subsequent Consume()
	* operations will increment this counter.
	*
	* Make sure that the output filter is flushed before using SetCount().
	*
	* @return A promise that resolves to - the value of previous counter
	*/
		PDFNet.Filter.prototype.setCount = function(new_count)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCount'. Expected "+1+" argument. Function Signature: setCount(number)")};
		if(new_count instanceof Promise) {throw new TypeError("1st input argument in function 'setCount' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof new_count != "number") {throw new TypeError("1st input argument '"+new_count+"' in function 'setCount' is of type '"+(typeof new_count)+"'. Expected type 'number'. Function Signature: setCount(number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.setCount', {"filter": this.id, "new_count": new_count}, this.userPriority);
	},

	/**
	* The functions specifies the length of the data stream. The default
	* implementation doesn't do anything. For some derived filters such
	* as file segment filter it may be useful to override this function
	* in order to limit the stream length.
	*
	* @param - the length of stream in bytes
	*/
		PDFNet.Filter.prototype.setStreamLength = function(bytes)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStreamLength'. Expected "+1+" argument. Function Signature: setStreamLength(number)")};
		if(bytes instanceof Promise) {throw new TypeError("1st input argument in function 'setStreamLength' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bytes != "number") {throw new TypeError("1st input argument '"+bytes+"' in function 'setStreamLength' is of type '"+(typeof bytes)+"'. Expected type 'number'. Function Signature: setStreamLength(number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.setStreamLength', {"filter": this.id, "bytes": bytes}, this.userPriority);
	},

	/**
	* Forces any data remaining in the buffer to be written to input or
	* output filter.
	*/
		PDFNet.Filter.prototype.flush = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flush'. Expected "+0+" arguments. Function Signature: flush()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.flush', {"filter": this.id}, this.userPriority);
	},

	/**
	* Forces any data remaining in the filter chain to the source or destination.
	*/
		PDFNet.Filter.prototype.flushAll = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flushAll'. Expected "+0+" arguments. Function Signature: flushAll()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.flushAll', {"filter": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - boolean indicating whether this is an input filter.
	*/
		PDFNet.Filter.prototype.isInputFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isInputFilter'. Expected "+0+" arguments. Function Signature: isInputFilter()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.isInputFilter', {"filter": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - true if the stream supports seeking; otherwise, false.
	* default is to return false.
	*/
		PDFNet.Filter.prototype.canSeek = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'canSeek'. Expected "+0+" arguments. Function Signature: canSeek()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.canSeek', {"filter": this.id}, this.userPriority);
	},

	/**
	*	Writes the entire filter, starting at current position, to
	*	specified filepath.  Should only be called on an input filter.
	*
	*	@param path the output filepath.
	*	@param append 'true' to append to existing file contents, 'false' to overwrite.
	*/
		PDFNet.Filter.prototype.writeToFile = function(path, append)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'writeToFile'. Expected "+2+" arguments. Function Signature: writeToFile(string, boolean)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'writeToFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'writeToFile' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: writeToFile(string, boolean).");}
		if(append instanceof Promise) {throw new TypeError("2nd input argument in function 'writeToFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof append != "boolean") {throw new TypeError("2nd input argument '"+append+"' in function 'writeToFile' is of type '"+(typeof append)+"'. Expected type 'boolean'. Function Signature: writeToFile(string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.writeToFile', {"filter": this.id, "path": path, "append": append}, this.userPriority);
	},

		PDFNet.Filter.prototype.seek = function(offset, origin)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'seek'. Expected "+2+" arguments. Function Signature: seek(number, number)")};
		if(offset instanceof Promise) {throw new TypeError("1st input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof offset != "number") {throw new TypeError("1st input argument '"+offset+"' in function 'seek' is of type '"+(typeof offset)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		if(origin instanceof Promise) {throw new TypeError("2nd input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof origin != "number") {throw new TypeError("2nd input argument '"+origin+"' in function 'seek' is of type '"+(typeof origin)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Filter.seek', {"filter": this.id, "offset": offset, "origin": origin}, this.userPriority);
	},

	/**
	* Reports the current read position in the stream relative to the stream origin.
	*
	* @return A promise that resolves to - The current position in the stream
	* @exception - throws FilterExc if the method is not implemented in derived class
	*/
		PDFNet.Filter.prototype.tell = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tell'. Expected "+0+" arguments. Function Signature: tell()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.tell', {"filter": this.id}, this.userPriority);
	},

	/**
	* Create Filter iterator. Filter iterator similar to a regular filter. However,
	* there can be only one owner of the attached filter.
	*
	* @note - Derived classes should make sure that there is only one owner of the
	*   attached stream. Otherwise the attached stream may be deleted several times.
	*
	* @exception - throws an exception if the method is not implemented in the derived class
	*/
		PDFNet.Filter.prototype.createInputIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createInputIterator'. Expected "+0+" arguments. Function Signature: createInputIterator()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.createInputIterator', {"filter": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to the file path to the underlying file stream.
	* Default implementation returns empty string.
	*/
		PDFNet.Filter.prototype.getFilePath = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFilePath'. Expected "+0+" arguments. Function Signature: getFilePath()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.getFilePath', {"filter": this.id}, this.userPriority);
	},

		PDFNet.Filter.prototype.memoryFilterGetBuffer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'memoryFilterGetBuffer'. Expected "+0+" arguments. Function Signature: memoryFilterGetBuffer()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.memoryFilterGetBuffer', {"filter": this.id}, this.userPriority);
	},

		PDFNet.Filter.prototype.memoryFilterSetAsInputFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'memoryFilterSetAsInputFilter'. Expected "+0+" arguments. Function Signature: memoryFilterSetAsInputFilter()")};
		return PDFNet.messageHandler.sendWithPromise('Filter.memoryFilterSetAsInputFilter', {"filter": this.id}, this.userPriority);
	},

		PDFNet.FilterReader.create = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Filter)")};
		if(filter instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter instanceof PDFNet.Filter)) {
			if(typeof filter == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+filter.name+"'. Expected type 'Filter'. Function Signature: create(Filter).");}
			else {throw new TypeError("1st input argument '"+filter+"' in function 'create' is of type '"+(typeof filter)+"'. Expected type 'Filter'. Function Signature: create(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('filterReaderCreate', {"filter": filter.id}, this.userPriority).then(function(id){
			//there is a return type FilterReader
			if(id == "0"){
				return null;
			}
			return new PDFNet.FilterReader(id);
		});
	},

		PDFNet.FilterReader.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.destroy', {"reader": this.id}, this.userPriority);
	},

	/**
	* Attaches a filter to the this FilterReader.
	*/
		PDFNet.FilterReader.prototype.attachFilter = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'attachFilter'. Expected "+1+" argument. Function Signature: attachFilter(Filter)")};
		if(filter instanceof Promise) {throw new TypeError("1st input argument in function 'attachFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter instanceof PDFNet.Filter)) {
			if(typeof filter == "object") {throw new TypeError("1st input argument in function 'attachFilter' is of type '"+filter.name+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
			else {throw new TypeError("1st input argument '"+filter+"' in function 'attachFilter' is of type '"+(typeof filter)+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FilterReader.attachFilter', {"reader": this.id, "filter": filter.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - The attached Filter or a NULL filter if no filter is attached.
	*/
		PDFNet.FilterReader.prototype.getAttachedFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAttachedFilter'. Expected "+0+" arguments. Function Signature: getAttachedFilter()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.getAttachedFilter', {"reader": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.FilterReader.prototype.seek = function(offset, origin)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'seek'. Expected "+2+" arguments. Function Signature: seek(number, number)")};
		if(offset instanceof Promise) {throw new TypeError("1st input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof offset != "number") {throw new TypeError("1st input argument '"+offset+"' in function 'seek' is of type '"+(typeof offset)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		if(origin instanceof Promise) {throw new TypeError("2nd input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof origin != "number") {throw new TypeError("2nd input argument '"+origin+"' in function 'seek' is of type '"+(typeof origin)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterReader.seek', {"reader": this.id, "offset": offset, "origin": origin}, this.userPriority);
	},

	/**
	* Reports the current read position in the stream relative to the stream origin.
	*
	* @return A promise that resolves to - The current position in the stream
	* @exception - throws an exception if the method is not implemented in the associated filter.
	*/
		PDFNet.FilterReader.prototype.tell = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tell'. Expected "+0+" arguments. Function Signature: tell()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.tell', {"reader": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - the number of bytes consumed since opening the filter or
	* since the last Seek operation.
	*/
		PDFNet.FilterReader.prototype.count = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'count'. Expected "+0+" arguments. Function Signature: count()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.count', {"reader": this.id}, this.userPriority);
	},

	/**
	* Forces any data remaining in the buffer to be written to input or output filter.
	*/
		PDFNet.FilterReader.prototype.flush = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flush'. Expected "+0+" arguments. Function Signature: flush()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.flush', {"reader": this.id}, this.userPriority);
	},

	/**
	* Forces any data remaining in the filter chain to the source or destination.
	*/
		PDFNet.FilterReader.prototype.flushAll = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flushAll'. Expected "+0+" arguments. Function Signature: flushAll()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.flushAll', {"reader": this.id}, this.userPriority);
	},

		PDFNet.FilterReader.prototype.get = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'get'. Expected "+0+" arguments. Function Signature: get()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.get', {"reader": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - the next character without extracting it from the stream or
	*			 or EOF (-1) if the end of file is reached.
	*/
		PDFNet.FilterReader.prototype.peek = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'peek'. Expected "+0+" arguments. Function Signature: peek()")};
		return PDFNet.messageHandler.sendWithPromise('FilterReader.peek', {"reader": this.id}, this.userPriority);
	},

		PDFNet.FilterWriter.create = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Filter)")};
		if(filter instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter instanceof PDFNet.Filter)) {
			if(typeof filter == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+filter.name+"'. Expected type 'Filter'. Function Signature: create(Filter).");}
			else {throw new TypeError("1st input argument '"+filter+"' in function 'create' is of type '"+(typeof filter)+"'. Expected type 'Filter'. Function Signature: create(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('filterWriterCreate', {"filter": filter.id}, this.userPriority).then(function(id){
			//there is a return type FilterWriter
			if(id == "0"){
				return null;
			}
			return new PDFNet.FilterWriter(id);
		});
	},

		PDFNet.FilterWriter.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.destroy', {"writer": this.id}, this.userPriority);
	},

	/**
	* Attaches a filter to the this FilterWriter.
	*/
		PDFNet.FilterWriter.prototype.attachFilter = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'attachFilter'. Expected "+1+" argument. Function Signature: attachFilter(Filter)")};
		if(filter instanceof Promise) {throw new TypeError("1st input argument in function 'attachFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter instanceof PDFNet.Filter)) {
			if(typeof filter == "object") {throw new TypeError("1st input argument in function 'attachFilter' is of type '"+filter.name+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
			else {throw new TypeError("1st input argument '"+filter+"' in function 'attachFilter' is of type '"+(typeof filter)+"'. Expected type 'Filter'. Function Signature: attachFilter(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.attachFilter', {"writer": this.id, "filter": filter.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - The attached Filter or a NULL filter if no filter is attached.
	*/
		PDFNet.FilterWriter.prototype.getAttachedFilter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAttachedFilter'. Expected "+0+" arguments. Function Signature: getAttachedFilter()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.getAttachedFilter', {"writer": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.FilterWriter.prototype.seek = function(offset, origin)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'seek'. Expected "+2+" arguments. Function Signature: seek(number, number)")};
		if(offset instanceof Promise) {throw new TypeError("1st input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof offset != "number") {throw new TypeError("1st input argument '"+offset+"' in function 'seek' is of type '"+(typeof offset)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		if(origin instanceof Promise) {throw new TypeError("2nd input argument in function 'seek' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof origin != "number") {throw new TypeError("2nd input argument '"+origin+"' in function 'seek' is of type '"+(typeof origin)+"'. Expected type 'number'. Function Signature: seek(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.seek', {"writer": this.id, "offset": offset, "origin": origin}, this.userPriority);
	},

	/**
	* Reports the current read position in the stream relative to the stream origin.
	*
	* @return A promise that resolves to - The current position in the stream
	* @exception - throws an exception if the method is not implemented in the associated filter.
	*/
		PDFNet.FilterWriter.prototype.tell = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tell'. Expected "+0+" arguments. Function Signature: tell()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.tell', {"writer": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - the number of bytes consumed since opening the filter or
	* since the last Seek operation.
	*/
		PDFNet.FilterWriter.prototype.count = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'count'. Expected "+0+" arguments. Function Signature: count()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.count', {"writer": this.id}, this.userPriority);
	},

	/**
	* Forces any data remaining in the buffer to be written to input or output filter.
	*/
		PDFNet.FilterWriter.prototype.flush = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flush'. Expected "+0+" arguments. Function Signature: flush()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.flush', {"writer": this.id}, this.userPriority);
	},

	/**
	* Forces any data remaining in the filter chain to the source or destination.
	*/
		PDFNet.FilterWriter.prototype.flushAll = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flushAll'. Expected "+0+" arguments. Function Signature: flushAll()")};
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.flushAll', {"writer": this.id}, this.userPriority);
	},

	/**
	* Write a single character to the output stream.
	* @param ch An unsigned character to write to the output stream.
	*/
		PDFNet.FilterWriter.prototype.writeUChar = function(ch)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeUChar'. Expected "+1+" argument. Function Signature: writeUChar(number)")};
		if(ch instanceof Promise) {throw new TypeError("1st input argument in function 'writeUChar' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ch != "number") {throw new TypeError("1st input argument '"+ch+"' in function 'writeUChar' is of type '"+(typeof ch)+"'. Expected type 'number'. Function Signature: writeUChar(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeUChar', {"writer": this.id, "ch": ch}, this.userPriority);
	},

	/**
	* Write an integer to the output stream.
	* @param num An integer to write to the output stream.
	*/
		PDFNet.FilterWriter.prototype.writeInt16 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeInt16'. Expected "+1+" argument. Function Signature: writeInt16(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeInt16' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeInt16' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeInt16(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeInt16', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeUInt16 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeUInt16'. Expected "+1+" argument. Function Signature: writeUInt16(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeUInt16' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeUInt16' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeUInt16(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeUInt16', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeInt32 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeInt32'. Expected "+1+" argument. Function Signature: writeInt32(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeInt32' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeInt32' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeInt32(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeInt32', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeUInt32 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeUInt32'. Expected "+1+" argument. Function Signature: writeUInt32(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeUInt32' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeUInt32' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeUInt32(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeUInt32', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeInt64 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeInt64'. Expected "+1+" argument. Function Signature: writeInt64(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeInt64' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeInt64' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeInt64(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeInt64', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeUInt64 = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeUInt64'. Expected "+1+" argument. Function Signature: writeUInt64(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'writeUInt64' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'writeUInt64' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: writeUInt64(number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeUInt64', {"writer": this.id, "num": num}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeString = function(str)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeString'. Expected "+1+" argument. Function Signature: writeString(string)")};
		if(str instanceof Promise) {throw new TypeError("1st input argument in function 'writeString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof str != "string") {throw new TypeError("1st input argument '"+str+"' in function 'writeString' is of type '"+(typeof str)+"'. Expected type 'string'. Function Signature: writeString(string).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeString', {"writer": this.id, "str": str}, this.userPriority);
	},

	/**
	* Write the entire input stream to the output stream (i.e. to this FilterWriter).
	* @param reader A FilterReader attached to an input stream.
	*/
		PDFNet.FilterWriter.prototype.writeFilter = function(reader)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeFilter'. Expected "+1+" argument. Function Signature: writeFilter(FilterReader)")};
		if(reader instanceof Promise) {throw new TypeError("1st input argument in function 'writeFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(reader instanceof PDFNet.FilterReader)) {
			if(typeof reader == "object") {throw new TypeError("1st input argument in function 'writeFilter' is of type '"+reader.name+"'. Expected type 'FilterReader'. Function Signature: writeFilter(FilterReader).");}
			else {throw new TypeError("1st input argument '"+reader+"' in function 'writeFilter' is of type '"+(typeof reader)+"'. Expected type 'FilterReader'. Function Signature: writeFilter(FilterReader).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeFilter', {"writer": this.id, "reader": reader.id}, this.userPriority);
	},

	/**
	* Write out a null terminated 'line' followed by a end of line character
	* default end of line character  is carriage return.
	*/
		PDFNet.FilterWriter.prototype.writeLine = function(line, eol)
	{
		if(typeof eol === "undefined") {eol = 13;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'writeLine'. Expected "+1+" to "+2+" arguments. Function Signature: writeLine(string, number)")};
		if(line instanceof Promise) {throw new TypeError("1st input argument in function 'writeLine' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof line != "string") {throw new TypeError("1st input argument '"+line+"' in function 'writeLine' is of type '"+(typeof line)+"'. Expected type 'string'. Function Signature: writeLine(string, number).");}
		if(eol instanceof Promise) {throw new TypeError("2nd input argument in function 'writeLine' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof eol != "number") {throw new TypeError("2nd input argument '"+eol+"' in function 'writeLine' is of type '"+(typeof eol)+"'. Expected type 'number'. Function Signature: writeLine(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeLine', {"writer": this.id, "line": line, "eol": eol}, this.userPriority);
	},

		PDFNet.FilterWriter.prototype.writeBuffer = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeBuffer'. Expected "+1+" argument. Function Signature: writeBuffer(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'writeBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'writeBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: writeBuffer(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'writeBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: writeBuffer(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FilterWriter.writeBuffer', {"writer": this.id, "buf": buf.buffer}, this.userPriority);
	},

		PDFNet.OCG.create = function(pdfdoc, name)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(PDFDoc, string)")};
		if(pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pdfdoc instanceof PDFNet.PDFDoc || pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof pdfdoc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+pdfdoc+"' in function 'create' is of type '"+(typeof pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, string).");}
		}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'create' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: create(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('ocgCreate', {"pdfdoc": pdfdoc.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type OCG
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCG(id);
		});
	},

		PDFNet.OCG.createFromObj = function(ocg_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(ocg_dict instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ocg_dict instanceof PDFNet.Obj)) {
			if(typeof ocg_dict == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+ocg_dict.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+ocg_dict+"' in function 'createFromObj' is of type '"+(typeof ocg_dict)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ocgCreateFromObj', {"ocg_dict": ocg_dict.id}, this.userPriority).then(function(id){
			//there is a return type OCG
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCG(id);
		});
	},

		PDFNet.OCG.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.copy', {"ocg": this.id}, this.userPriority).then(function(id){
			//there is a return type OCG
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCG(id);
		});
	},

		PDFNet.OCG.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.getSDFObj', {"ocg": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.OCG.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.isValid', {"ocg": this.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.getName', {"c": this.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.setName = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setName'. Expected "+1+" argument. Function Signature: setName(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setName' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setName(string).");}
		return PDFNet.messageHandler.sendWithPromise('OCG.setName', {"c": this.id, "value": value}, this.userPriority);
	},

		PDFNet.OCG.prototype.getIntent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIntent'. Expected "+0+" arguments. Function Signature: getIntent()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.getIntent', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.OCG.prototype.setIntent = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIntent'. Expected "+1+" argument. Function Signature: setIntent(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setIntent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setIntent' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setIntent(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setIntent' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setIntent(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCG.setIntent', {"c": this.id, "value": value.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.hasUsage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasUsage'. Expected "+0+" arguments. Function Signature: hasUsage()")};
		return PDFNet.messageHandler.sendWithPromise('OCG.hasUsage', {"c": this.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.getUsage = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getUsage'. Expected "+1+" argument. Function Signature: getUsage(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'getUsage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'getUsage' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: getUsage(string).");}
		return PDFNet.messageHandler.sendWithPromise('OCG.getUsage', {"c": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.OCG.prototype.getCurrentState = function(ctx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentState'. Expected "+1+" argument. Function Signature: getCurrentState(OCGContext)")};
		if(ctx instanceof Promise) {throw new TypeError("1st input argument in function 'getCurrentState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("1st input argument in function 'getCurrentState' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: getCurrentState(OCGContext).");}
			else {throw new TypeError("1st input argument '"+ctx+"' in function 'getCurrentState' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: getCurrentState(OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCG.getCurrentState', {"c": this.id, "ctx": ctx.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.setCurrentState = function(ctx, state)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setCurrentState'. Expected "+2+" arguments. Function Signature: setCurrentState(OCGContext, boolean)")};
		if(ctx instanceof Promise) {throw new TypeError("1st input argument in function 'setCurrentState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("1st input argument in function 'setCurrentState' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: setCurrentState(OCGContext, boolean).");}
			else {throw new TypeError("1st input argument '"+ctx+"' in function 'setCurrentState' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: setCurrentState(OCGContext, boolean).");}
		}
		if(state instanceof Promise) {throw new TypeError("2nd input argument in function 'setCurrentState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof state != "boolean") {throw new TypeError("2nd input argument '"+state+"' in function 'setCurrentState' is of type '"+(typeof state)+"'. Expected type 'boolean'. Function Signature: setCurrentState(OCGContext, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCG.setCurrentState', {"c": this.id, "ctx": ctx.id, "state": state}, this.userPriority);
	},

		PDFNet.OCG.prototype.getInitialState = function(cfg)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getInitialState'. Expected "+1+" argument. Function Signature: getInitialState(OCGConfig)")};
		if(cfg instanceof Promise) {throw new TypeError("1st input argument in function 'getInitialState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cfg instanceof PDFNet.OCGConfig)) {
			if(typeof cfg == "object") {throw new TypeError("1st input argument in function 'getInitialState' is of type '"+cfg.name+"'. Expected type 'OCGConfig'. Function Signature: getInitialState(OCGConfig).");}
			else {throw new TypeError("1st input argument '"+cfg+"' in function 'getInitialState' is of type '"+(typeof cfg)+"'. Expected type 'OCGConfig'. Function Signature: getInitialState(OCGConfig).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCG.getInitialState', {"c": this.id, "cfg": cfg.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.setInitialState = function(cfg, state)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setInitialState'. Expected "+2+" arguments. Function Signature: setInitialState(OCGConfig, boolean)")};
		if(cfg instanceof Promise) {throw new TypeError("1st input argument in function 'setInitialState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cfg instanceof PDFNet.OCGConfig)) {
			if(typeof cfg == "object") {throw new TypeError("1st input argument in function 'setInitialState' is of type '"+cfg.name+"'. Expected type 'OCGConfig'. Function Signature: setInitialState(OCGConfig, boolean).");}
			else {throw new TypeError("1st input argument '"+cfg+"' in function 'setInitialState' is of type '"+(typeof cfg)+"'. Expected type 'OCGConfig'. Function Signature: setInitialState(OCGConfig, boolean).");}
		}
		if(state instanceof Promise) {throw new TypeError("2nd input argument in function 'setInitialState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof state != "boolean") {throw new TypeError("2nd input argument '"+state+"' in function 'setInitialState' is of type '"+(typeof state)+"'. Expected type 'boolean'. Function Signature: setInitialState(OCGConfig, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCG.setInitialState', {"c": this.id, "cfg": cfg.id, "state": state}, this.userPriority);
	},

		PDFNet.OCG.prototype.isLocked = function(cfg)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isLocked'. Expected "+1+" argument. Function Signature: isLocked(OCGConfig)")};
		if(cfg instanceof Promise) {throw new TypeError("1st input argument in function 'isLocked' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cfg instanceof PDFNet.OCGConfig)) {
			if(typeof cfg == "object") {throw new TypeError("1st input argument in function 'isLocked' is of type '"+cfg.name+"'. Expected type 'OCGConfig'. Function Signature: isLocked(OCGConfig).");}
			else {throw new TypeError("1st input argument '"+cfg+"' in function 'isLocked' is of type '"+(typeof cfg)+"'. Expected type 'OCGConfig'. Function Signature: isLocked(OCGConfig).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCG.isLocked', {"c": this.id, "cfg": cfg.id}, this.userPriority);
	},

		PDFNet.OCG.prototype.setLocked = function(cfg, state)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setLocked'. Expected "+2+" arguments. Function Signature: setLocked(OCGConfig, boolean)")};
		if(cfg instanceof Promise) {throw new TypeError("1st input argument in function 'setLocked' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cfg instanceof PDFNet.OCGConfig)) {
			if(typeof cfg == "object") {throw new TypeError("1st input argument in function 'setLocked' is of type '"+cfg.name+"'. Expected type 'OCGConfig'. Function Signature: setLocked(OCGConfig, boolean).");}
			else {throw new TypeError("1st input argument '"+cfg+"' in function 'setLocked' is of type '"+(typeof cfg)+"'. Expected type 'OCGConfig'. Function Signature: setLocked(OCGConfig, boolean).");}
		}
		if(state instanceof Promise) {throw new TypeError("2nd input argument in function 'setLocked' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof state != "boolean") {throw new TypeError("2nd input argument '"+state+"' in function 'setLocked' is of type '"+(typeof state)+"'. Expected type 'boolean'. Function Signature: setLocked(OCGConfig, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCG.setLocked', {"c": this.id, "cfg": cfg.id, "state": state}, this.userPriority);
	},

		PDFNet.OCGConfig.createFromObj = function(dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(dict instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dict instanceof PDFNet.Obj)) {
			if(typeof dict == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+dict.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+dict+"' in function 'createFromObj' is of type '"+(typeof dict)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ocgConfigCreateFromObj', {"dict": dict.id}, this.userPriority).then(function(id){
			//there is a return type OCGConfig
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGConfig(id);
		});
	},

	/**
	* Creates a new optional-content configuration object in the document.
	* @param doc The document in which the new OCG::Config will be created.
	* @param default_config If true, the configuration will be set as the
	* default OCG configuration (i.e. listed as a D entry under 'OCProperies'
	* dictionary).
	* @return A promise that resolves to the newly created configuration object.
	*/
		PDFNet.OCGConfig.create = function(pdfdoc, default_config)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(PDFDoc, boolean)")};
		if(pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pdfdoc instanceof PDFNet.PDFDoc || pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof pdfdoc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, boolean).");}
			else {throw new TypeError("1st input argument '"+pdfdoc+"' in function 'create' is of type '"+(typeof pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, boolean).");}
		}
		if(default_config instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof default_config != "boolean") {throw new TypeError("2nd input argument '"+default_config+"' in function 'create' is of type '"+(typeof default_config)+"'. Expected type 'boolean'. Function Signature: create(PDFDoc, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ocgConfigCreate', {"pdfdoc": pdfdoc.id, "default_config": default_config}, this.userPriority).then(function(id){
			//there is a return type OCGConfig
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGConfig(id);
		});
	},

		PDFNet.OCGConfig.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.copy', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type OCGConfig
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGConfig(id);
		});
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.OCGConfig.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getSDFObj', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the Obj array that specifies the order of optional content (OC) groups
	* in this configuration or NULL if the configuration does not contain any OCGs.
	* The order of OCGs in the array is used to represent the order in which the
	* group names are displayed in the Layers panel of a PDF viewer application.
	* For more information, please refer to Section 4.10.3 in the PDF Reference.
	*/
		PDFNet.OCGConfig.prototype.getOrder = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOrder'. Expected "+0+" arguments. Function Signature: getOrder()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getOrder', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Sets the user interface display order of optional-content groups (OCGs) in
	* this configuration. This is the order in which the group names are displayed
	* in the Layers panel of a PDF viewer.
	*
	* @param ocgs_array The SDF/Cos object containing the OCG order array.
	* For more information, please refer to section 4.10.3 in the PDF Reference.
	*/
		PDFNet.OCGConfig.prototype.setOrder = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOrder'. Expected "+1+" argument. Function Signature: setOrder(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setOrder' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setOrder' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setOrder(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setOrder' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setOrder(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setOrder', {"c": this.id, "value": value.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the name of an optional-content configuration (suitable for
	* presentation in a user interface).
	*/
		PDFNet.OCGConfig.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getName', {"c": this.id}, this.userPriority);
	},

	/**
	* sets the name of an optional-content configuration (suitable for presentation
	* in a user interface). The method stores the specified string as the Name entry
	* in the configuration's SDF/Cos dictionary.
	* @param name The new name string.
	*/
		PDFNet.OCGConfig.prototype.setName = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setName'. Expected "+1+" argument. Function Signature: setName(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setName' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setName(string).");}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setName', {"c": this.id, "value": value}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the creator property of an optional-content configuration. The string
	* is used to represent the name of the application or feature that created this
	* configuration.
	*/
		PDFNet.OCGConfig.prototype.getCreator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCreator'. Expected "+0+" arguments. Function Signature: getCreator()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getCreator', {"c": this.id}, this.userPriority);
	},

	/**
	* sets the creator property of an optional-content configuration. Stores the
	* specified string as the Creator entry in the configuration's SDF/Cos dictionary.
	* @param name The new creator string.
	*/
		PDFNet.OCGConfig.prototype.setCreator = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCreator'. Expected "+1+" argument. Function Signature: setCreator(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setCreator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setCreator' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setCreator(string).");}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setCreator', {"c": this.id, "value": value}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the base initialization state. This state is used to initialize the states
	* of all the OCGs in a document when this configuration is applied. The value of this entry
	* must be one of the following names:
	*  <li>ON: The states of all groups are turned ON. </li>
	*  <li>OFF: The states of all groups are turned OFF.</li>
	*  <li>Unchanged: The states of all groups are left unchanged.</li>
	*
	* <p> After base initialization, the contents of the ON and OFF arrays are processed, overriding
	* the state of the groups included in the arrays.</p>
	* @note: If BaseState is present in the document's default configuration dictionary, its value must
	* be "ON".
	* @default ON.
	*/
		PDFNet.OCGConfig.prototype.getInitBaseState = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInitBaseState'. Expected "+0+" arguments. Function Signature: getInitBaseState()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getInitBaseState', {"c": this.id}, this.userPriority);
	},

	/**
	* sets the base initialization state. For more info, please see GetInitBaseState().
	* @param state new base state ("ON", "OFF", or "Unchanged").
	*/
		PDFNet.OCGConfig.prototype.setInitBaseState = function(value)
	{
		if(typeof value === "undefined") {value = "ON";};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInitBaseState'. Expected at most "+1+" arguments. Function Signature: setInitBaseState(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setInitBaseState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setInitBaseState' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setInitBaseState(string).");}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setInitBaseState', {"c": this.id, "value": value}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the "ON" initialization array from the configuration dictionary or
	* NULL if the array is not present. The returned object is an array of optional
	* content groups whose state should be set to ON when this configuration is applied.
	* Note: If the BaseState entry is ON, this entry is redundant.
	*/
		PDFNet.OCGConfig.prototype.getInitOnStates = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInitOnStates'. Expected "+0+" arguments. Function Signature: getInitOnStates()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getInitOnStates', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* sets the 'ON' initialization array in the configuration dictionary.
	* For more info, please see SetInitOnStates() and  section 4.10.3 in PDF Reference.
	*/
		PDFNet.OCGConfig.prototype.setInitOnStates = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInitOnStates'. Expected "+1+" argument. Function Signature: setInitOnStates(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setInitOnStates' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setInitOnStates' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setInitOnStates(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setInitOnStates' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setInitOnStates(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setInitOnStates', {"c": this.id, "value": value.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the "OFF" initialization array from the configuration dictionary or
	* NULL if the array is not present. The returned object is an array of optional
	* content groups whose state should be set to OFF when this configuration is applied.
	* Note: If the BaseState entry is OFF, this entry is redundant.
	*/
		PDFNet.OCGConfig.prototype.getInitOffStates = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInitOffStates'. Expected "+0+" arguments. Function Signature: getInitOffStates()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getInitOffStates', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* sets the 'OFF' initialization array in the configuration dictionary.
	* For more info, please see SetInitOffStates() and section 4.10.3 in PDF Reference.
	*/
		PDFNet.OCGConfig.prototype.setInitOffStates = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInitOffStates'. Expected "+1+" argument. Function Signature: setInitOffStates(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setInitOffStates' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setInitOffStates' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setInitOffStates(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setInitOffStates' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setInitOffStates(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setInitOffStates', {"c": this.id, "value": value.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to oCG configuration intent. An intent is a name object (or an array of name
	* objects) broadly describing the intended use, which can be either "View" or "Design".
	* A group's content is considered to be optional (that is, the group's state is considered
	* in its visibility) if any intent in its list matches an intent of the context. The
	* intent list of the context is usually set from the intent list of the document
	* configuration. If the configuration has no Intent entry, the default value of
	* "View" is used.
	*/
		PDFNet.OCGConfig.prototype.getIntent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIntent'. Expected "+0+" arguments. Function Signature: getIntent()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getIntent', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Sets the Intent entry in an optional-content configuration's SDF/Cos dictionary.
	* For more information, see GetIntent().
	* @param intent The new Intent entry value (a name object or an array of name objects).
	*/
		PDFNet.OCGConfig.prototype.setIntent = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIntent'. Expected "+1+" argument. Function Signature: setIntent(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setIntent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setIntent' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setIntent(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setIntent' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setIntent(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setIntent', {"c": this.id, "value": value.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the list of locked OCGs or NULL if there are no locked OCGs.
	* The on/off state of a locked OCG cannot be toggled by the user through the
	* user interface.
	*/
		PDFNet.OCGConfig.prototype.getLockedOCGs = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLockedOCGs'. Expected "+0+" arguments. Function Signature: getLockedOCGs()")};
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.getLockedOCGs', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* sets the array of locked OCGs. The on/off state of a locked OCG cannot be
	* toggled by the user through the user interface.
	*
	* @param locked_ocg_array An SDF/Cos array of OCG objects to be locked in this
	* configuration, or an empty array if the configuration should not contain
	* locked OCGs. The default is the empty array.
	*/
		PDFNet.OCGConfig.prototype.setLockedOCGs = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLockedOCGs'. Expected "+1+" argument. Function Signature: setLockedOCGs(Obj)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setLockedOCGs' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("1st input argument in function 'setLockedOCGs' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: setLockedOCGs(Obj).");}
			else {throw new TypeError("1st input argument '"+value+"' in function 'setLockedOCGs' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: setLockedOCGs(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGConfig.setLockedOCGs', {"c": this.id, "value": value.id}, this.userPriority);
	},

		PDFNet.OCGContext.createFromConfig = function(cfg)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromConfig'. Expected "+1+" argument. Function Signature: createFromConfig(OCGConfig)")};
		if(cfg instanceof Promise) {throw new TypeError("1st input argument in function 'createFromConfig' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cfg instanceof PDFNet.OCGConfig)) {
			if(typeof cfg == "object") {throw new TypeError("1st input argument in function 'createFromConfig' is of type '"+cfg.name+"'. Expected type 'OCGConfig'. Function Signature: createFromConfig(OCGConfig).");}
			else {throw new TypeError("1st input argument '"+cfg+"' in function 'createFromConfig' is of type '"+(typeof cfg)+"'. Expected type 'OCGConfig'. Function Signature: createFromConfig(OCGConfig).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ocgContextCreateFromConfig', {"cfg": cfg.id}, this.userPriority).then(function(id){
			//there is a return type OCGContext
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGContext(id);
		});
	},

		PDFNet.OCGContext.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('OCGContext.copy', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type OCGContext
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGContext(id);
		});
	},

		PDFNet.OCGContext.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('OCGContext.destroy', {"ctx": this.id}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.getState = function(grp)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getState'. Expected "+1+" argument. Function Signature: getState(OCG)")};
		if(grp instanceof Promise) {throw new TypeError("1st input argument in function 'getState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(grp instanceof PDFNet.OCG)) {
			if(typeof grp == "object") {throw new TypeError("1st input argument in function 'getState' is of type '"+grp.name+"'. Expected type 'OCG'. Function Signature: getState(OCG).");}
			else {throw new TypeError("1st input argument '"+grp+"' in function 'getState' is of type '"+(typeof grp)+"'. Expected type 'OCG'. Function Signature: getState(OCG).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCGContext.getState', {"c": this.id, "grp": grp.id}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.setState = function(grp, state)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setState'. Expected "+2+" arguments. Function Signature: setState(OCG, boolean)")};
		if(grp instanceof Promise) {throw new TypeError("1st input argument in function 'setState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(grp instanceof PDFNet.OCG)) {
			if(typeof grp == "object") {throw new TypeError("1st input argument in function 'setState' is of type '"+grp.name+"'. Expected type 'OCG'. Function Signature: setState(OCG, boolean).");}
			else {throw new TypeError("1st input argument '"+grp+"' in function 'setState' is of type '"+(typeof grp)+"'. Expected type 'OCG'. Function Signature: setState(OCG, boolean).");}
		}
		if(state instanceof Promise) {throw new TypeError("2nd input argument in function 'setState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof state != "boolean") {throw new TypeError("2nd input argument '"+state+"' in function 'setState' is of type '"+(typeof state)+"'. Expected type 'boolean'. Function Signature: setState(OCG, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCGContext.setState', {"c": this.id, "grp": grp.id, "state": state}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.resetStates = function(all_on)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'resetStates'. Expected "+1+" argument. Function Signature: resetStates(boolean)")};
		if(all_on instanceof Promise) {throw new TypeError("1st input argument in function 'resetStates' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof all_on != "boolean") {throw new TypeError("1st input argument '"+all_on+"' in function 'resetStates' is of type '"+(typeof all_on)+"'. Expected type 'boolean'. Function Signature: resetStates(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCGContext.resetStates', {"c": this.id, "all_on": all_on}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.setNonOCDrawing = function(draw_non_OC)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setNonOCDrawing'. Expected "+1+" argument. Function Signature: setNonOCDrawing(boolean)")};
		if(draw_non_OC instanceof Promise) {throw new TypeError("1st input argument in function 'setNonOCDrawing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof draw_non_OC != "boolean") {throw new TypeError("1st input argument '"+draw_non_OC+"' in function 'setNonOCDrawing' is of type '"+(typeof draw_non_OC)+"'. Expected type 'boolean'. Function Signature: setNonOCDrawing(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('OCGContext.setNonOCDrawing', {"c": this.id, "draw_non_OC": draw_non_OC}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.getNonOCDrawing = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNonOCDrawing'. Expected "+0+" arguments. Function Signature: getNonOCDrawing()")};
		return PDFNet.messageHandler.sendWithPromise('OCGContext.getNonOCDrawing', {"c": this.id}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.setOCDrawMode = function(oc_draw_mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOCDrawMode'. Expected "+1+" argument. Function Signature: setOCDrawMode(number)")};
		if(oc_draw_mode instanceof Promise) {throw new TypeError("1st input argument in function 'setOCDrawMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof oc_draw_mode != "number") {throw new TypeError("1st input argument '"+oc_draw_mode+"' in function 'setOCDrawMode' is of type '"+(typeof oc_draw_mode)+"'. Expected type 'number'. Function Signature: setOCDrawMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('OCGContext.setOCDrawMode', {"c": this.id, "oc_draw_mode": oc_draw_mode}, this.userPriority);
	},

		PDFNet.OCGContext.prototype.getOCMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOCMode'. Expected "+0+" arguments. Function Signature: getOCMode()")};
		return PDFNet.messageHandler.sendWithPromise('OCGContext.getOCMode', {"c": this.id}, this.userPriority);
	},

	/**
	* Creates a new optional-content group membership dictionary (OCMD) object from
	* an existing SDF/Cos object.
	*/
		PDFNet.OCMD.createFromObj = function(ocmd_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(ocmd_dict instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ocmd_dict instanceof PDFNet.Obj)) {
			if(typeof ocmd_dict == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+ocmd_dict.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+ocmd_dict+"' in function 'createFromObj' is of type '"+(typeof ocmd_dict)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ocmdCreateFromObj', {"ocmd_dict": ocmd_dict.id}, this.userPriority).then(function(id){
			//there is a return type OCMD
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCMD(id);
		});
	},

	/**
	* Creates a new optional-content membership dictionary (OCMD) object in the
	* given document for the given groups and visibility policy.
	*
	* @param doc The document in which the new OCMD will be created.
	* @param ocgs An array of optional-content groups (OCGs) to be members of the dictionary.
	* @param policy The visibility policy that determines the visibility of content with respect
	* to the ON-OFF state of OCGs listed in the dictionary.
	*
	* @return A promise that resolves to the newly created OCG::OCMD object.
	*/
		PDFNet.OCMD.create = function(pdfdoc, ocgs, vis_policy)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+3+" arguments. Function Signature: create(PDFDoc, Obj, number)")};
		if(pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pdfdoc instanceof PDFNet.PDFDoc || pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof pdfdoc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, Obj, number).");}
			else {throw new TypeError("1st input argument '"+pdfdoc+"' in function 'create' is of type '"+(typeof pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, Obj, number).");}
		}
		if(ocgs instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ocgs instanceof PDFNet.Obj)) {
			if(typeof ocgs == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+ocgs.name+"'. Expected type 'Obj'. Function Signature: create(PDFDoc, Obj, number).");}
			else {throw new TypeError("2nd input argument '"+ocgs+"' in function 'create' is of type '"+(typeof ocgs)+"'. Expected type 'Obj'. Function Signature: create(PDFDoc, Obj, number).");}
		}
		if(vis_policy instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vis_policy != "number") {throw new TypeError("3rd input argument '"+vis_policy+"' in function 'create' is of type '"+(typeof vis_policy)+"'. Expected type 'number'. Function Signature: create(PDFDoc, Obj, number).");}
		return PDFNet.messageHandler.sendWithPromise('ocmdCreate', {"pdfdoc": pdfdoc.id, "ocgs": ocgs.id, "vis_policy": vis_policy}, this.userPriority).then(function(id){
			//there is a return type OCMD
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCMD(id);
		});
	},

		PDFNet.OCMD.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.copy', {"ocmd": this.id}, this.userPriority).then(function(id){
			//there is a return type OCMD
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCMD(id);
		});
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.OCMD.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.getSDFObj', {"ocmd": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Returns the optional-content groups listed under 'OCGs' entry in the object
	* dictionary.
	*
	* @return A promise that resolves to a dictionary (for a single OCG::Group object), an SDF::Obj array
	* (for multiple OCG::Group objects) or NULL (for an empty OCMD).
	*/
		PDFNet.OCMD.prototype.getOCGs = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOCGs'. Expected "+0+" arguments. Function Signature: getOCGs()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.getOCGs', {"ocmd": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to if the PDOCMD has a visibility expression entry, return the
	* SDF::Obj array object representing the expression, otherwise returns NULL.
	*/
		PDFNet.OCMD.prototype.getVisibilityExpression = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVisibilityExpression'. Expected "+0+" arguments. Function Signature: getVisibilityExpression()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.getVisibilityExpression', {"ocmd": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid (non-null) OCMD, false otherwise.
	*/
		PDFNet.OCMD.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.isValid', {"ocmd": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if content tagged with this OCMD is visible in the given
	* context, false if it is hidden.
	* <p>
	* Based on the optional-content groups listed in the dictionary, the current
	* ON-OFF state of those groups within the specified context, and the
	* dictionary's visibility policy, test whether the content tagged with
	* this dictionary would be visible.
	*
	* @param context The context in which the visibility of content is tested.
	*/
		PDFNet.OCMD.prototype.isCurrentlyVisible = function(ctx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isCurrentlyVisible'. Expected "+1+" argument. Function Signature: isCurrentlyVisible(OCGContext)")};
		if(ctx instanceof Promise) {throw new TypeError("1st input argument in function 'isCurrentlyVisible' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("1st input argument in function 'isCurrentlyVisible' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: isCurrentlyVisible(OCGContext).");}
			else {throw new TypeError("1st input argument '"+ctx+"' in function 'isCurrentlyVisible' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: isCurrentlyVisible(OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('OCMD.isCurrentlyVisible', {"ocmd": this.id, "ctx": ctx.id}, this.userPriority);
	},

	/**
	* Returns the optional-content membership dictionary's visibility policy, which
	* determines the visibility of content with respect to the ON-OFF state of
	* OCGs listed in the dictionary.
	*
	* @return A promise that resolves to the visibility policy.
	*/
		PDFNet.OCMD.prototype.getVisibilityPolicy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVisibilityPolicy'. Expected "+0+" arguments. Function Signature: getVisibilityPolicy()")};
		return PDFNet.messageHandler.sendWithPromise('OCMD.getVisibilityPolicy', {"ocmd": this.id}, this.userPriority);
	},

	/**
	* Sets the optional-content membership dictionary's visibility policy, which
	* determines the visibility of content with respect to the ON-OFF state of
	* OCGs listed in the dictionary.
	* @param vis_policy New visibility policy.
	*/
		PDFNet.OCMD.prototype.setVisibilityPolicy = function(vis_policy)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setVisibilityPolicy'. Expected "+1+" argument. Function Signature: setVisibilityPolicy(number)")};
		if(vis_policy instanceof Promise) {throw new TypeError("1st input argument in function 'setVisibilityPolicy' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vis_policy != "number") {throw new TypeError("1st input argument '"+vis_policy+"' in function 'setVisibilityPolicy' is of type '"+(typeof vis_policy)+"'. Expected type 'number'. Function Signature: setVisibilityPolicy(number).");}
		return PDFNet.messageHandler.sendWithPromise('OCMD.setVisibilityPolicy', {"ocmd": this.id, "vis_policy": vis_policy}, this.userPriority);
	},

	/**
	* perform PDF/A validation or PDF/A conversion on the input PDF document
	* which is stored in a memory buffer.
	*
	* @param convert A flag used to instruct PDF/A processor to perform PDF/A
	* conversion (if 'true') or PDF/A validation (if 'false'). After PDF/A conversion
	* you can save the resulting document using Save() method(s).
	* @param buf A memory buffer containing the serialized PDF document.
	* @param buf_size The size of memory buffer.
	* @param password An optional parameter that can be used to specify the
	* password for encrypted PDF documents (typically only useful in the conversion mode).
	* @param conf The PDF conformance level. The default value is e_Level1B.
	* @param max_ref_objs The maximum number of object references per error condition.
	*
	* @exception. Throws an exception if the file can't be opened.
	*/
		PDFNet.PDFACompliance.createFromBuffer = function(convert, buf, password, conf, exceptions, exlength, max_ref_objs, first_stop)
	{
		if(typeof password === "undefined") {password = 0;};
		if(typeof conf === "undefined") {conf = exports.PDFNet.PDFACompliance.Conformance.e_Level1B};
		if(typeof exceptions === "undefined") {exceptions = 0;};
		if(typeof exlength === "undefined") {exlength = 0;};
		if(typeof max_ref_objs === "undefined") {max_ref_objs = 10;};
		if(typeof first_stop === "undefined") {first_stop = false;};
		if((arguments.length < 2) || (arguments.length > 8)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromBuffer'. Expected "+2+" to "+8+" arguments. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean)")};
		if(convert instanceof Promise) {throw new TypeError("1st input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof convert != "boolean") {throw new TypeError("1st input argument '"+convert+"' in function 'createFromBuffer' is of type '"+(typeof convert)+"'. Expected type 'boolean'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createFromBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createFromBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		}
		if(password instanceof Promise) {throw new TypeError("4th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("4th input argument '"+password+"' in function 'createFromBuffer' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(conf instanceof Promise) {throw new TypeError("5th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof conf != "number") {throw new TypeError("5th input argument '"+conf+"' in function 'createFromBuffer' is of type '"+(typeof conf)+"'. Expected type 'number'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(exceptions instanceof Promise) {throw new TypeError("6th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof exceptions != "number") {throw new TypeError("6th input argument '"+exceptions+"' in function 'createFromBuffer' is of type '"+(typeof exceptions)+"'. Expected type 'number'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(exlength instanceof Promise) {throw new TypeError("7th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof exlength != "number") {throw new TypeError("7th input argument '"+exlength+"' in function 'createFromBuffer' is of type '"+(typeof exlength)+"'. Expected type 'number'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(max_ref_objs instanceof Promise) {throw new TypeError("8th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof max_ref_objs != "number") {throw new TypeError("8th input argument '"+max_ref_objs+"' in function 'createFromBuffer' is of type '"+(typeof max_ref_objs)+"'. Expected type 'number'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		if(first_stop instanceof Promise) {throw new TypeError("9th input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof first_stop != "boolean") {throw new TypeError("9th input argument '"+first_stop+"' in function 'createFromBuffer' is of type '"+(typeof first_stop)+"'. Expected type 'boolean'. Function Signature: createFromBuffer(boolean, ArrayBuffer, string, number, number, number, number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('pdfaComplianceCreateFromBuffer', {"convert": convert, "buf": buf.buffer, "password": password, "conf": conf, "exceptions": exceptions, "exlength": exlength, "max_ref_objs": max_ref_objs, "first_stop": first_stop}, this.userPriority).then(function(id){
			//there is a return type PDFACompliance
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFACompliance(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.PDFACompliance.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.destroy', {"pdfac": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of compliance violations.
	*/
		PDFNet.PDFACompliance.prototype.getErrorCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getErrorCount'. Expected "+0+" arguments. Function Signature: getErrorCount()")};
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.getErrorCount', {"pdfac": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the error identifier.
	* @param idx The index in the array of error code identifiers.
	* The array is indexed starting from zero.
	*
	* @exception throws an Exception if the index is outside the array bounds.
	*/
		PDFNet.PDFACompliance.prototype.getError = function(idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getError'. Expected "+1+" argument. Function Signature: getError(number)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'getError' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'getError' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: getError(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.getError', {"pdfac": this.id, "idx": idx}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of object references associated with a given error.
	* @param id error code identifier (obtained using GetError() method).
	*/
		PDFNet.PDFACompliance.prototype.getRefObjCount = function(id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getRefObjCount'. Expected "+1+" argument. Function Signature: getRefObjCount(number)")};
		if(id instanceof Promise) {throw new TypeError("1st input argument in function 'getRefObjCount' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof id != "number") {throw new TypeError("1st input argument '"+id+"' in function 'getRefObjCount' is of type '"+(typeof id)+"'. Expected type 'number'. Function Signature: getRefObjCount(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.getRefObjCount', {"pdfac": this.id, "id": id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a specific object reference associated with a given error type.
	* The return value is a PDF object identifier (i.e. object number for
	* 'pdftron.SDF.Obj)) for the that is associated with the error.
	*
	* @param id error code identifier (obtained using GetError() method).
	* @param err_idx The index in the array of object references.
	* The array is indexed starting from zero.
	*
	* @exception throws an Exception if the index is outside the array bounds.
	*/
		PDFNet.PDFACompliance.prototype.getRefObj = function(id, obj_idx)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'getRefObj'. Expected "+2+" arguments. Function Signature: getRefObj(number, number)")};
		if(id instanceof Promise) {throw new TypeError("1st input argument in function 'getRefObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof id != "number") {throw new TypeError("1st input argument '"+id+"' in function 'getRefObj' is of type '"+(typeof id)+"'. Expected type 'number'. Function Signature: getRefObj(number, number).");}
		if(obj_idx instanceof Promise) {throw new TypeError("2nd input argument in function 'getRefObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof obj_idx != "number") {throw new TypeError("2nd input argument '"+obj_idx+"' in function 'getRefObj' is of type '"+(typeof obj_idx)+"'. Expected type 'number'. Function Signature: getRefObj(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.getRefObj', {"pdfac": this.id, "id": id, "obj_idx": obj_idx}, this.userPriority);
	},

	/**
	* @param id error code identifier (obtained using GetError() method).
	* @return A promise that resolves to a descriptive error message for the given error identifier.
	*/
		PDFNet.PDFACompliance.getPDFAErrorMessage = function(id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPDFAErrorMessage'. Expected "+1+" argument. Function Signature: getPDFAErrorMessage(number)")};
		if(id instanceof Promise) {throw new TypeError("1st input argument in function 'getPDFAErrorMessage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof id != "number") {throw new TypeError("1st input argument '"+id+"' in function 'getPDFAErrorMessage' is of type '"+(typeof id)+"'. Expected type 'number'. Function Signature: getPDFAErrorMessage(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfaComplianceGetPDFAErrorMessage', {"id": id}, this.userPriority);
	},

	/**
	* serializes the converted PDF/A document to a file on disk.
	* @note This method assumes that the first parameter passed in PDFACompliance
	* constructor (i.e. the convert parameter) is set to 'true'.
	* @param filepath - the output file name.
	* @param linearized - An optional flag used to specify whether the the resulting
	* PDF/A document should be web-optimized (linearized).
	*/
		PDFNet.PDFACompliance.prototype.saveAsFromFileName = function(file_path, linearized)
	{
		if(typeof linearized === "undefined") {linearized = false;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'saveAsFromFileName'. Expected "+1+" to "+2+" arguments. Function Signature: saveAsFromFileName(string, boolean)")};
		if(file_path instanceof Promise) {throw new TypeError("1st input argument in function 'saveAsFromFileName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_path != "string") {throw new TypeError("1st input argument '"+file_path+"' in function 'saveAsFromFileName' is of type '"+(typeof file_path)+"'. Expected type 'string'. Function Signature: saveAsFromFileName(string, boolean).");}
		if(linearized instanceof Promise) {throw new TypeError("2nd input argument in function 'saveAsFromFileName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof linearized != "boolean") {throw new TypeError("2nd input argument '"+linearized+"' in function 'saveAsFromFileName' is of type '"+(typeof linearized)+"'. Expected type 'boolean'. Function Signature: saveAsFromFileName(string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.saveAsFromFileName', {"pdfac": this.id, "file_path": file_path, "linearized": linearized}, this.userPriority);
	},

		PDFNet.PDFACompliance.prototype.saveAsFromBuffer = function(linearized)
	{
		if(typeof linearized === "undefined") {linearized = false;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'saveAsFromBuffer'. Expected at most "+1+" arguments. Function Signature: saveAsFromBuffer(boolean)")};
		if(linearized instanceof Promise) {throw new TypeError("3rd input argument in function 'saveAsFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof linearized != "boolean") {throw new TypeError("3rd input argument '"+linearized+"' in function 'saveAsFromBuffer' is of type '"+(typeof linearized)+"'. Expected type 'boolean'. Function Signature: saveAsFromBuffer(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFACompliance.saveAsFromBuffer', {"pdfac": this.id, "linearized": linearized}, this.userPriority).then(function(id){
			return new Uint8Array(id);
		});
	},

	/**
	* Initialize a AttrObj using an existing low-level Cos/SDF object.
	*
	* @param dict - a low-level (SDF/Cos) dictionary representing the attribute object.
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.AttrObj.create = function(dict)
	{
		if(typeof dict === "undefined") {dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dict instanceof PDFNet.Obj)) {
			if(typeof dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+dict+"' in function 'create' is of type '"+(typeof dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('attrObjCreate', {"dict": dict.id}, this.userPriority).then(function(id){
			//there is a return type AttrObj
			if(id == "0"){
				return null;
			}
			return new PDFNet.AttrObj(id);
		});
	},

		PDFNet.AttrObj.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('AttrObj.copy', {"a": this.id}, this.userPriority).then(function(id){
			//there is a return type AttrObj
			if(id == "0"){
				return null;
			}
			return new PDFNet.AttrObj(id);
		});
	},

	/**
	* @return A promise that resolves to the name of the application or plug-in extension owning the
	* attribute data.
	*/
		PDFNet.AttrObj.prototype.getOwner = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOwner'. Expected "+0+" arguments. Function Signature: getOwner()")};
		return PDFNet.messageHandler.sendWithPromise('AttrObj.getOwner', {"obj": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.AttrObj.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('AttrObj.getSDFObj', {"obj": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Initialize a ClassMap using an existing low-level Cos/SDF ClassMap object.
	*
	* @param dict - a low-level (SDF/Cos) ClassMap dictionary.
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.ClassMap.create = function(dict)
	{
		if(typeof dict === "undefined") {dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dict instanceof PDFNet.Obj)) {
			if(typeof dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+dict+"' in function 'create' is of type '"+(typeof dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('classMapCreate', {"dict": dict.id}, this.userPriority).then(function(id){
			//there is a return type ClassMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.ClassMap(id);
		});
	},

		PDFNet.ClassMap.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('ClassMap.copy', {"p": this.id}, this.userPriority).then(function(id){
			//there is a return type ClassMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.ClassMap(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid (non-null) ClassMap, false otherwise.
	* If the function returns false the underlying SDF/Cos object is null or is
	* not valid and the ClassMap object should be treated as a null object.
	*/
		PDFNet.ClassMap.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('ClassMap.isValid', {"map": this.id}, this.userPriority);
	},

	/**
	* Returns the ClassMap dictionary.
	*
	* @return A promise that resolves to the object to the underlying SDF/Cos object.
	*/
		PDFNet.ClassMap.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('ClassMap.getSDFObj', {"map": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ContentItem.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'copy'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.copy', {"c": this}, this.userPriority).then(function(id){
			//there is a return type ContentItem
			if(id == "0"){
				return null;
			}
			return new PDFNet.ContentItem(id);
		});
	},

	/**
	* @return A promise that resolves to the content item type.
	*/
		PDFNet.ContentItem.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getType'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getType', {"item": this}, this.userPriority);
	},

	/**
	* find the parent structure element.
	*/
		PDFNet.ContentItem.prototype.getParent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParent'. Expected "+0+" arguments. Function Signature: getParent()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getParent'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ContentItem.getParent"; // TRN_ContentItem* item
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getParent', {"item": this}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.item, me);
			me.yieldFunction = undefined;
			return new PDFNet.SElement(id.result.obj, id.result.k);
		});
	},

	/**
	* the page on which the marked content is drawn, whether directly as part of
	* page content or indirectly by being in a Form XObject or annotation drawn
	* on that page.
	*/
		PDFNet.ContentItem.prototype.getPage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPage'. Expected "+0+" arguments. Function Signature: getPage()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getPage'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ContentItem.getPage"; // TRN_ContentItem* item
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getPage', {"item": this}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.item, me);
			me.yieldFunction = undefined;
			return new PDFNet.Page(id.result);
		});
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.ContentItem.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getSDFObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getSDFObj', {"item": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to mcid (marked-content identifier).
	*
	* @note this method only applies to content items with types e_MCR or e_MCID.
	*/
		PDFNet.ContentItem.prototype.getMCID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMCID'. Expected "+0+" arguments. Function Signature: getMCID()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getMCID'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getMCID', {"item": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the stream object that contains the marked-content sequence.
	* The function will return a non-NULL object only if the marked-content
	* sequence resides in a content stream other than the content stream for the
	* page (e.g. in a form XObject).
	*
	* @note this method only applies to content items with type e_MCR.
	*/
		PDFNet.ContentItem.prototype.getContainingStm = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContainingStm'. Expected "+0+" arguments. Function Signature: getContainingStm()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getContainingStm'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getContainingStm', {"item": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to nULL or the PDF object owning the stream returned by
	* GetContainingStm() (e.g. the annotation to which an appearance stream
	* belongs).
	*
	* @note this method only applies to content items with type e_MCR.
	*/
		PDFNet.ContentItem.prototype.getStmOwner = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStmOwner'. Expected "+0+" arguments. Function Signature: getStmOwner()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStmOwner'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getStmOwner', {"item": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the referenced object.
	* @note this method only applies to content items with type e_OBJR.
	*/
		PDFNet.ContentItem.prototype.getRefObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRefObj'. Expected "+0+" arguments. Function Signature: getRefObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getRefObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ContentItem.getRefObj', {"item": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Initialize a RoleMap using an existing low-level Cos/SDF role map dictionary.
	*
	* @param dict - a low-level (SDF/Cos) RoleMap dictionary.
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.RoleMap.create = function(dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dict instanceof PDFNet.Obj)) {
			if(typeof dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+dict+"' in function 'create' is of type '"+(typeof dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('roleMapCreate', {"dict": dict.id}, this.userPriority).then(function(id){
			//there is a return type RoleMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.RoleMap(id);
		});
	},

		PDFNet.RoleMap.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('RoleMap.copy', {"p": this.id}, this.userPriority).then(function(id){
			//there is a return type RoleMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.RoleMap(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid (non-null) RoleMap, false otherwise.
	* If the function returns false the underlying SDF/Cos object is null or is
	* not valid and the RoleMap should be treated as NULL object.
	*/
		PDFNet.RoleMap.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('RoleMap.isValid', {"map": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the direct mapping of given StructElement type, or NULL
	* if such mapping is not defined.
	*
	* @param structural element type
	*/
		PDFNet.RoleMap.prototype.getDirectMap = function(type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getDirectMap'. Expected "+1+" argument. Function Signature: getDirectMap(string)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'getDirectMap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "string") {throw new TypeError("1st input argument '"+type+"' in function 'getDirectMap' is of type '"+(typeof type)+"'. Expected type 'string'. Function Signature: getDirectMap(string).");}
		return PDFNet.messageHandler.sendWithPromise('RoleMap.getDirectMap', {"map": this.id, "type": type}, this.userPriority);
	},

	/**
	* Returns the RoleMap dictionary.
	* @return A promise that resolves to the object to the underlying SDF/Cos dictionary.
	*/
		PDFNet.RoleMap.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('RoleMap.getSDFObj', {"map": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Initialize a SElement using an existing low-level Cos/SDF object.
	*
	* @param dict - a low-level (SDF/Cos) dictionary representing the structural element.
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.SElement.create = function(dict)
	{
		if(typeof dict === "undefined") {dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dict instanceof PDFNet.Obj)) {
			if(typeof dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+dict+"' in function 'create' is of type '"+(typeof dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('sElementCreate', {"dict": dict.id}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

		PDFNet.SElement.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(SElement)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.SElement) && right.name != "SElement") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'SElement'. Function Signature: assign(SElement).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'SElement'. Function Signature: assign(SElement).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "SElement.assign"; // TRN_SElement* left
		return PDFNet.messageHandler.sendWithPromise('SElement.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Creates a new SElement.
	*/
		PDFNet.SElement.createFromPDFDoc = function(doc, struct_type)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFromPDFDoc'. Expected "+2+" arguments. Function Signature: createFromPDFDoc(PDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromPDFDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromPDFDoc' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: createFromPDFDoc(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromPDFDoc' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: createFromPDFDoc(PDFDoc, string).");}
		}
		if(struct_type instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromPDFDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof struct_type != "string") {throw new TypeError("2nd input argument '"+struct_type+"' in function 'createFromPDFDoc' is of type '"+(typeof struct_type)+"'. Expected type 'string'. Function Signature: createFromPDFDoc(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('sElementCreateFromPDFDoc', {"doc": doc.id, "struct_type": struct_type}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

		PDFNet.SElement.prototype.insert = function(kid, insert_before)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insert'. Expected "+2+" arguments. Function Signature: insert(SElement, number)")};
		if(kid instanceof Promise) {throw new TypeError("1st input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(kid instanceof PDFNet.SElement) && kid.name != "SElement") {
			if(typeof kid == "object") {throw new TypeError("1st input argument in function 'insert' is of type '"+kid.name+"'. Expected type 'SElement'. Function Signature: insert(SElement, number).");}
			else {throw new TypeError("1st input argument '"+kid+"' in function 'insert' is of type '"+(typeof kid)+"'. Expected type 'SElement'. Function Signature: insert(SElement, number).");}
		}
		if(insert_before instanceof Promise) {throw new TypeError("2nd input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof insert_before != "number") {throw new TypeError("2nd input argument '"+insert_before+"' in function 'insert' is of type '"+(typeof insert_before)+"'. Expected type 'number'. Function Signature: insert(SElement, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'insert'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof kid.yieldFunction != "undefined") {throw new Error("Function '"+kid.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'insert'. Perhaps a yield statement is required for '"+kid.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "SElement.insert"; // TRN_SElement* kid
		return PDFNet.messageHandler.sendWithPromise('SElement.insert', {"e": this, "kid": kid, "insert_before": insert_before}, this.userPriority).then(function(id){
			copyFunc(id.e, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @param insert_before The position after which the kid is inserted. If
	* element currently has no kids, insert_before is ignored.
	*/
		PDFNet.SElement.prototype.createContentItem = function(doc, page, insert_before)
	{
		if(typeof insert_before === "undefined") {insert_before = -1;};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createContentItem'. Expected "+2+" to "+3+" arguments. Function Signature: createContentItem(PDFDoc, Page, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createContentItem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createContentItem' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: createContentItem(PDFDoc, Page, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createContentItem' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: createContentItem(PDFDoc, Page, number).");}
		}
		if(page instanceof Promise) {throw new TypeError("2nd input argument in function 'createContentItem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("2nd input argument in function 'createContentItem' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createContentItem(PDFDoc, Page, number).");}
			else {throw new TypeError("2nd input argument '"+page+"' in function 'createContentItem' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createContentItem(PDFDoc, Page, number).");}
		}
		if(insert_before instanceof Promise) {throw new TypeError("3rd input argument in function 'createContentItem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof insert_before != "number") {throw new TypeError("3rd input argument '"+insert_before+"' in function 'createContentItem' is of type '"+(typeof insert_before)+"'. Expected type 'number'. Function Signature: createContentItem(PDFDoc, Page, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'createContentItem'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "SElement.createContentItem"; // TRN_SElement* e
		return PDFNet.messageHandler.sendWithPromise('SElement.createContentItem', {"e": this, "doc": doc.id, "page": page.id, "insert_before": insert_before}, this.userPriority).then(function(id){
			copyFunc(id.e, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid structure element object, false otherwise.
	*/
		PDFNet.SElement.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.isValid', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the element's structural element type. The type corresponds to
	* the 'S' (i.e. subtype) key in the structure element dictionary.
	*
	* The type identifies the nature of the structure element and its role
	* within the document (such as a chapter, paragraph, or footnote).
	*/
		PDFNet.SElement.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getType'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getType', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of direct kids.
	*/
		PDFNet.SElement.prototype.getNumKids = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumKids'. Expected "+0+" arguments. Function Signature: getNumKids()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getNumKids'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getNumKids', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the kid at a given array index is a content item,
	* false otherwise.
	* @param index The index of the kid type to obtain.
	*
	* To retrieve a content item at a given array index use GetAsContentItem(index),
	* otherwise use GetAsStructElem(index)
	*/
		PDFNet.SElement.prototype.isContentItem = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isContentItem'. Expected "+1+" argument. Function Signature: isContentItem(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'isContentItem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'isContentItem' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: isContentItem(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isContentItem'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.isContentItem', {"e": this, "index": index}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the kid at a given array index assuming that the kid is a ContentItem.
	* @note use IsContentItem(index) prior to calling this method to make sure that
	* the kid is indeed a ContentItem.
	* @param index The index of the kid to obtain.
	*/
		PDFNet.SElement.prototype.getAsContentItem = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAsContentItem'. Expected "+1+" argument. Function Signature: getAsContentItem(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getAsContentItem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getAsContentItem' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getAsContentItem(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getAsContentItem'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getAsContentItem', {"e": this, "index": index}, this.userPriority).then(function(id){
			//there is a return type ContentItem
			if(id == "0"){
				return null;
			}
			return new PDFNet.ContentItem(id);
		});
	},

	/**
	* @return A promise that resolves to the kid at a given array index assuming that the kid is a SElement.
	* @note use IsContentItem(index) prior to calling this method to make sure that
	* the kid is not a ContentItem and is another SElement.
	* @param index The index of the kid to obtain.
	*/
		PDFNet.SElement.prototype.getAsStructElem = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAsStructElem'. Expected "+1+" argument. Function Signature: getAsStructElem(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getAsStructElem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getAsStructElem' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getAsStructElem(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getAsStructElem'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getAsStructElem', {"e": this, "index": index}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

	/**
	* @return A promise that resolves to the immediate ancestor element of the specified element in
	* the structure tree.
	*
	* @note If the element's parent is the structure tree root, the returned
	* SElement will be not valid (i.e. element.IsValid() -> false) and the
	* underlying SDF/Cos object will be NULL.
	*/
		PDFNet.SElement.prototype.getParent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParent'. Expected "+0+" arguments. Function Signature: getParent()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getParent'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getParent', {"e": this}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

	/**
	* @return A promise that resolves to the structure tree root of the document that directly or
	* indirectly contains this element.
	*/
		PDFNet.SElement.prototype.getStructTreeRoot = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStructTreeRoot'. Expected "+0+" arguments. Function Signature: getStructTreeRoot()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStructTreeRoot'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getStructTreeRoot', {"e": this}, this.userPriority).then(function(id){
			//there is a return type STree
			if(id == "0"){
				return null;
			}
			return new PDFNet.STree(id);
		});
	},

	/**
	* @return A promise that resolves to if this SElement has title.
	*
	* The title of the structure element, a text string representing it in
	* human-readable form.
	*/
		PDFNet.SElement.prototype.hasTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasTitle'. Expected "+0+" arguments. Function Signature: hasTitle()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'hasTitle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.hasTitle', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the title of this structure element.
	*/
		PDFNet.SElement.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getTitle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getTitle', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the ID of an element, or NULL if the ID is not defined.
	*/
		PDFNet.SElement.prototype.getID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getID'. Expected "+0+" arguments. Function Signature: getID()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getID'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getID', {"e": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to if this structure element defines ActualText.
	*
	* ActualText is an exact replacement for the structure element and its children.
	* This replacement text is useful when extracting the document's contents in
	* support of accessibility to users with disabilities or for other purposes.
	*/
		PDFNet.SElement.prototype.hasActualText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasActualText'. Expected "+0+" arguments. Function Signature: hasActualText()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'hasActualText'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.hasActualText', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the ActualText associated with this element.
	*
	* @note The ActualText can be defined as an empty string. To differentiate
	* between an ActualText string of zero length and no ActualText being defined,
	* use HasActualText().
	*/
		PDFNet.SElement.prototype.getActualText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getActualText'. Expected "+0+" arguments. Function Signature: getActualText()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getActualText'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getActualText', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to if this structure element defines Alt text.
	*
	* Alt text is an alternate description of the structure element and
	* its children in human-readable form, which is useful when extracting
	* the document's contents in support of accessibility.
	*/
		PDFNet.SElement.prototype.hasAlt = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasAlt'. Expected "+0+" arguments. Function Signature: hasAlt()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'hasAlt'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.hasAlt', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the alternate text associated with this element.
	*
	* @note The Alt text can be defined as an empty string. To differentiate
	* between an Alt text string of zero length and no Alt text being defined,
	* use HasAlt().
	*/
		PDFNet.SElement.prototype.getAlt = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAlt'. Expected "+0+" arguments. Function Signature: getAlt()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getAlt'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getAlt', {"e": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.SElement.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getSDFObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('SElement.getSDFObj', {"e": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Initialize a STree using an existing low-level Cos/SDF object.
	*
	* @param struct_dict - a low-level (SDF/Cos) dictionary representing the .
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.STree.create = function(struct_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(struct_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(struct_dict instanceof PDFNet.Obj)) {
			if(typeof struct_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+struct_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+struct_dict+"' in function 'create' is of type '"+(typeof struct_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('sTreeCreate', {"struct_dict": struct_dict.id}, this.userPriority).then(function(id){
			//there is a return type STree
			if(id == "0"){
				return null;
			}
			return new PDFNet.STree(id);
		});
	},

	/**
	* Create a structure tree if it is missing, else return the existing
	* structure tree
	*
	* @return A promise that resolves to structure tree of the document
	*/
		PDFNet.STree.createFromPDFDoc = function(doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromPDFDoc'. Expected "+1+" argument. Function Signature: createFromPDFDoc(PDFDoc)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromPDFDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromPDFDoc' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: createFromPDFDoc(PDFDoc).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromPDFDoc' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: createFromPDFDoc(PDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('sTreeCreateFromPDFDoc', {"doc": doc.id}, this.userPriority).then(function(id){
			//there is a return type STree
			if(id == "0"){
				return null;
			}
			return new PDFNet.STree(id);
		});
	},

	/**
	* Inserts the specified kid element after the given position as a kid of
	* the specified structure tree root.
	*
	* @param insert_before The position after which the kid is inserted. If
	* element currently has no kids, insert_before is ignored.
	*/
		PDFNet.STree.prototype.insert = function(kid, insert_before)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insert'. Expected "+2+" arguments. Function Signature: insert(SElement, number)")};
		if(kid instanceof Promise) {throw new TypeError("1st input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(kid instanceof PDFNet.SElement) && kid.name != "SElement") {
			if(typeof kid == "object") {throw new TypeError("1st input argument in function 'insert' is of type '"+kid.name+"'. Expected type 'SElement'. Function Signature: insert(SElement, number).");}
			else {throw new TypeError("1st input argument '"+kid+"' in function 'insert' is of type '"+(typeof kid)+"'. Expected type 'SElement'. Function Signature: insert(SElement, number).");}
		}
		if(insert_before instanceof Promise) {throw new TypeError("2nd input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof insert_before != "number") {throw new TypeError("2nd input argument '"+insert_before+"' in function 'insert' is of type '"+(typeof insert_before)+"'. Expected type 'number'. Function Signature: insert(SElement, number).");}
		if(typeof kid.yieldFunction != "undefined") {throw new Error("Function '"+kid.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'insert'. Perhaps a yield statement is required for '"+kid.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "STree.insert"; // TRN_SElement* kid
		return PDFNet.messageHandler.sendWithPromise('STree.insert', {"tree": this.id, "kid": kid, "insert_before": insert_before}, this.userPriority).then(function(id){
			copyFunc(id.kid, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.STree.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('STree.copy', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type STree
			if(id == "0"){
				return null;
			}
			return new PDFNet.STree(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid STree object, false otherwise.
	*/
		PDFNet.STree.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('STree.isValid', {"tree": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of kids of the structure tree root.
	*/
		PDFNet.STree.prototype.getNumKids = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumKids'. Expected "+0+" arguments. Function Signature: getNumKids()")};
		return PDFNet.messageHandler.sendWithPromise('STree.getNumKids', {"tree": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the kid at an array index in the structure tree root.
	* @param index The index of the kid to obtain.
	*/
		PDFNet.STree.prototype.getKid = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getKid'. Expected "+1+" argument. Function Signature: getKid(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getKid' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getKid' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getKid(number).");}
		return PDFNet.messageHandler.sendWithPromise('STree.getKid', {"tree": this.id, "index": index}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

	/**
	* @return A promise that resolves to the RoleMap object from the structure tree root.
	*/
		PDFNet.STree.prototype.getRoleMap = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRoleMap'. Expected "+0+" arguments. Function Signature: getRoleMap()")};
		return PDFNet.messageHandler.sendWithPromise('STree.getRoleMap', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type RoleMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.RoleMap(id);
		});
	},

	/**
	* @return A promise that resolves to the ClassMap object from the structure tree root.
	*/
		PDFNet.STree.prototype.getClassMap = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getClassMap'. Expected "+0+" arguments. Function Signature: getClassMap()")};
		return PDFNet.messageHandler.sendWithPromise('STree.getClassMap', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type ClassMap
			if(id == "0"){
				return null;
			}
			return new PDFNet.ClassMap(id);
		});
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.STree.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('STree.getSDFObj', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* creates a new 'GoTo'action. GoTo action takes the user to the
	* specified Destination view located in the same document.
	*
	* @param dest A Destination for the new Action.
	*
	* @note This method can only be used for destinations in the same
	* document as the source document. For cross-document links use
	* Action::CreateGotoRemote().
	*/
		PDFNet.Action.createGoto = function(dest)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createGoto'. Expected "+1+" argument. Function Signature: createGoto(Destination)")};
		if(dest instanceof Promise) {throw new TypeError("1st input argument in function 'createGoto' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest instanceof PDFNet.Destination)) {
			if(typeof dest == "object") {throw new TypeError("1st input argument in function 'createGoto' is of type '"+dest.name+"'. Expected type 'Destination'. Function Signature: createGoto(Destination).");}
			else {throw new TypeError("1st input argument '"+dest+"' in function 'createGoto' is of type '"+(typeof dest)+"'. Expected type 'Destination'. Function Signature: createGoto(Destination).");}
		}
		return PDFNet.messageHandler.sendWithPromise('actionCreateGoto', {"dest": dest.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createGotoWithKey = function(key, dest)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createGotoWithKey'. Expected "+2+" arguments. Function Signature: createGotoWithKey(string, Destination)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'createGotoWithKey' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'createGotoWithKey' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: createGotoWithKey(string, Destination).");}
		if(dest instanceof Promise) {throw new TypeError("2nd input argument in function 'createGotoWithKey' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest instanceof PDFNet.Destination)) {
			if(typeof dest == "object") {throw new TypeError("2nd input argument in function 'createGotoWithKey' is of type '"+dest.name+"'. Expected type 'Destination'. Function Signature: createGotoWithKey(string, Destination).");}
			else {throw new TypeError("2nd input argument '"+dest+"' in function 'createGotoWithKey' is of type '"+(typeof dest)+"'. Expected type 'Destination'. Function Signature: createGotoWithKey(string, Destination).");}
		}
		return PDFNet.messageHandler.sendWithPromise('actionCreateGotoWithKey', {"key": key, "dest": dest.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* creates a new 'GoToR'action. A remote go-to action is similar to an
	* ordinary go-to action but jumps to a destination in another PDF file
	* instead of the current file.
	*
	* @param file The file referred to by the action.
	* @param page_num A page number within the remote document. The first page is
	* numbered 0.
	* @new_window A flag specifying whether to open the destination document
	* in a new window. If new_window is false, the destination document replaces
	* the current document in the same window, otherwise the viewer application
	* should behave in accordance with the current user preference.
	*/
		PDFNet.Action.createGotoRemote = function(file, page_num)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createGotoRemote'. Expected "+2+" arguments. Function Signature: createGotoRemote(FileSpec, number)")};
		if(file instanceof Promise) {throw new TypeError("1st input argument in function 'createGotoRemote' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(file instanceof PDFNet.FileSpec)) {
			if(typeof file == "object") {throw new TypeError("1st input argument in function 'createGotoRemote' is of type '"+file.name+"'. Expected type 'FileSpec'. Function Signature: createGotoRemote(FileSpec, number).");}
			else {throw new TypeError("1st input argument '"+file+"' in function 'createGotoRemote' is of type '"+(typeof file)+"'. Expected type 'FileSpec'. Function Signature: createGotoRemote(FileSpec, number).");}
		}
		if(page_num instanceof Promise) {throw new TypeError("2nd input argument in function 'createGotoRemote' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("2nd input argument '"+page_num+"' in function 'createGotoRemote' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: createGotoRemote(FileSpec, number).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateGotoRemote', {"file": file.id, "page_num": page_num}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* Creates a new 'GoToR'action. See the above method for details.
	*
	* @param file The file referred to by the action.
	* @param page_num A page number within the remote document. The first page is
	* numbered 0.
	* @new_window A flag specifying whether to open the destination document
	* in a new window. If new_window is false, the destination document replaces
	* the current document in the same window, otherwise the viewer application
	* should behave in accordance with the current user preference.
	*/
		PDFNet.Action.createGotoRemoteSetNewWindow = function(file, page_num, new_window)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createGotoRemoteSetNewWindow'. Expected "+3+" arguments. Function Signature: createGotoRemoteSetNewWindow(FileSpec, number, boolean)")};
		if(file instanceof Promise) {throw new TypeError("1st input argument in function 'createGotoRemoteSetNewWindow' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(file instanceof PDFNet.FileSpec)) {
			if(typeof file == "object") {throw new TypeError("1st input argument in function 'createGotoRemoteSetNewWindow' is of type '"+file.name+"'. Expected type 'FileSpec'. Function Signature: createGotoRemoteSetNewWindow(FileSpec, number, boolean).");}
			else {throw new TypeError("1st input argument '"+file+"' in function 'createGotoRemoteSetNewWindow' is of type '"+(typeof file)+"'. Expected type 'FileSpec'. Function Signature: createGotoRemoteSetNewWindow(FileSpec, number, boolean).");}
		}
		if(page_num instanceof Promise) {throw new TypeError("2nd input argument in function 'createGotoRemoteSetNewWindow' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("2nd input argument '"+page_num+"' in function 'createGotoRemoteSetNewWindow' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: createGotoRemoteSetNewWindow(FileSpec, number, boolean).");}
		if(new_window instanceof Promise) {throw new TypeError("3rd input argument in function 'createGotoRemoteSetNewWindow' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof new_window != "boolean") {throw new TypeError("3rd input argument '"+new_window+"' in function 'createGotoRemoteSetNewWindow' is of type '"+(typeof new_window)+"'. Expected type 'boolean'. Function Signature: createGotoRemoteSetNewWindow(FileSpec, number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateGotoRemoteSetNewWindow', {"file": file.id, "page_num": page_num, "new_window": new_window}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* Create a new URI action. The URI action is typically resolved by opening a URL in
	* the default web browser.
	*
	* @param doc The document in which to create the action.
	* @param uri The uniform resource identifier to resolve, encoded in 7-bit ASCII.
	* A uniform resource identifier (URI) is a string that identifies (resolves to) a resource
	* on the Internet; typically a file that is the destination of a hypertext link, although
	* it can also resolve to a query or other entity. (URIs are described in Internet RFC 2396,
	* Uniform Resource Identifiers (URI).
	*/
		PDFNet.Action.createURI = function(sdfdoc, uri)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createURI'. Expected "+2+" arguments. Function Signature: createURI(SDFDoc, string)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createURI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createURI' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createURI(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createURI' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createURI(SDFDoc, string).");}
		}
		if(uri instanceof Promise) {throw new TypeError("2nd input argument in function 'createURI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof uri != "string") {throw new TypeError("2nd input argument '"+uri+"' in function 'createURI' is of type '"+(typeof uri)+"'. Expected type 'string'. Function Signature: createURI(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateURI', {"sdfdoc": sdfdoc.id, "uri": uri}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* creates a new 'SubmitForm'action. A submit-form action transmits the names
	* and values of selected interactive form fields to a specified uniform
	* resource locator (URL), presumably the address of a Web server that will
	* process them and send back a response.
	*
	* @param url A URL file specification giving the uniform resource locator (URL)
	* of the script at the Web server that will process the submission.
	*/
		PDFNet.Action.createSubmitForm = function(url)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createSubmitForm'. Expected "+1+" argument. Function Signature: createSubmitForm(FileSpec)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'createSubmitForm' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(url instanceof PDFNet.FileSpec)) {
			if(typeof url == "object") {throw new TypeError("1st input argument in function 'createSubmitForm' is of type '"+url.name+"'. Expected type 'FileSpec'. Function Signature: createSubmitForm(FileSpec).");}
			else {throw new TypeError("1st input argument '"+url+"' in function 'createSubmitForm' is of type '"+(typeof url)+"'. Expected type 'FileSpec'. Function Signature: createSubmitForm(FileSpec).");}
		}
		return PDFNet.messageHandler.sendWithPromise('actionCreateSubmitForm', {"url": url.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createLaunch = function(sdfdoc, path)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createLaunch'. Expected "+2+" arguments. Function Signature: createLaunch(SDFDoc, string)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createLaunch' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createLaunch' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createLaunch(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createLaunch' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createLaunch(SDFDoc, string).");}
		}
		if(path instanceof Promise) {throw new TypeError("2nd input argument in function 'createLaunch' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("2nd input argument '"+path+"' in function 'createLaunch' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: createLaunch(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateLaunch', {"sdfdoc": sdfdoc.id, "path": path}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createHideField = function(sdfdoc, list_length, field_list)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createHideField'. Expected "+3+" arguments. Function Signature: createHideField(SDFDoc, number, string)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createHideField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createHideField' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createHideField(SDFDoc, number, string).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createHideField' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createHideField(SDFDoc, number, string).");}
		}
		if(list_length instanceof Promise) {throw new TypeError("2nd input argument in function 'createHideField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof list_length != "number") {throw new TypeError("2nd input argument '"+list_length+"' in function 'createHideField' is of type '"+(typeof list_length)+"'. Expected type 'number'. Function Signature: createHideField(SDFDoc, number, string).");}
		if(field_list instanceof Promise) {throw new TypeError("3rd input argument in function 'createHideField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_list != "string") {throw new TypeError("3rd input argument '"+field_list+"' in function 'createHideField' is of type '"+(typeof field_list)+"'. Expected type 'string'. Function Signature: createHideField(SDFDoc, number, string).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateHideField', {"sdfdoc": sdfdoc.id, "list_length": list_length, "field_list": field_list}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createImportData = function(sdfdoc, path)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createImportData'. Expected "+2+" arguments. Function Signature: createImportData(SDFDoc, string)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createImportData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createImportData' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createImportData(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createImportData' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createImportData(SDFDoc, string).");}
		}
		if(path instanceof Promise) {throw new TypeError("2nd input argument in function 'createImportData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("2nd input argument '"+path+"' in function 'createImportData' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: createImportData(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateImportData', {"sdfdoc": sdfdoc.id, "path": path}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createResetForm = function(sdfdoc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createResetForm'. Expected "+1+" argument. Function Signature: createResetForm(SDFDoc)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createResetForm' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createResetForm' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createResetForm(SDFDoc).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createResetForm' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createResetForm(SDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('actionCreateResetForm', {"sdfdoc": sdfdoc.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.createJavaScript = function(sdfdoc, script)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createJavaScript'. Expected "+2+" arguments. Function Signature: createJavaScript(SDFDoc, string)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createJavaScript' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createJavaScript' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createJavaScript(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createJavaScript' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createJavaScript(SDFDoc, string).");}
		}
		if(script instanceof Promise) {throw new TypeError("2nd input argument in function 'createJavaScript' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof script != "string") {throw new TypeError("2nd input argument '"+script+"' in function 'createJavaScript' is of type '"+(typeof script)+"'. Expected type 'string'. Function Signature: createJavaScript(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('actionCreateJavaScript', {"sdfdoc": sdfdoc.id, "script": script}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* A constructor. Creates an Action and initializes it using given Cos/SDF object.
	*
	* @param in_obj Pointer to the Cos/SDF object.
	*
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.Action.create = function(in_obj)
	{
		if(typeof in_obj === "undefined") {in_obj = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(in_obj instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_obj instanceof PDFNet.Obj)) {
			if(typeof in_obj == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+in_obj.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+in_obj+"' in function 'create' is of type '"+(typeof in_obj)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('actionCreate', {"in_obj": in_obj.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Action.copy', {"in_action": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.Action.prototype.compare = function(in_action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(Action)")};
		if(in_action instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_action instanceof PDFNet.Action)) {
			if(typeof in_action == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+in_action.name+"'. Expected type 'Action'. Function Signature: compare(Action).");}
			else {throw new TypeError("1st input argument '"+in_action+"' in function 'compare' is of type '"+(typeof in_action)+"'. Expected type 'Action'. Function Signature: compare(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Action.compare', {"action": this.id, "in_action": in_action.id}, this.userPriority);
	},

	/**
	* Indicates whether the Action is valid (non-null).
	*
	* @return A promise that resolves to true if this is a valid (non-null) Action; otherwise false.
	*
	* @note If this method returns false the underlying SDF/Cos object is null and
	* the Action object should be treated as null as well.
	*/
		PDFNet.Action.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Action.isValid', {"action": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the type of this Action.
	*/
		PDFNet.Action.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Action.getType', {"action": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Action's Destination view.
	*
	* @note This only works for Actions whose subtype is "GoTo".
	*
	* @note All named destinations are automatically resolved to the
	* explicit destination so you can access destination members directly.
	*/
		PDFNet.Action.prototype.getDest = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDest'. Expected "+0+" arguments. Function Signature: getDest()")};
		return PDFNet.messageHandler.sendWithPromise('Action.getDest', {"action": this.id}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* @return A promise that resolves to the next action dictionary, an array of action dictionaries,
	* or NULL if there are no additional actions.
	*
	* Sequences of actions can be chained together. For example, the effect
	* of clicking a link annotation with the mouse might be to play a sound,
	* jump to a new page, and start up a movie. Note that the Next entry is
	* not restricted to a single action but may contain an array of actions,
	* each of which in turn may have a Next entry of its own. The actions may
	* thus form a tree instead of a simple linked list. Actions within each
	* Next array are executed in order, each followed in turn by any actions
	* specified in its Next entry, and so on recursively.
	*/
		PDFNet.Action.prototype.getNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNext'. Expected "+0+" arguments. Function Signature: getNext()")};
		return PDFNet.messageHandler.sendWithPromise('Action.getNext', {"action": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to pointer to the underlying SDF/Cos object.
	*/
		PDFNet.Action.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Action.getSDFObj', {"action": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.Action.prototype.GetFormActionFlag = function(flag)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'GetFormActionFlag'. Expected "+1+" argument. Function Signature: GetFormActionFlag(number)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'GetFormActionFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'GetFormActionFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: GetFormActionFlag(number).");}
		return PDFNet.messageHandler.sendWithPromise('Action.GetFormActionFlag', {"action": this.id, "flag": flag}, this.userPriority);
	},

		PDFNet.Action.prototype.SetFormActionFlag = function(flag, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'SetFormActionFlag'. Expected "+2+" arguments. Function Signature: SetFormActionFlag(number, boolean)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'SetFormActionFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'SetFormActionFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: SetFormActionFlag(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'SetFormActionFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'SetFormActionFlag' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: SetFormActionFlag(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Action.SetFormActionFlag', {"action": this.id, "flag": flag, "value": value}, this.userPriority);
	},

		PDFNet.Action.prototype.Execute = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'Execute'. Expected "+0+" arguments. Function Signature: Execute()")};
		return PDFNet.messageHandler.sendWithPromise('Action.Execute', {"action": this.id}, this.userPriority);
	},

	/**
	* Initialize a page using an existing low-level Cos/SDF page object.
	*
	* @param page_dict - a low-level (SDF/Cos) page dictionary.
	*
	* @note This constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*
	* @note Because PDF::PDFDoc provides a complete high-level interface for Page creation
	* and traversal this constructor is rarely used.
	*/
		PDFNet.Page.create = function(page_dict)
	{
		if(typeof page_dict === "undefined") {page_dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(page_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_dict instanceof PDFNet.Obj)) {
			if(typeof page_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+page_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+page_dict+"' in function 'create' is of type '"+(typeof page_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pageCreate', {"page_dict": page_dict.id}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

		PDFNet.Page.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Page.copy', {"p": this.id}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid (non-null) page, false otherwise.
	* If the function returns false the underlying SDF/Cos object is null
	* or is not valid.
	*/
		PDFNet.Page.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Page.isValid', {"page": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Page number indication the position of this Page in document's page sequence.
	* Document's page sequence is indexed from 1. Page number 0 means that the page is not part
	* of document's page sequence or that the page is not valid.
	*/
		PDFNet.Page.prototype.getIndex = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIndex'. Expected "+0+" arguments. Function Signature: getIndex()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getIndex', {"page": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the box specified for the page object intersected with the media box.
	*
	* @param type The type of the page bounding box. Possible values are: e_media, e_crop,
	* e_bleed, e_trim, and e_art.
	*
	* If the value for 'type' is e_crop, this call is equivalent to GetCropBox().
	* If the value for 'type' is e_media, this call is equivalent to GetMediaBox().
	*/
		PDFNet.Page.prototype.getBox = function(type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getBox'. Expected "+1+" argument. Function Signature: getBox(number)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'getBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'getBox' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: getBox(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.getBox', {"page": this.id, "type": type}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* Sets the page bounding box specified by 'page_region' for this page.
	*
	* @param type The type of the page bounding box. Possible values are: e_media, e_crop,
	* e_bleed, e_trim, and e_art.
	* @param box A rectangle specifying the coordinates to set for the box. The coordinates are
	* specified in user space units.
	*/
		PDFNet.Page.prototype.setBox = function(type, box)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBox'. Expected "+2+" arguments. Function Signature: setBox(number, Rect)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'setBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'setBox' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: setBox(number, Rect).");}
		if(box instanceof Promise) {throw new TypeError("2nd input argument in function 'setBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(box instanceof PDFNet.Rect) && box.name != "Rect") {
			if(typeof box == "object") {throw new TypeError("2nd input argument in function 'setBox' is of type '"+box.name+"'. Expected type 'Rect'. Function Signature: setBox(number, Rect).");}
			else {throw new TypeError("2nd input argument '"+box+"' in function 'setBox' is of type '"+(typeof box)+"'. Expected type 'Rect'. Function Signature: setBox(number, Rect).");}
		}
		if(typeof box.yieldFunction != "undefined") {throw new Error("Function '"+box.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setBox'. Perhaps a yield statement is required for '"+box.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Page.setBox', {"page": this.id, "type": type, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the crop box for this page. The page dimensions are specified in user space
	* coordinates.
	*
	* The crop box is the region of the page to display and print.
	* @note this method is equivalent to GetBox(Page::e_crop)
	*/
		PDFNet.Page.prototype.getCropBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCropBox'. Expected "+0+" arguments. Function Signature: getCropBox()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getCropBox', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* Sets the crop box for this page. The crop box is the region of the page to
	* display and print.
	*
	* @param box the new crop box for this page. The page dimensions are specified in user space
	* coordinates.
	*
	* The crop box defines the region to which the contents of the page are to be clipped (cropped)
	* when displayed or printed.
	*
	* @note this method is equivalent to SetBox(Page::e_crop)
	*/
		PDFNet.Page.prototype.setCropBox = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCropBox'. Expected "+1+" argument. Function Signature: setCropBox(Rect)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setCropBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(box instanceof PDFNet.Rect) && box.name != "Rect") {
			if(typeof box == "object") {throw new TypeError("1st input argument in function 'setCropBox' is of type '"+box.name+"'. Expected type 'Rect'. Function Signature: setCropBox(Rect).");}
			else {throw new TypeError("1st input argument '"+box+"' in function 'setCropBox' is of type '"+(typeof box)+"'. Expected type 'Rect'. Function Signature: setCropBox(Rect).");}
		}
		if(typeof box.yieldFunction != "undefined") {throw new Error("Function '"+box.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setCropBox'. Perhaps a yield statement is required for '"+box.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Page.setCropBox', {"page": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the media box for this page. The page dimensions are specified in user space
	* coordinates.
	*
	* The media box defines the boundaries of the physical medium on which the page is to
	* be printed. It may include any extended area surrounding the finished page for bleed,
	* printing marks, or other such purposes.
	*
	* @note this method is equivalent to GetBox(Page::e_media)
	* @exception if the page is missing media box the function throws Exception
	*/
		PDFNet.Page.prototype.getMediaBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMediaBox'. Expected "+0+" arguments. Function Signature: getMediaBox()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getMediaBox', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* Sets the media box for this page.
	*
	* @param box the new media box for this page. The page dimensions are specified in user space
	* coordinates.
	*
	* The media box defines the boundaries of the physical medium on which the page is to
	* be printed. It may include any extended area surrounding the finished page for bleed,
	* printing marks, or other such purposes.
	*
	* @note this method is equivalent to SetBox(Page::e_media)
	*/
		PDFNet.Page.prototype.setMediaBox = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMediaBox'. Expected "+1+" argument. Function Signature: setMediaBox(Rect)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setMediaBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(box instanceof PDFNet.Rect) && box.name != "Rect") {
			if(typeof box == "object") {throw new TypeError("1st input argument in function 'setMediaBox' is of type '"+box.name+"'. Expected type 'Rect'. Function Signature: setMediaBox(Rect).");}
			else {throw new TypeError("1st input argument '"+box+"' in function 'setMediaBox' is of type '"+(typeof box)+"'. Expected type 'Rect'. Function Signature: setMediaBox(Rect).");}
		}
		if(typeof box.yieldFunction != "undefined") {throw new Error("Function '"+box.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setMediaBox'. Perhaps a yield statement is required for '"+box.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Page.setMediaBox', {"page": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the bounding box for this page. The page dimensions are specified in user space
	* coordinates.
	*
	* The bounding box is defined as the smallest rectangle that includes all the visible content on the page.
	*/
		PDFNet.Page.prototype.getVisibleContentBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVisibleContentBox'. Expected "+0+" arguments. Function Signature: getVisibleContentBox()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getVisibleContentBox', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* @return A promise that resolves to the rotation value for this page.
	*/
		PDFNet.Page.prototype.getRotation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRotation'. Expected "+0+" arguments. Function Signature: getRotation()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getRotation', {"page": this.id}, this.userPriority);
	},

	/**
	* Sets the rotation value for this page.
	*
	* @param angle Rotation value to be set for a given page. Must be one
	* of the Page::Rotate values.
	*/
		PDFNet.Page.prototype.setRotation = function(angle)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRotation'. Expected "+1+" argument. Function Signature: setRotation(number)")};
		if(angle instanceof Promise) {throw new TypeError("1st input argument in function 'setRotation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof angle != "number") {throw new TypeError("1st input argument '"+angle+"' in function 'setRotation' is of type '"+(typeof angle)+"'. Expected type 'number'. Function Signature: setRotation(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.setRotation', {"page": this.id, "angle": angle}, this.userPriority);
	},

	/**
	* Rotate r0 clockwise by r1
	*
	* @param r0 first rotation.
	* @param r1 second rotation.
	* @return A promise that resolves to returns r0 + r1
	*/
		PDFNet.Page.addRotations = function(r0, r1)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addRotations'. Expected "+2+" arguments. Function Signature: addRotations(number, number)")};
		if(r0 instanceof Promise) {throw new TypeError("1st input argument in function 'addRotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r0 != "number") {throw new TypeError("1st input argument '"+r0+"' in function 'addRotations' is of type '"+(typeof r0)+"'. Expected type 'number'. Function Signature: addRotations(number, number).");}
		if(r1 instanceof Promise) {throw new TypeError("2nd input argument in function 'addRotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r1 != "number") {throw new TypeError("2nd input argument '"+r1+"' in function 'addRotations' is of type '"+(typeof r1)+"'. Expected type 'number'. Function Signature: addRotations(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageAddRotations', {"r0": r0, "r1": r1}, this.userPriority);
	},

	/**
	* Rotate r0 counter clockwise by r1.
	*
	* @param r0 first rotation.
	* @param r1 second rotation.
	* @return A promise that resolves to returns r0 - r1
	*/
		PDFNet.Page.subtractRotations = function(r0, r1)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'subtractRotations'. Expected "+2+" arguments. Function Signature: subtractRotations(number, number)")};
		if(r0 instanceof Promise) {throw new TypeError("1st input argument in function 'subtractRotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r0 != "number") {throw new TypeError("1st input argument '"+r0+"' in function 'subtractRotations' is of type '"+(typeof r0)+"'. Expected type 'number'. Function Signature: subtractRotations(number, number).");}
		if(r1 instanceof Promise) {throw new TypeError("2nd input argument in function 'subtractRotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r1 != "number") {throw new TypeError("2nd input argument '"+r1+"' in function 'subtractRotations' is of type '"+(typeof r1)+"'. Expected type 'number'. Function Signature: subtractRotations(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageSubtractRotations', {"r0": r0, "r1": r1}, this.userPriority);
	},

	/**
	* Convert a rotation to a number.
	*
	* @param r rotation to convert to number
	* @return A promise that resolves to one of four numbers; 0, 90, 180 or 270.
	*/
		PDFNet.Page.rotationToDegree = function(r)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'rotationToDegree'. Expected "+1+" argument. Function Signature: rotationToDegree(number)")};
		if(r instanceof Promise) {throw new TypeError("1st input argument in function 'rotationToDegree' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r != "number") {throw new TypeError("1st input argument '"+r+"' in function 'rotationToDegree' is of type '"+(typeof r)+"'. Expected type 'number'. Function Signature: rotationToDegree(number).");}
		return PDFNet.messageHandler.sendWithPromise('pageRotationToDegree', {"r": r}, this.userPriority);
	},

	/**
	* Convert a number that represents rotation in degrees to a rotation enum.
	*
	* @param r degree to convert to rotation. Valid numbers are multiples of 90.
	* @return A promise that resolves to one of four angles; e_0, e_90, e_180 or e_270. Returns e_0 if input is
	* not a multiple 90.
	*/
		PDFNet.Page.degreeToRotation = function(r)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'degreeToRotation'. Expected "+1+" argument. Function Signature: degreeToRotation(number)")};
		if(r instanceof Promise) {throw new TypeError("1st input argument in function 'degreeToRotation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r != "number") {throw new TypeError("1st input argument '"+r+"' in function 'degreeToRotation' is of type '"+(typeof r)+"'. Expected type 'number'. Function Signature: degreeToRotation(number).");}
		return PDFNet.messageHandler.sendWithPromise('pageDegreeToRotation', {"r": r}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the width for the given page region/box taking into account page
	* rotation attribute (i.e. /Rotate entry in page dictionary).
	*
	* @param box_type indicates the page box/region to query for width.
	*/
		PDFNet.Page.prototype.getPageWidth = function(box_type)
	{
		if(typeof box_type === "undefined") {box_type = exports.PDFNet.Page.Box.e_crop};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPageWidth'. Expected at most "+1+" arguments. Function Signature: getPageWidth(number)")};
		if(box_type instanceof Promise) {throw new TypeError("1st input argument in function 'getPageWidth' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box_type != "number") {throw new TypeError("1st input argument '"+box_type+"' in function 'getPageWidth' is of type '"+(typeof box_type)+"'. Expected type 'number'. Function Signature: getPageWidth(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.getPageWidth', {"page": this.id, "box_type": box_type}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the height for the given page region/box taking into account page
	* rotation attribute (i.e. /Rotate entry in page dictionary).
	*
	* @param box_type indicates the page box/region to query for height.
	*/
		PDFNet.Page.prototype.getPageHeight = function(box_type)
	{
		if(typeof box_type === "undefined") {box_type = exports.PDFNet.Page.Box.e_crop};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPageHeight'. Expected at most "+1+" arguments. Function Signature: getPageHeight(number)")};
		if(box_type instanceof Promise) {throw new TypeError("1st input argument in function 'getPageHeight' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box_type != "number") {throw new TypeError("1st input argument '"+box_type+"' in function 'getPageHeight' is of type '"+(typeof box_type)+"'. Expected type 'number'. Function Signature: getPageHeight(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.getPageHeight', {"page": this.id, "box_type": box_type}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the matrix that transforms user space coordinates to rotated and cropped coordinates.
	* The origin of this space is the bottom-left of the rotated, cropped page.
	*
	* @param flip_y this parameter can be used to mirror the page. if 'flip_y' is true the Y
	* axis is not flipped and it is increasing, otherwise Y axis is decreasing.
	*
	* @param box_type an optional parameter used to specify the page box/region that the matrix
	* should map to. By default, the function transforms user space coordinates to cropped
	* coordinates.
	*
	* @param angle an optional parameter used to specify page rotation in addition to the
	* rotation specified in the page dictionary. This parameter is usually used to rotate the
	* page without modifying the document itself.
	*/
		PDFNet.Page.prototype.getDefaultMatrix = function(flip_y, box_type, angle)
	{
		if(typeof flip_y === "undefined") {flip_y = false;};
		if(typeof box_type === "undefined") {box_type = exports.PDFNet.Page.Box.e_crop};
		if(typeof angle === "undefined") {angle = exports.PDFNet.Page.Rotate.e_0};
		if(arguments.length > 3) {throw new RangeError(arguments.length+" arguments passed into function 'getDefaultMatrix'. Expected at most "+3+" arguments. Function Signature: getDefaultMatrix(boolean, number, number)")};
		if(flip_y instanceof Promise) {throw new TypeError("1st input argument in function 'getDefaultMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flip_y != "boolean") {throw new TypeError("1st input argument '"+flip_y+"' in function 'getDefaultMatrix' is of type '"+(typeof flip_y)+"'. Expected type 'boolean'. Function Signature: getDefaultMatrix(boolean, number, number).");}
		if(box_type instanceof Promise) {throw new TypeError("2nd input argument in function 'getDefaultMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box_type != "number") {throw new TypeError("2nd input argument '"+box_type+"' in function 'getDefaultMatrix' is of type '"+(typeof box_type)+"'. Expected type 'number'. Function Signature: getDefaultMatrix(boolean, number, number).");}
		if(angle instanceof Promise) {throw new TypeError("3rd input argument in function 'getDefaultMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof angle != "number") {throw new TypeError("3rd input argument '"+angle+"' in function 'getDefaultMatrix' is of type '"+(typeof angle)+"'. Expected type 'number'. Function Signature: getDefaultMatrix(boolean, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.getDefaultMatrix', {"page": this.id, "flip_y": flip_y, "box_type": box_type, "angle": angle}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* Returns SDF/Cos array containing annotation dictionaries. See Section 8.4 in
	* the PDF Reference for a description of the annotation array.
	*
	* @return A promise that resolves to an array of annotation dictionaries representing annotations
	* associated with the page or NULL if page dictionary is not specified.
	*/
		PDFNet.Page.prototype.getAnnots = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAnnots'. Expected "+0+" arguments. Function Signature: getAnnots()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getAnnots', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Returns the number of annotations on a page. Widget annotations (form fields) are
	* included in the count.
	*
	* @return A promise that resolves to the number of annotations on a page.
	*/
		PDFNet.Page.prototype.getNumAnnots = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumAnnots'. Expected "+0+" arguments. Function Signature: getNumAnnots()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getNumAnnots', {"page": this.id}, this.userPriority);
	},

	/**
	* Returns the annotation on the page.
	*
	* @return A promise that resolves to annotation object. If the index is out of range returned Annot object
	* is not valid (i.e. annot.IsValid() returns false).
	*
	* @param index - The index of the annotation to get on a page. The first annotation
	* on a page has an index of zero.
	*/
		PDFNet.Page.prototype.getAnnot = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAnnot'. Expected "+1+" argument. Function Signature: getAnnot(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getAnnot' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getAnnot(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.getAnnot', {"page": this.id, "index": index}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

	/**
	* Adds an annotation at the specified location in a page's annotation array.
	*
	* @param pos - The location in the array to insert the object. The object is inserted
	* before the specified location. The first element in an array has a pos of zero.
	* If pos >= GetNumAnnots(), the method appends the annotation to the array.
	* @param annot - The annotation to add.
	*/
		PDFNet.Page.prototype.annotInsert = function(pos, annot)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'annotInsert'. Expected "+2+" arguments. Function Signature: annotInsert(number, Annot)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'annotInsert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'annotInsert' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: annotInsert(number, Annot).");}
		if(annot instanceof Promise) {throw new TypeError("2nd input argument in function 'annotInsert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("2nd input argument in function 'annotInsert' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: annotInsert(number, Annot).");}
			else {throw new TypeError("2nd input argument '"+annot+"' in function 'annotInsert' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: annotInsert(number, Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Page.annotInsert', {"page": this.id, "pos": pos, "annot": annot.id}, this.userPriority);
	},

	/**
	* Adds an annotation to the end of a page's annotation array.
	* @param annot - The annotation to prepend in a page's annotation array.
	*/
		PDFNet.Page.prototype.annotPushBack = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'annotPushBack'. Expected "+1+" argument. Function Signature: annotPushBack(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'annotPushBack' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'annotPushBack' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: annotPushBack(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'annotPushBack' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: annotPushBack(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Page.annotPushBack', {"page": this.id, "annot": annot.id}, this.userPriority);
	},

	/**
	* Adds an annotation to the beginning of a page's annotation array.
	* @param annot - The annotation to append in a page's annotation array.
	*/
		PDFNet.Page.prototype.annotPushFront = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'annotPushFront'. Expected "+1+" argument. Function Signature: annotPushFront(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'annotPushFront' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'annotPushFront' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: annotPushFront(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'annotPushFront' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: annotPushFront(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Page.annotPushFront', {"page": this.id, "annot": annot.id}, this.userPriority);
	},

	/**
	* Removes the given annotation from the page.
	* @note Removing the annotation invalidates the given Annot object.
	* @param index - A zero based index of the annotation to remove.
	*/
		PDFNet.Page.prototype.annotRemove = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'annotRemove'. Expected "+1+" argument. Function Signature: annotRemove(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'annotRemove' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'annotRemove' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: annotRemove(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'annotRemove' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: annotRemove(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Page.annotRemove', {"page": this.id, "annot": annot.id}, this.userPriority);
	},

	/**
	* Removes the annotation at a given location.
	* @note Removing the annotation invalidates any associated Annot object.
	* @param index - A zero based index of the annotation to remove.
	*/
		PDFNet.Page.prototype.annotRemoveByIndex = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'annotRemoveByIndex'. Expected "+1+" argument. Function Signature: annotRemoveByIndex(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'annotRemoveByIndex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'annotRemoveByIndex' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: annotRemoveByIndex(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.annotRemoveByIndex', {"page": this.id, "index": index}, this.userPriority);
	},

	/**
	* A utility method used to scale physical dimensions of the page including
	* all page content.
	*
	* @param scale A number greater than 0 which is used as a scale factor.
	*  For example, calling page.Scale(0.5) will reduce physical dimensions of the
	*  page to half its original size, whereas page.Scale(2) will double the physical
	* dimensions of the page and will rescale all page content appropriately.
	*
	* @note Unlike SetUserUnitSize(unit_size) which is only supported in PDF 1.6
	* (i.e. Acrobat 7) and above, page.Scale(sc) supports all PDF versions.
	*/
		PDFNet.Page.prototype.scale = function(scale)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'scale'. Expected "+1+" argument. Function Signature: scale(number)")};
		if(scale instanceof Promise) {throw new TypeError("1st input argument in function 'scale' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof scale != "number") {throw new TypeError("1st input argument '"+scale+"' in function 'scale' is of type '"+(typeof scale)+"'. Expected type 'number'. Function Signature: scale(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.scale', {"page": this.id, "scale": scale}, this.userPriority);
	},

	/**
	* Flatten/Merge existing form field appearances with the page content and
	* remove widget annotation.
	*
	* Form 'flattening' refers to the operation that changes active form fields
	* into a static area that is part of the PDF document, just like the other
	* text and images in the document. A completely flattened PDF form does not
	* have any widget annotations or interactive fields.
	*
	* @note An alternative approach to set the field as read only is using
	* Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
	* the result of FlattenField() operation can not be programatically reversed.
	*/
		PDFNet.Page.prototype.flattenField = function(filed)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'flattenField'. Expected "+1+" argument. Function Signature: flattenField(Field)")};
		if(filed instanceof Promise) {throw new TypeError("1st input argument in function 'flattenField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filed instanceof PDFNet.Field) && filed.name != "Field") {
			if(typeof filed == "object") {throw new TypeError("1st input argument in function 'flattenField' is of type '"+filed.name+"'. Expected type 'Field'. Function Signature: flattenField(Field).");}
			else {throw new TypeError("1st input argument '"+filed+"' in function 'flattenField' is of type '"+(typeof filed)+"'. Expected type 'Field'. Function Signature: flattenField(Field).");}
		}
		if(typeof filed.yieldFunction != "undefined") {throw new Error("Function '"+filed.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'flattenField'. Perhaps a yield statement is required for '"+filed.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Page.flattenField"; // TRN_Field* filed
		return PDFNet.messageHandler.sendWithPromise('Page.flattenField', {"page": this.id, "filed": filed}, this.userPriority).then(function(id){
			copyFunc(id.filed, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* tests whether this page has a transition.
	*/
		PDFNet.Page.prototype.hasTransition = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasTransition'. Expected "+0+" arguments. Function Signature: hasTransition()")};
		return PDFNet.messageHandler.sendWithPromise('Page.hasTransition', {"page": this.id}, this.userPriority);
	},

	/**
	* Returns the UserUnit value for the page. A UserUnit is a positive number giving
	* the size of default user space units, in multiples of 1/72 inch.
	*
	* @return A promise that resolves to the UserUnit value for the page. If the key is not present in the
	* page dictionary the default of 1.0 is returned.
	*/
		PDFNet.Page.prototype.getUserUnitSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUserUnitSize'. Expected "+0+" arguments. Function Signature: getUserUnitSize()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getUserUnitSize', {"page": this.id}, this.userPriority);
	},

	/**
	* Sets the UserUnit value for a page.
	*
	* @param unit_size A positive number giving the size of default user space
	* units, in multiples of 1/72 inch.
	*
	* @note This is a PDF 1.6 feature. See the implementation note 171 in
	* PDF Reference for details.
	*/
		PDFNet.Page.prototype.setUserUnitSize = function(unit_size)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUserUnitSize'. Expected "+1+" argument. Function Signature: setUserUnitSize(number)")};
		if(unit_size instanceof Promise) {throw new TypeError("1st input argument in function 'setUserUnitSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof unit_size != "number") {throw new TypeError("1st input argument '"+unit_size+"' in function 'setUserUnitSize' is of type '"+(typeof unit_size)+"'. Expected type 'number'. Function Signature: setUserUnitSize(number).");}
		return PDFNet.messageHandler.sendWithPromise('Page.setUserUnitSize', {"page": this.id, "unit_size": unit_size}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a pointer to the page resource dictionary.
	* @exception if the page is missing resource dictionary the function throws Exception
	*/
		PDFNet.Page.prototype.getResourceDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getResourceDict'. Expected "+0+" arguments. Function Signature: getResourceDict()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getResourceDict', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to nULL if page is empty, otherwise a single stream or an array of streams.
	*/
		PDFNet.Page.prototype.getContents = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContents'. Expected "+0+" arguments. Function Signature: getContents()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getContents', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to object representing the Image thumbnail.
	*/
		PDFNet.Page.prototype.getThumb = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getThumb'. Expected "+0+" arguments. Function Signature: getThumb()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getThumb', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Returns the page dictionary.
	*
	* @return A promise that resolves to the object to the underlying SDF/Cos object.
	*/
		PDFNet.Page.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Page.getSDFObj', {"page": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Some of the page attributes are designated as inheritable.
	* If such an attribute is omitted from a page object, its value is inherited
	* from an ancestor node in the page tree. If the attribute is a required one,
	* a value must be supplied in an ancestor node; if it is optional and no
	* inherited value is specified, the default value should be used.
	*
	* The function walks up the page inheritance tree in search for specified
	* attribute.
	*
	* @return A promise that resolves to if the attribute was found return a pointer to the value. Otherwise
	* the function return NULL.
	*
	*	Resources dictionary (Required; inheritable)
	*  MediaBox rectangle (Required; inheritable)
	*  CropBox rectangle (Optional; inheritable)
	*  Rotate integer (Optional; inheritable)
	*/
		PDFNet.Page.prototype.findInheritedAttribute = function(attrib)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'findInheritedAttribute'. Expected "+1+" argument. Function Signature: findInheritedAttribute(string)")};
		if(attrib instanceof Promise) {throw new TypeError("1st input argument in function 'findInheritedAttribute' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof attrib != "string") {throw new TypeError("1st input argument '"+attrib+"' in function 'findInheritedAttribute' is of type '"+(typeof attrib)+"'. Expected type 'string'. Function Signature: findInheritedAttribute(string).");}
		return PDFNet.messageHandler.sendWithPromise('Page.findInheritedAttribute', {"page": this.id, "attrib": attrib}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Creates a new annotation of a given type, in the specified document.
	* The newly created annotation does not contain any properties specific
	* to a given annotation type, which means an invalid annotation object could be created.
	* It is therefore recommended to always create an annotation using type specific methods,
	* such as Annots::Line::Create() or Annots::FileAttachment::Create().
	* Users should only call Annot::Create() to create annotations of non-standard types
	* that are not recognized by PDFTron software (by using Annot::e_Unknown as a type).
	*
	* @param doc A document to which the annotation is added.
	* @param type Subtype of annotation to create.
	* @param pos A rectangle specifying the annotation's bounds, specified in
	* user space coordinates.
	*
	* @return A promise that resolves to a newly created blank annotation for the given annotation type.
	*/
		PDFNet.Annot.create = function(doc, type, pos)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+3+" arguments. Function Signature: create(SDFDoc, number, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number, Rect).");}
		}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'create' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: create(SDFDoc, number, Rect).");}
		if(pos instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("3rd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, number, Rect).");}
			else {throw new TypeError("3rd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, number, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('annotCreate', {"doc": doc.id, "type": type, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

	/**
	* Create an annotation and initialize it using given Cos/SDF object.
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.Annot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('annotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

		PDFNet.Annot.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.copy', {"d": this.id}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

		PDFNet.Annot.prototype.compare = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(Annot)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Annot)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+d.name+"'. Expected type 'Annot'. Function Signature: compare(Annot).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'compare' is of type '"+(typeof d)+"'. Expected type 'Annot'. Function Signature: compare(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Annot.compare', {"annot": this.id, "d": d.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a valid (non-null) annotation, false otherwise.
	* If the function returns false the underlying SDF/Cos object is null or is
	* not valid and the annotation object should be treated as a null object.
	*/
		PDFNet.Annot.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.isValid', {"annot": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object.
	*/
		PDFNet.Annot.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getSDFObj', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the type of this annotation. Corresponds to the "Subtype" entry of annotation
	* dictionary, as per PDF Reference Manual section 12.5.2
	*/
		PDFNet.Annot.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getType', {"annot": this.id}, this.userPriority);
	},

	/**
	* Return true if this annotation is classified as a markup annotation.
	*
	* @return A promise that resolves to boolean value, true if this annotation is classified as a markup annotation.
	*/
		PDFNet.Annot.prototype.isMarkup = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isMarkup'. Expected "+0+" arguments. Function Signature: isMarkup()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.isMarkup', {"annot": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to annotation's bounding rectangle, specified in user space coordinates.
	*
	* The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
	* annotations, the rectangle specifies the area containing the hyperlink area or stamp.
	* For Note annotations, the rectangle is describing the popup window when it's opened.
	* When it's closed, the icon is positioned at lower left corner.
	*/
		PDFNet.Annot.prototype.getRect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRect'. Expected "+0+" arguments. Function Signature: getRect()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getRect', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* It is possible during viewing that GetRect does not return the most accurate bounding box
	* of what is actually rendered. This method calculates the bounding box, rather than relying
	* on what is specified in the PDF document. The bounding box is defined as the smallest
	* rectangle that includes all the visible content on the annotation.
	*
	* @return A promise that resolves to the bounding box for this annotation. The dimensions are specified in user space
	* coordinates.
	*/
		PDFNet.Annot.prototype.getVisibleContentBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVisibleContentBox'. Expected "+0+" arguments. Function Signature: getVisibleContentBox()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getVisibleContentBox', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* Sets the size and location of an annotation on its page.
	* @param p Annotation's bounding rectangle, specified in user space coordinates.
	*
	* The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
	* annotations, the rectangle specifies the area containing the hyperlink area or stamp.
	* For Note annotations, the rectangle is describing the popup window when it's opened.
	* When it's closed, the icon is positioned at lower left corner.
	*/
		PDFNet.Annot.prototype.setRect = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRect'. Expected "+1+" argument. Function Signature: setRect(Rect)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'setRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("1st input argument in function 'setRect' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: setRect(Rect).");}
			else {throw new TypeError("1st input argument '"+pos+"' in function 'setRect' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: setRect(Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setRect'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setRect', {"annot": this.id, "pos": pos}, this.userPriority);
	},

	/**
	* Scales the geometry of the annotation so that its appearance would now fit a new
	* rectangle on the page, in user units. Users still have to call RefreshAppearance() later
	* if they want a corresponding appearance stream to be generated for the new rectangle.
	* The main reason for not combining the two operations together is to be able to resize
	* annotations that do not have an appearance stream.
	*
	* @param newrect A reference to the new rectangle to which this annotation has to be resized.
	*/
		PDFNet.Annot.prototype.resize = function(rect)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'resize'. Expected "+1+" argument. Function Signature: resize(Rect)")};
		if(rect instanceof Promise) {throw new TypeError("1st input argument in function 'resize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(rect instanceof PDFNet.Rect) && rect.name != "Rect") {
			if(typeof rect == "object") {throw new TypeError("1st input argument in function 'resize' is of type '"+rect.name+"'. Expected type 'Rect'. Function Signature: resize(Rect).");}
			else {throw new TypeError("1st input argument '"+rect+"' in function 'resize' is of type '"+(typeof rect)+"'. Expected type 'Rect'. Function Signature: resize(Rect).");}
		}
		if(typeof rect.yieldFunction != "undefined") {throw new Error("Function '"+rect.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'resize'. Perhaps a yield statement is required for '"+rect.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Annot.resize', {"annot": this.id, "rect": rect}, this.userPriority);
	},

	/**
	* Sets the content of this annotation. (Optional).
	*
	* @param contents A reference to unicode string object with the text that will be associated with
	* this annotation. This is the text that annotation displays on user interaction, if the annotation
	* type supports it.
	*/
		PDFNet.Annot.prototype.setContents = function(cont)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setContents'. Expected "+1+" argument. Function Signature: setContents(string)")};
		if(cont instanceof Promise) {throw new TypeError("1st input argument in function 'setContents' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cont != "string") {throw new TypeError("1st input argument '"+cont+"' in function 'setContents' is of type '"+(typeof cont)+"'. Expected type 'string'. Function Signature: setContents(string).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setContents', {"annot": this.id, "cont": cont}, this.userPriority);
	},

	/**
	* Extract the content of this annotation. (Optional).
	*
	* @return A promise that resolves to  A unicode string object with the text that is associated with
	* this annotation. This is the text that annotation displays on user interaction,
	* if the annotation type supports it.
	*/
		PDFNet.Annot.prototype.getContents = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContents'. Expected "+0+" arguments. Function Signature: getContents()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getContents', {"annot": this.id}, this.userPriority);
	},

	/**
	* Gets the page the annotation is associated with.
	*
	* @return A promise that resolves to a Page object or null page object if the page reference is not available.
	* The page object returned is an indirect reference to the page object with which
	* this annotation is associated.
	* This entry shall be present in screen annotations associated with rendition actions.
	*
	* Optional. PDF 1.3 PDF 1.4 PDF 1.5 not used in FDF files.
	*/
		PDFNet.Annot.prototype.getPage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPage'. Expected "+0+" arguments. Function Signature: getPage()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getPage', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

	/**
	* sets the reference to a page the annotation is associated with.
	* (Optional PDF 1.3; not used in FDF files)
	*
	* @param Page The page object user wants the annotation to be associated with.
	*
	* @note The parameter should be an indirect reference to the page object with
	* which this annotation is associated. This entry shall be present in screen
	* annotations associated with rendition actions
	*/
		PDFNet.Annot.prototype.setPage = function(pg)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPage'. Expected "+1+" argument. Function Signature: setPage(Page)")};
		if(pg instanceof Promise) {throw new TypeError("1st input argument in function 'setPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pg instanceof PDFNet.Page)) {
			if(typeof pg == "object") {throw new TypeError("1st input argument in function 'setPage' is of type '"+pg.name+"'. Expected type 'Page'. Function Signature: setPage(Page).");}
			else {throw new TypeError("1st input argument '"+pg+"' in function 'setPage' is of type '"+(typeof pg)+"'. Expected type 'Page'. Function Signature: setPage(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Annot.setPage', {"annot": this.id, "pg": pg.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the unique identifier for this annotation, or NULL if the identifier is not
	* available. The returned value is a String object and is the value of the "NM"
	* field, which was added as an optional attribute in PDF 1.4.
	*/
		PDFNet.Annot.prototype.getUniqueID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUniqueID'. Expected "+0+" arguments. Function Signature: getUniqueID()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getUniqueID', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Gets an annotation's last modified date.
	* @return A promise that resolves to the annotation's last modified time and date. If the annotation has no associated
	* date structure, the returned date is not valid (date.IsValid() returns false). Corresponds
	* to the "M" entry of the annotation dictionary.
	*/
		PDFNet.Annot.prototype.getDate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDate'. Expected "+0+" arguments. Function Signature: getDate()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getDate', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Date
			if(id == "0"){
				return null;
			}
			return new PDFNet.Date(id);
		});
	},

	/**
	* Sets an annotation's last modified date.
	* @param The annotation's last modified time and date. Corresponds to the "M" entry of the
	* annotation dictionary.
	*/
		PDFNet.Annot.prototype.setDate = function(date)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDate'. Expected "+1+" argument. Function Signature: setDate(Date)")};
		if(date instanceof Promise) {throw new TypeError("1st input argument in function 'setDate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(date instanceof PDFNet.Date) && date.name != "Date") {
			if(typeof date == "object") {throw new TypeError("1st input argument in function 'setDate' is of type '"+date.name+"'. Expected type 'Date'. Function Signature: setDate(Date).");}
			else {throw new TypeError("1st input argument '"+date+"' in function 'setDate' is of type '"+(typeof date)+"'. Expected type 'Date'. Function Signature: setDate(Date).");}
		}
		if(typeof date.yieldFunction != "undefined") {throw new Error("Function '"+date.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setDate'. Perhaps a yield statement is required for '"+date.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setDate', {"annot": this.id, "date": date}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the value of given Flag
	* @param flag The Flag property to query.
	*/
		PDFNet.Annot.prototype.getFlag = function(flag)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFlag'. Expected "+1+" argument. Function Signature: getFlag(number)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'getFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'getFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: getFlag(number).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.getFlag', {"annot": this.id, "flag": flag}, this.userPriority);
	},

	/**
	* sets the value of given Flag.
	*
	* @param flag The Flag property to modify.
	* @param value The new value for the property.
	*/
		PDFNet.Annot.prototype.setFlag = function(flag, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setFlag'. Expected "+2+" arguments. Function Signature: setFlag(number, boolean)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'setFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'setFlag' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: setFlag(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'setFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'setFlag' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: setFlag(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setFlag', {"annot": this.id, "flag": flag, "value": value}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.create = function(s, b_width, b_hr, b_vr)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+4+" arguments. Function Signature: create(number, number, number, number)")};
		if(s instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof s != "number") {throw new TypeError("1st input argument '"+s+"' in function 'create' is of type '"+(typeof s)+"'. Expected type 'number'. Function Signature: create(number, number, number, number).");}
		if(b_width instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_width != "number") {throw new TypeError("2nd input argument '"+b_width+"' in function 'create' is of type '"+(typeof b_width)+"'. Expected type 'number'. Function Signature: create(number, number, number, number).");}
		if(b_hr instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_hr != "number") {throw new TypeError("3rd input argument '"+b_hr+"' in function 'create' is of type '"+(typeof b_hr)+"'. Expected type 'number'. Function Signature: create(number, number, number, number).");}
		if(b_vr instanceof Promise) {throw new TypeError("4th input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_vr != "number") {throw new TypeError("4th input argument '"+b_vr+"' in function 'create' is of type '"+(typeof b_vr)+"'. Expected type 'number'. Function Signature: create(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('annotBorderStyleCreate', {"s": s, "b_width": b_width, "b_hr": b_hr, "b_vr": b_vr}, this.userPriority).then(function(id){
			//there is a return type AnnotBorderStyle
			if(id == "0"){
				return null;
			}
			return new PDFNet.AnnotBorderStyle(id);
		});
	},

		PDFNet.AnnotBorderStyle.createWithDashPattern = function(s, b_width, b_hr, b_vr, buffer)
	{
		if(arguments.length != 5) {throw new RangeError(arguments.length+" arguments passed into function 'createWithDashPattern'. Expected "+5+" arguments. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer)")};
		if(s instanceof Promise) {throw new TypeError("1st input argument in function 'createWithDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof s != "number") {throw new TypeError("1st input argument '"+s+"' in function 'createWithDashPattern' is of type '"+(typeof s)+"'. Expected type 'number'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
		if(b_width instanceof Promise) {throw new TypeError("2nd input argument in function 'createWithDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_width != "number") {throw new TypeError("2nd input argument '"+b_width+"' in function 'createWithDashPattern' is of type '"+(typeof b_width)+"'. Expected type 'number'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
		if(b_hr instanceof Promise) {throw new TypeError("3rd input argument in function 'createWithDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_hr != "number") {throw new TypeError("3rd input argument '"+b_hr+"' in function 'createWithDashPattern' is of type '"+(typeof b_hr)+"'. Expected type 'number'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
		if(b_vr instanceof Promise) {throw new TypeError("4th input argument in function 'createWithDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b_vr != "number") {throw new TypeError("4th input argument '"+b_vr+"' in function 'createWithDashPattern' is of type '"+(typeof b_vr)+"'. Expected type 'number'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
		if(buffer instanceof Promise) {throw new TypeError("5th input argument in function 'createWithDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buffer.buffer instanceof ArrayBuffer)) {
			if(typeof buffer == "object") {throw new TypeError("5th input argument in function 'createWithDashPattern' is of type '"+buffer.name+"'. Expected type 'ArrayBuffer'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
			else {throw new TypeError("5th input argument '"+buffer+"' in function 'createWithDashPattern' is of type '"+(typeof buffer)+"'. Expected type 'ArrayBuffer'. Function Signature: createWithDashPattern(number, number, number, number, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('annotBorderStyleCreateWithDashPattern', {"s": s, "b_width": b_width, "b_hr": b_hr, "b_vr": b_vr, "buffer": buffer.buffer}, this.userPriority).then(function(id){
			//there is a return type AnnotBorderStyle
			if(id == "0"){
				return null;
			}
			return new PDFNet.AnnotBorderStyle(id);
		});
	},

		PDFNet.AnnotBorderStyle.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.copy', {"bs": this.id}, this.userPriority).then(function(id){
			//there is a return type AnnotBorderStyle
			if(id == "0"){
				return null;
			}
			return new PDFNet.AnnotBorderStyle(id);
		});
	},

		PDFNet.AnnotBorderStyle.prototype.getStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStyle'. Expected "+0+" arguments. Function Signature: getStyle()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.getStyle', {"bs": this.id}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.setStyle = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStyle'. Expected "+1+" argument. Function Signature: setStyle(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setStyle' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.setStyle', {"bs": this.id, "style": style}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.destroy', {"bs": this.id}, this.userPriority);
	},

	/**
	* Gets the annotation's appearance for the given combination of annotation
	* and appearance states.
	*
	* @param annot_state the annotation's appearance state, which selects the applicable
	* appearance stream from the appearance sub-dictionary. An annotation can define as many
	* as three separate appearances: The normal, rollover, and down appearance.
	* @param app_state is an optional parameter specifying the appearance state
	* to look for (e.g. "Off", "On", etc). If appearance_state is NULL, the choice
	* between different appearance states is determined by the AS (Appearance State)
	* entry in the annotation dictionary.
	*
	* @return A promise that resolves to the appearance stream for this annotation, or NULL if the annotation
	* does not have an appearance for the given combination of annotation and
	* appearance states.
	*/
		PDFNet.Annot.prototype.getAppearance = function(annot_state, app_state)
	{
		if(typeof annot_state === "undefined") {annot_state = exports.PDFNet.Annot.State.e_normal};
		if(typeof app_state === "undefined") {app_state = 0;};
		if(arguments.length > 2) {throw new RangeError(arguments.length+" arguments passed into function 'getAppearance'. Expected at most "+2+" arguments. Function Signature: getAppearance(number, string)")};
		if(annot_state instanceof Promise) {throw new TypeError("1st input argument in function 'getAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof annot_state != "number") {throw new TypeError("1st input argument '"+annot_state+"' in function 'getAppearance' is of type '"+(typeof annot_state)+"'. Expected type 'number'. Function Signature: getAppearance(number, string).");}
		if(app_state instanceof Promise) {throw new TypeError("2nd input argument in function 'getAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof app_state != "string") {throw new TypeError("2nd input argument '"+app_state+"' in function 'getAppearance' is of type '"+(typeof app_state)+"'. Expected type 'string'. Function Signature: getAppearance(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.getAppearance', {"annot": this.id, "annot_state": annot_state, "app_state": app_state}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Sets the annotation's appearance for the given combination of annotation
	* and appearance states.
	* (Optional; PDF 1.2)
	*
	* @param app_stream a content stream defining the new appearance.
	*
	* @param annot_state the annotation's appearance state, which selects the applicable
	* appearance stream from the appearance sub-dictionary. An annotation can define as many
	* as three separate appearances: The normal, rollover, and down appearance.
	*
	* @param app_state is an optional parameter specifying the appearance state
	* (e.g. "Off", "On", etc) under which the new appearance should be stored. If
	* appearance_state is NULL, the annotation will have only one annotation state.
	*/
		PDFNet.Annot.prototype.setAppearance = function(app_stream, annot_state, app_state)
	{
		if(typeof annot_state === "undefined") {annot_state = exports.PDFNet.Annot.State.e_normal};
		if(typeof app_state === "undefined") {app_state = 0;};
		if((arguments.length < 1) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'setAppearance'. Expected "+1+" to "+3+" arguments. Function Signature: setAppearance(Obj, number, string)")};
		if(app_stream instanceof Promise) {throw new TypeError("1st input argument in function 'setAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(app_stream instanceof PDFNet.Obj)) {
			if(typeof app_stream == "object") {throw new TypeError("1st input argument in function 'setAppearance' is of type '"+app_stream.name+"'. Expected type 'Obj'. Function Signature: setAppearance(Obj, number, string).");}
			else {throw new TypeError("1st input argument '"+app_stream+"' in function 'setAppearance' is of type '"+(typeof app_stream)+"'. Expected type 'Obj'. Function Signature: setAppearance(Obj, number, string).");}
		}
		if(annot_state instanceof Promise) {throw new TypeError("2nd input argument in function 'setAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof annot_state != "number") {throw new TypeError("2nd input argument '"+annot_state+"' in function 'setAppearance' is of type '"+(typeof annot_state)+"'. Expected type 'number'. Function Signature: setAppearance(Obj, number, string).");}
		if(app_state instanceof Promise) {throw new TypeError("3rd input argument in function 'setAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof app_state != "string") {throw new TypeError("3rd input argument '"+app_state+"' in function 'setAppearance' is of type '"+(typeof app_state)+"'. Expected type 'string'. Function Signature: setAppearance(Obj, number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setAppearance', {"annot": this.id, "app_stream": app_stream.id, "annot_state": annot_state, "app_state": app_state}, this.userPriority);
	},

	/**
	* Removes the annotation's appearance for the given combination of annotation
	* and appearance states.
	*
	* @param annot_state the annotation's appearance state, which selects the applicable
	* appearance stream from the appearance sub-dictionary. An annotation can define as many
	* as three separate appearances: The normal, rollover, and down appearance.
	*
	* @param app_state is an optional parameter specifying the appearance state
	* (e.g. "Off", "On", etc) under which the new appearance should be stored. If
	* appearance_state is NULL, the annotation will have only one annotation state.
	*/
		PDFNet.Annot.prototype.removeAppearance = function(annot_state, app_state)
	{
		if(typeof annot_state === "undefined") {annot_state = exports.PDFNet.Annot.State.e_normal};
		if(typeof app_state === "undefined") {app_state = 0;};
		if(arguments.length > 2) {throw new RangeError(arguments.length+" arguments passed into function 'removeAppearance'. Expected at most "+2+" arguments. Function Signature: removeAppearance(number, string)")};
		if(annot_state instanceof Promise) {throw new TypeError("1st input argument in function 'removeAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof annot_state != "number") {throw new TypeError("1st input argument '"+annot_state+"' in function 'removeAppearance' is of type '"+(typeof annot_state)+"'. Expected type 'number'. Function Signature: removeAppearance(number, string).");}
		if(app_state instanceof Promise) {throw new TypeError("2nd input argument in function 'removeAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof app_state != "string") {throw new TypeError("2nd input argument '"+app_state+"' in function 'removeAppearance' is of type '"+(typeof app_state)+"'. Expected type 'string'. Function Signature: removeAppearance(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.removeAppearance', {"annot": this.id, "annot_state": annot_state, "app_state": app_state}, this.userPriority);
	},

	/**
	* Flatten/Merge the existing annotation appearances with the page content and
	* delete this annotation from a given page.
	*
	* Annotation 'flattening' refers to the operation that changes active annotations
	* (such as markup, widgets, 3D models, etc.) into a static area that is part of the
	* PDF document, just like the other text and images in the document.
	*
	* @note an alternative approach to set the annotation as read only is using
	* Annot.SetFlag(Annot::e_read_only, true) method. Unlike Annot.SetFlag(...),
	* the result of Flatten() operation can not be programatically reversed.
	*/
		PDFNet.Annot.prototype.flatten = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'flatten'. Expected "+1+" argument. Function Signature: flatten(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'flatten' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'flatten' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: flatten(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'flatten' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: flatten(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Annot.flatten', {"annot": this.id, "page": page.id}, this.userPriority);
	},

	/**
	* Gets the annotation's active appearance state.
	*
	* @return A promise that resolves to the name of the active state.
	* The annotation's appearance state, which
	* selects the applicable appearance stream from an appearance subdictionary.
	*/
		PDFNet.Annot.prototype.getActiveAppearanceState = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getActiveAppearanceState'. Expected "+0+" arguments. Function Signature: getActiveAppearanceState()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getActiveAppearanceState', {"annot": this.id}, this.userPriority);
	},

	/**
	* Sets the annotation's active appearance state.
	* (Required if the appearance dictionary AP contains one or more subdictionaries; PDF 1.2)
	*
	* @param: astate Character string representing the name of the active appearance state.
	* The string used to select the annotation's appearance state, which
	* selects the applicable appearance stream from an appearance subdictionary.
	*/
		PDFNet.Annot.prototype.setActiveAppearanceState = function(astate)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setActiveAppearanceState'. Expected "+1+" argument. Function Signature: setActiveAppearanceState(string)")};
		if(astate instanceof Promise) {throw new TypeError("1st input argument in function 'setActiveAppearanceState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof astate != "string") {throw new TypeError("1st input argument '"+astate+"' in function 'setActiveAppearanceState' is of type '"+(typeof astate)+"'. Expected type 'string'. Function Signature: setActiveAppearanceState(string).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setActiveAppearanceState', {"annot": this.id, "astate": astate}, this.userPriority);
	},

		PDFNet.Annot.prototype.getColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColor'. Expected "+0+" arguments. Function Signature: getColor()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getColor', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* Gets an annotation's color in RGB color space.
	*
	* @return A promise that resolves to a ColorPt object containing an array of three numbers in the range 0.0 to 1.0,
	* representing an RGB colour used for the following purposes:
	*   - The background of the annotation's icon when closed
	*   - The title bar of the annotation's pop-up window
	*   - The border of a link annotation
	*
	*  If the annotation does not specify an explicit color, a default color is returned.
	*  Text annotations return 'default yellow;' all others return black.
	*/
		PDFNet.Annot.prototype.getColorAsRGB = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColorAsRGB'. Expected "+0+" arguments. Function Signature: getColorAsRGB()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getColorAsRGB', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* Returns the annotation's color in CMYK color space.
	*
	* @return A promise that resolves to a ColorPt object containing an array of four numbers in the range 0.0 to 1.0,
	* representing a CMYK color used for the following purposes:
	*   - The background of the annotation's icon when closed
	*   - The title bar of the annotation's pop-up window
	*   - The border of a link annotation
	*
	* If the annotation does not specify an explicit color, a default color is returned.
	* Text annotations return 'default yellow;' all others return black.
	*/
		PDFNet.Annot.prototype.getColorAsCMYK = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColorAsCMYK'. Expected "+0+" arguments. Function Signature: getColorAsCMYK()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getColorAsCMYK', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* Returns the annotation's color in Gray color space.
	*
	* @return A promise that resolves to a ColorPt object containing a number in the range 0.0 to 1.0,
	* representing a Gray Scale color used for the following purposes:
	* The background of the annotation's icon when closed
	* The title bar of the annotation's pop-up window
	* The border of a link annotation
	* If the annotation does not specify an explicit color, black color is returned.
	*/
		PDFNet.Annot.prototype.getColorAsGray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColorAsGray'. Expected "+0+" arguments. Function Signature: getColorAsGray()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getColorAsGray', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* Returns the color space the annotation's color is represented in.
	*
	* @return A promise that resolves to an integer that is either 1(for DeviceGray), 3(DeviceRGB), or 4(DeviceCMYK).
	* If the annotation has no color, i.e. is transparent, 0 will be returned.
	*/
		PDFNet.Annot.prototype.getColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColorCompNum'. Expected "+0+" arguments. Function Signature: getColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getColorCompNum', {"annot": this.id}, this.userPriority);
	},

		PDFNet.Annot.prototype.setColorDefault = function(col)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setColorDefault'. Expected "+1+" argument. Function Signature: setColorDefault(ColorPt)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setColorDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setColorDefault' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setColorDefault(ColorPt).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setColorDefault' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setColorDefault(ColorPt).");}
		}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setColorDefault'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setColorDefault', {"annot": this.id, "col": col.id}, this.userPriority);
	},

	/**
	* Sets an annotation's color.
	* (Optional; PDF 1.1)
	*
	* @param c A ColorPt object in RGB or Gray or CMYK color space representing the annotation's color.
	* The ColorPt contains an array of numbers in the range 0.0 to 1.0, representing a color used for the following purposes:
	*    The background of the annotation's icon when closed
	*     The title bar of the annotation's pop-up window
	*     The border of a link annotation
	*
	* The number of array elements determines the color space in which the color shall be defined:
	* 0 No color; transparent
	* 1 DeviceGray
	* 3 DeviceRGB
	* 4 DeviceCMYK
	*
	* @param comp_num - The number of color components used to represent the color (i.e. 1, 3, 4).
	*/
		PDFNet.Annot.prototype.setColor = function(col, numcomp)
	{
		if(typeof numcomp === "undefined") {numcomp = 3;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'setColor'. Expected "+1+" to "+2+" arguments. Function Signature: setColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setColor', {"annot": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

	/**
	* Returns the struct parent of an annotation.
	* (Required if the annotation is a structural content item; PDF 1.3)
	*
	* @return A promise that resolves to an integer which is the integer key of the annotation's entry
	* in the structural parent tree.
	* @note The StructParent is the integer key of the annotation's entry
	* in the structural parent tree.
	*
	*/
		PDFNet.Annot.prototype.getStructParent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStructParent'. Expected "+0+" arguments. Function Signature: getStructParent()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getStructParent', {"annot": this.id}, this.userPriority);
	},

	/**
	* sets the struct parent of an annotation.
	* (Required if the annotation is a structural content item; PDF 1.3)
	*
	* @param keyval An integer which is the integer key of the
	* annotation's entry in the structural parent tree.
	* @note The StructParent is the integer key of the annotation's entry
	* in the structural parent tree.
	*
	*/
		PDFNet.Annot.prototype.setStructParent = function(pakeyval)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStructParent'. Expected "+1+" argument. Function Signature: setStructParent(number)")};
		if(pakeyval instanceof Promise) {throw new TypeError("1st input argument in function 'setStructParent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pakeyval != "number") {throw new TypeError("1st input argument '"+pakeyval+"' in function 'setStructParent' is of type '"+(typeof pakeyval)+"'. Expected type 'number'. Function Signature: setStructParent(number).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setStructParent', {"annot": this.id, "pakeyval": pakeyval}, this.userPriority);
	},

	/**
	* Returns optional content associated with this annotation.
	*
	* @return A promise that resolves to a SDF object corresponding to the group of optional properties.
	* @note The return value is an Optional Content Group (OCG) or Optional Content Membership
	* Dictionary (PDF::OCG::OCMD) specifying the optional content properties for the annotation.
	* Before the annotation is drawn, its visibility shall be determined based on this entry
	* as well as the annotation flags specified in the Flag entry. If it is determined to be
	* invisible, the annotation shall be skipped, as if it were not in the document.
	*/
		PDFNet.Annot.prototype.getOptionalContent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOptionalContent'. Expected "+0+" arguments. Function Signature: getOptionalContent()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getOptionalContent', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Associates optional content with this annotation. (Optional, PDF1.5).
	*
	* @param oc A pointer to an SDF object corresponding to the optional content,
	* a PDF::OCG::Group or membership dictionary specifying the PDF::OCG::Group properties for
	* the annotation. Before the annotation is drawn, its visibility
	* shall be determined based on this entry as well as the annotation
	* flags specified in the Flag entry . If it is determined to be invisible,
	* the annotation shall be skipped, as if it were not in the document.
	*/
		PDFNet.Annot.prototype.setOptionalContent = function(content)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOptionalContent'. Expected "+1+" argument. Function Signature: setOptionalContent(Obj)")};
		if(content instanceof Promise) {throw new TypeError("1st input argument in function 'setOptionalContent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(content instanceof PDFNet.Obj)) {
			if(typeof content == "object") {throw new TypeError("1st input argument in function 'setOptionalContent' is of type '"+content.name+"'. Expected type 'Obj'. Function Signature: setOptionalContent(Obj).");}
			else {throw new TypeError("1st input argument '"+content+"' in function 'setOptionalContent' is of type '"+(typeof content)+"'. Expected type 'Obj'. Function Signature: setOptionalContent(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Annot.setOptionalContent', {"annot": this.id, "content": content.id}, this.userPriority);
	},

	/**
	* Regenerates the appearance stream for the annotation.
	* This method can be used to auto-generate the annotation appearance after creating
	* or modifying the annotation without providing an explicit appearance or
	* setting the "NeedAppearances" flag in the AcroForm dictionary.
	*
	* @note If this annotation contains text, and has been added to a rotated page, the text in
	* the annotation may be rotated. If RefreshAppearance is called *after* the annotation is added
	* to a rotated page, then any text will be rotated in the opposite direction of the page
	* rotation. If this method is called *before* the annotation is added to any rotated page, then
	* no counter rotation will be applied. If you wish to call RefreshAppearance on an annotation
	* already added to a rotated page, but you don't want the text to be rotated, you can do one
	* of the following; temporarily un-rotate the page, or, temporarily remove the "Rotate" object
	* from the annotation. To support users adding text annotations while using a PDF viewer,
	* you can also add any viewer rotation to the annotations Rotate object, to have text always
	* rotated correctly, from the users perspective.
	*/
		PDFNet.Annot.prototype.refreshAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'refreshAppearance'. Expected "+0+" arguments. Function Signature: refreshAppearance()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.refreshAppearance', {"annot": this.id}, this.userPriority);
	},

	/**
	* @note The functionality documented below is part of the appearance characteristics dictionary, the dictionary
	* that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
	* presentation on the page.
	*//**
	* Returns the rotation value of the annotation.
	*
	* @return A promise that resolves to an integer representing the rotation value of the annotation.
	* @note The Rotation specifies the number of degrees by which the
	* annotation shall be rotated counterclockwise relative to the page.
	* The value shall be a multiple of 90.
	* Default value: 0.
	*/
		PDFNet.Annot.prototype.getRotation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRotation'. Expected "+0+" arguments. Function Signature: getRotation()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getRotation', {"annot": this.id}, this.userPriority);
	},

	/**
	* Sets the rotation value of the annotation.
	* (Optional)
	*
	* @param rot An integer representing the rotation value of the annotation.
	* @note the Rotation specifies the number of degrees by which the
	* annotation shall be rotated counterclockwise relative to the page.
	* The value shall be a multiple of 90.
	* Default value: 0.
	*/
		PDFNet.Annot.prototype.setRotation = function(angle)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRotation'. Expected "+1+" argument. Function Signature: setRotation(number)")};
		if(angle instanceof Promise) {throw new TypeError("1st input argument in function 'setRotation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof angle != "number") {throw new TypeError("1st input argument '"+angle+"' in function 'setRotation' is of type '"+(typeof angle)+"'. Expected type 'number'. Function Signature: setRotation(number).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setRotation', {"annot": this.id, "angle": angle}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.getWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getWidth'. Expected "+0+" arguments. Function Signature: getWidth()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.getWidth', {"bs": this.id}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.setWidth = function(width)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setWidth'. Expected "+1+" argument. Function Signature: setWidth(number)")};
		if(width instanceof Promise) {throw new TypeError("1st input argument in function 'setWidth' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("1st input argument '"+width+"' in function 'setWidth' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: setWidth(number).");}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.setWidth', {"bs": this.id, "width": width}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.getHR = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHR'. Expected "+0+" arguments. Function Signature: getHR()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.getHR', {"bs": this.id}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.setHR = function(horizontal_radius)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHR'. Expected "+1+" argument. Function Signature: setHR(number)")};
		if(horizontal_radius instanceof Promise) {throw new TypeError("1st input argument in function 'setHR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof horizontal_radius != "number") {throw new TypeError("1st input argument '"+horizontal_radius+"' in function 'setHR' is of type '"+(typeof horizontal_radius)+"'. Expected type 'number'. Function Signature: setHR(number).");}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.setHR', {"bs": this.id, "horizontal_radius": horizontal_radius}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.getVR = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVR'. Expected "+0+" arguments. Function Signature: getVR()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.getVR', {"bs": this.id}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.setVR = function(vertical_radius)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setVR'. Expected "+1+" argument. Function Signature: setVR(number)")};
		if(vertical_radius instanceof Promise) {throw new TypeError("1st input argument in function 'setVR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vertical_radius != "number") {throw new TypeError("1st input argument '"+vertical_radius+"' in function 'setVR' is of type '"+(typeof vertical_radius)+"'. Expected type 'number'. Function Signature: setVR(number).");}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.setVR', {"bs": this.id, "vertical_radius": vertical_radius}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.getDashPattern = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDashPattern'. Expected "+0+" arguments. Function Signature: getDashPattern()")};
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.getDashPattern', {"bs": this.id}, this.userPriority).then(function(id){
			return new Float64Array(id);
		});
	},

	/**
	* Gets the border style for the annotation. Typically used for Link annotations.
	*
	* @return A promise that resolves to annotation's border style.
	*/
		PDFNet.Annot.prototype.getBorderStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderStyle'. Expected "+0+" arguments. Function Signature: getBorderStyle()")};
		return PDFNet.messageHandler.sendWithPromise('Annot.getBorderStyle', {"annot": this.id}, this.userPriority).then(function(id){
			//there is a return type AnnotBorderStyle
			if(id == "0"){
				return null;
			}
			return new PDFNet.AnnotBorderStyle(id);
		});
	},

	/**
	* Sets the border style for the annotation.
	*
	* @param bs New border style for this annotation.
	* @param oldStyleOnly PDF manual specifies two ways to add border information to an annotation object,
	* either through an array named 'Border' (PDF 1.0), or a dictionary called 'BS' (PDF 1.2) the latter
	* taking precedence over the former. However, if you want to create a border with rounded corners, you can only
	* do that using PDF 1.0 Border specification, in which case if you call SetBorderStyle() set the parameter
	* oldStyleOnly to true. This parameter has a default value of false in the API and does not need to be used otherwise.
	*/
		PDFNet.Annot.prototype.setBorderStyle = function(bs, oldStyleOnly)
	{
		if(typeof oldStyleOnly === "undefined") {oldStyleOnly = false;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderStyle'. Expected "+1+" to "+2+" arguments. Function Signature: setBorderStyle(AnnotBorderStyle, boolean)")};
		if(bs instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(bs instanceof PDFNet.AnnotBorderStyle)) {
			if(typeof bs == "object") {throw new TypeError("1st input argument in function 'setBorderStyle' is of type '"+bs.name+"'. Expected type 'AnnotBorderStyle'. Function Signature: setBorderStyle(AnnotBorderStyle, boolean).");}
			else {throw new TypeError("1st input argument '"+bs+"' in function 'setBorderStyle' is of type '"+(typeof bs)+"'. Expected type 'AnnotBorderStyle'. Function Signature: setBorderStyle(AnnotBorderStyle, boolean).");}
		}
		if(oldStyleOnly instanceof Promise) {throw new TypeError("2nd input argument in function 'setBorderStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof oldStyleOnly != "boolean") {throw new TypeError("2nd input argument '"+oldStyleOnly+"' in function 'setBorderStyle' is of type '"+(typeof oldStyleOnly)+"'. Expected type 'boolean'. Function Signature: setBorderStyle(AnnotBorderStyle, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Annot.setBorderStyle', {"annot": this.id, "bs": bs.id, "oldStyleOnly": oldStyleOnly}, this.userPriority);
	},

		PDFNet.Annot.getBorderStyleStyle = function(bs)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderStyleStyle'. Expected "+1+" argument. Function Signature: getBorderStyleStyle(AnnotBorderStyle)")};
		if(bs instanceof Promise) {throw new TypeError("1st input argument in function 'getBorderStyleStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(bs instanceof PDFNet.AnnotBorderStyle)) {
			if(typeof bs == "object") {throw new TypeError("1st input argument in function 'getBorderStyleStyle' is of type '"+bs.name+"'. Expected type 'AnnotBorderStyle'. Function Signature: getBorderStyleStyle(AnnotBorderStyle).");}
			else {throw new TypeError("1st input argument '"+bs+"' in function 'getBorderStyleStyle' is of type '"+(typeof bs)+"'. Expected type 'AnnotBorderStyle'. Function Signature: getBorderStyleStyle(AnnotBorderStyle).");}
		}
		return PDFNet.messageHandler.sendWithPromise('annotGetBorderStyleStyle', {"bs": bs.id}, this.userPriority);
	},

		PDFNet.Annot.setBorderStyleStyle = function(bs, bst)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderStyleStyle'. Expected "+2+" arguments. Function Signature: setBorderStyleStyle(AnnotBorderStyle, number)")};
		if(bs instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderStyleStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(bs instanceof PDFNet.AnnotBorderStyle)) {
			if(typeof bs == "object") {throw new TypeError("1st input argument in function 'setBorderStyleStyle' is of type '"+bs.name+"'. Expected type 'AnnotBorderStyle'. Function Signature: setBorderStyleStyle(AnnotBorderStyle, number).");}
			else {throw new TypeError("1st input argument '"+bs+"' in function 'setBorderStyleStyle' is of type '"+(typeof bs)+"'. Expected type 'AnnotBorderStyle'. Function Signature: setBorderStyleStyle(AnnotBorderStyle, number).");}
		}
		if(bst instanceof Promise) {throw new TypeError("2nd input argument in function 'setBorderStyleStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bst != "number") {throw new TypeError("2nd input argument '"+bst+"' in function 'setBorderStyleStyle' is of type '"+(typeof bst)+"'. Expected type 'number'. Function Signature: setBorderStyleStyle(AnnotBorderStyle, number).");}
		return PDFNet.messageHandler.sendWithPromise('annotSetBorderStyleStyle', {"bs": bs.id, "bst": bst}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.assign = function(to)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(AnnotBorderStyle)")};
		if(to instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(to instanceof PDFNet.AnnotBorderStyle)) {
			if(typeof to == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+to.name+"'. Expected type 'AnnotBorderStyle'. Function Signature: assign(AnnotBorderStyle).");}
			else {throw new TypeError("1st input argument '"+to+"' in function 'assign' is of type '"+(typeof to)+"'. Expected type 'AnnotBorderStyle'. Function Signature: assign(AnnotBorderStyle).");}
		}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.assign', {"from": this.id, "to": to.id}, this.userPriority);
	},

		PDFNet.AnnotBorderStyle.prototype.compare = function(b)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(AnnotBorderStyle)")};
		if(b instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(b instanceof PDFNet.AnnotBorderStyle)) {
			if(typeof b == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+b.name+"'. Expected type 'AnnotBorderStyle'. Function Signature: compare(AnnotBorderStyle).");}
			else {throw new TypeError("1st input argument '"+b+"' in function 'compare' is of type '"+(typeof b)+"'. Expected type 'AnnotBorderStyle'. Function Signature: compare(AnnotBorderStyle).");}
		}
		return PDFNet.messageHandler.sendWithPromise('AnnotBorderStyle.compare', {"a": this.id, "b": b.id}, this.userPriority);
	},

		PDFNet.CaretAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('caretAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type CaretAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CaretAnnot(id);
		});
	},

		PDFNet.CaretAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('caretAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type CaretAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CaretAnnot(id);
		});
	},

		PDFNet.CaretAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('caretAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type CaretAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CaretAnnot(id);
		});
	},

		PDFNet.CaretAnnot.prototype.getSymbol = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSymbol'. Expected "+0+" arguments. Function Signature: getSymbol()")};
		return PDFNet.messageHandler.sendWithPromise('CaretAnnot.getSymbol', {"caret": this.id}, this.userPriority);
	},

		PDFNet.CaretAnnot.prototype.setSymbol = function(content)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSymbol'. Expected "+1+" argument. Function Signature: setSymbol(string)")};
		if(content instanceof Promise) {throw new TypeError("1st input argument in function 'setSymbol' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof content != "string") {throw new TypeError("1st input argument '"+content+"' in function 'setSymbol' is of type '"+(typeof content)+"'. Expected type 'string'. Function Signature: setSymbol(string).");}
		return PDFNet.messageHandler.sendWithPromise('CaretAnnot.setSymbol', {"caret": this.id, "content": content}, this.userPriority);
	},

		PDFNet.LineAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('lineAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type LineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LineAnnot(id);
		});
	},

		PDFNet.LineAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('lineAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type LineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LineAnnot(id);
		});
	},

		PDFNet.LineAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('lineAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type LineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LineAnnot(id);
		});
	},

		PDFNet.LineAnnot.prototype.getStartPoint = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStartPoint'. Expected "+0+" arguments. Function Signature: getStartPoint()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getStartPoint', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setStartPoint = function(stp)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStartPoint'. Expected "+1+" argument. Function Signature: setStartPoint(Point)")};
		if(stp instanceof Promise) {throw new TypeError("1st input argument in function 'setStartPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stp instanceof PDFNet.Point) && stp.name != "Point") {
			if(typeof stp == "object") {throw new TypeError("1st input argument in function 'setStartPoint' is of type '"+stp.name+"'. Expected type 'Point'. Function Signature: setStartPoint(Point).");}
			else {throw new TypeError("1st input argument '"+stp+"' in function 'setStartPoint' is of type '"+(typeof stp)+"'. Expected type 'Point'. Function Signature: setStartPoint(Point).");}
		}
		if(typeof stp.yieldFunction != "undefined") {throw new Error("Function '"+stp.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setStartPoint'. Perhaps a yield statement is required for '"+stp.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setStartPoint', {"line": this.id, "stp": stp}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getEndPoint = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEndPoint'. Expected "+0+" arguments. Function Signature: getEndPoint()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getEndPoint', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setEndPoint = function(etp)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEndPoint'. Expected "+1+" argument. Function Signature: setEndPoint(Point)")};
		if(etp instanceof Promise) {throw new TypeError("1st input argument in function 'setEndPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(etp instanceof PDFNet.Point) && etp.name != "Point") {
			if(typeof etp == "object") {throw new TypeError("1st input argument in function 'setEndPoint' is of type '"+etp.name+"'. Expected type 'Point'. Function Signature: setEndPoint(Point).");}
			else {throw new TypeError("1st input argument '"+etp+"' in function 'setEndPoint' is of type '"+(typeof etp)+"'. Expected type 'Point'. Function Signature: setEndPoint(Point).");}
		}
		if(typeof etp.yieldFunction != "undefined") {throw new Error("Function '"+etp.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setEndPoint'. Perhaps a yield statement is required for '"+etp.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setEndPoint', {"line": this.id, "etp": etp}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getStartStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStartStyle'. Expected "+0+" arguments. Function Signature: getStartStyle()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getStartStyle', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setStartStyle = function(ss)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStartStyle'. Expected "+1+" argument. Function Signature: setStartStyle(number)")};
		if(ss instanceof Promise) {throw new TypeError("1st input argument in function 'setStartStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ss != "number") {throw new TypeError("1st input argument '"+ss+"' in function 'setStartStyle' is of type '"+(typeof ss)+"'. Expected type 'number'. Function Signature: setStartStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setStartStyle', {"line": this.id, "ss": ss}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getEndStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEndStyle'. Expected "+0+" arguments. Function Signature: getEndStyle()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getEndStyle', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setEndStyle = function(es)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEndStyle'. Expected "+1+" argument. Function Signature: setEndStyle(number)")};
		if(es instanceof Promise) {throw new TypeError("1st input argument in function 'setEndStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof es != "number") {throw new TypeError("1st input argument '"+es+"' in function 'setEndStyle' is of type '"+(typeof es)+"'. Expected type 'number'. Function Signature: setEndStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setEndStyle', {"line": this.id, "es": es}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getLeaderLineLength = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLeaderLineLength'. Expected "+0+" arguments. Function Signature: getLeaderLineLength()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getLeaderLineLength', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setLeaderLineLength = function(length)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLeaderLineLength'. Expected "+1+" argument. Function Signature: setLeaderLineLength(number)")};
		if(length instanceof Promise) {throw new TypeError("1st input argument in function 'setLeaderLineLength' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof length != "number") {throw new TypeError("1st input argument '"+length+"' in function 'setLeaderLineLength' is of type '"+(typeof length)+"'. Expected type 'number'. Function Signature: setLeaderLineLength(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setLeaderLineLength', {"line": this.id, "length": length}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getLeaderLineExtensionLength = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLeaderLineExtensionLength'. Expected "+0+" arguments. Function Signature: getLeaderLineExtensionLength()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getLeaderLineExtensionLength', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setLeaderLineExtensionLength = function(length)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLeaderLineExtensionLength'. Expected "+1+" argument. Function Signature: setLeaderLineExtensionLength(number)")};
		if(length instanceof Promise) {throw new TypeError("1st input argument in function 'setLeaderLineExtensionLength' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof length != "number") {throw new TypeError("1st input argument '"+length+"' in function 'setLeaderLineExtensionLength' is of type '"+(typeof length)+"'. Expected type 'number'. Function Signature: setLeaderLineExtensionLength(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setLeaderLineExtensionLength', {"line": this.id, "length": length}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getShowCaption = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getShowCaption'. Expected "+0+" arguments. Function Signature: getShowCaption()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getShowCaption', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setShowCaption = function(sorn)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setShowCaption'. Expected "+1+" argument. Function Signature: setShowCaption(boolean)")};
		if(sorn instanceof Promise) {throw new TypeError("1st input argument in function 'setShowCaption' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof sorn != "boolean") {throw new TypeError("1st input argument '"+sorn+"' in function 'setShowCaption' is of type '"+(typeof sorn)+"'. Expected type 'boolean'. Function Signature: setShowCaption(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setShowCaption', {"line": this.id, "sorn": sorn}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getIntentType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIntentType'. Expected "+0+" arguments. Function Signature: getIntentType()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getIntentType', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setIntentType = function(it)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIntentType'. Expected "+1+" argument. Function Signature: setIntentType(number)")};
		if(it instanceof Promise) {throw new TypeError("1st input argument in function 'setIntentType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof it != "number") {throw new TypeError("1st input argument '"+it+"' in function 'setIntentType' is of type '"+(typeof it)+"'. Expected type 'number'. Function Signature: setIntentType(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setIntentType', {"line": this.id, "it": it}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getCapPos = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCapPos'. Expected "+0+" arguments. Function Signature: getCapPos()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getCapPos', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setCapPos = function(it)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCapPos'. Expected "+1+" argument. Function Signature: setCapPos(number)")};
		if(it instanceof Promise) {throw new TypeError("1st input argument in function 'setCapPos' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof it != "number") {throw new TypeError("1st input argument '"+it+"' in function 'setCapPos' is of type '"+(typeof it)+"'. Expected type 'number'. Function Signature: setCapPos(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setCapPos', {"line": this.id, "it": it}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getLeaderLineOffset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLeaderLineOffset'. Expected "+0+" arguments. Function Signature: getLeaderLineOffset()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getLeaderLineOffset', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setLeaderLineOffset = function(length)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLeaderLineOffset'. Expected "+1+" argument. Function Signature: setLeaderLineOffset(number)")};
		if(length instanceof Promise) {throw new TypeError("1st input argument in function 'setLeaderLineOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof length != "number") {throw new TypeError("1st input argument '"+length+"' in function 'setLeaderLineOffset' is of type '"+(typeof length)+"'. Expected type 'number'. Function Signature: setLeaderLineOffset(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setLeaderLineOffset', {"line": this.id, "length": length}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getTextHOffset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextHOffset'. Expected "+0+" arguments. Function Signature: getTextHOffset()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getTextHOffset', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setTextHOffset = function(offset)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextHOffset'. Expected "+1+" argument. Function Signature: setTextHOffset(number)")};
		if(offset instanceof Promise) {throw new TypeError("1st input argument in function 'setTextHOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof offset != "number") {throw new TypeError("1st input argument '"+offset+"' in function 'setTextHOffset' is of type '"+(typeof offset)+"'. Expected type 'number'. Function Signature: setTextHOffset(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setTextHOffset', {"line": this.id, "offset": offset}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.getTextVOffset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextVOffset'. Expected "+0+" arguments. Function Signature: getTextVOffset()")};
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.getTextVOffset', {"line": this.id}, this.userPriority);
	},

		PDFNet.LineAnnot.prototype.setTextVOffset = function(offset)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextVOffset'. Expected "+1+" argument. Function Signature: setTextVOffset(number)")};
		if(offset instanceof Promise) {throw new TypeError("1st input argument in function 'setTextVOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof offset != "number") {throw new TypeError("1st input argument '"+offset+"' in function 'setTextVOffset' is of type '"+(typeof offset)+"'. Expected type 'number'. Function Signature: setTextVOffset(number).");}
		return PDFNet.messageHandler.sendWithPromise('LineAnnot.setTextVOffset', {"line": this.id, "offset": offset}, this.userPriority);
	},

		PDFNet.CircleAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('circleAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type CircleAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CircleAnnot(id);
		});
	},

		PDFNet.CircleAnnot.createFromAnnot = function(circle)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(circle instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(circle instanceof PDFNet.Annot)) {
			if(typeof circle == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+circle.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+circle+"' in function 'createFromAnnot' is of type '"+(typeof circle)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('circleAnnotCreateFromAnnot', {"circle": circle.id}, this.userPriority).then(function(id){
			//there is a return type CircleAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CircleAnnot(id);
		});
	},

		PDFNet.CircleAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('circleAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type CircleAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.CircleAnnot(id);
		});
	},

		PDFNet.CircleAnnot.prototype.getInteriorColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColor'. Expected "+0+" arguments. Function Signature: getInteriorColor()")};
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.getInteriorColor', {"circle": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.CircleAnnot.prototype.getInteriorColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColorCompNum'. Expected "+0+" arguments. Function Signature: getInteriorColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.getInteriorColorCompNum', {"circle": this.id}, this.userPriority);
	},

		PDFNet.CircleAnnot.prototype.setInteriorColorDefault = function(col)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColorDefault'. Expected "+1+" argument. Function Signature: setInteriorColorDefault(ColorPt)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColorDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColorDefault' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorDefault(ColorPt).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColorDefault' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorDefault(ColorPt).");}
		}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColorDefault'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.setInteriorColorDefault', {"circle": this.id, "col": col.id}, this.userPriority);
	},

		PDFNet.CircleAnnot.prototype.setInteriorColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColor'. Expected "+2+" arguments. Function Signature: setInteriorColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setInteriorColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setInteriorColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.setInteriorColor', {"circle": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.CircleAnnot.prototype.getContentRect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContentRect'. Expected "+0+" arguments. Function Signature: getContentRect()")};
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.getContentRect', {"circle": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.CircleAnnot.prototype.setContentRect = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setContentRect'. Expected "+1+" argument. Function Signature: setContentRect(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setContentRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setContentRect' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setContentRect' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setContentRect'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.setContentRect', {"circle": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.CircleAnnot.prototype.getPadding = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPadding'. Expected "+0+" arguments. Function Signature: getPadding()")};
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.getPadding', {"circle": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.CircleAnnot.prototype.setPadding = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPadding'. Expected "+1+" argument. Function Signature: setPadding(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setPadding' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setPadding' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setPadding' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setPadding'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('CircleAnnot.setPadding', {"circle": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.prototype.export = function(save_as)
	{
		if(typeof save_as === "undefined") {save_as = "";};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'export'. Expected at most "+1+" arguments. Function Signature: export(string)")};
		if(save_as instanceof Promise) {throw new TypeError("1st input argument in function 'export' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof save_as != "string") {throw new TypeError("1st input argument '"+save_as+"' in function 'export' is of type '"+(typeof save_as)+"'. Expected type 'string'. Function Signature: export(string).");}
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.export', {"fileatt": this.id, "save_as": save_as}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.prototype.createFromAnnot = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+0+" arguments. Function Signature: createFromAnnot()")};
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.createFromAnnot', {"fileatt": this.id}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.createWithFileSpec = function(doc, pos, fs, ic)
	{
		if(typeof ic === "undefined") {ic = exports.PDFNet.FileAttachmentAnnot.Icon.e_PushPin};
		if((arguments.length < 3) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'createWithFileSpec'. Expected "+3+" to "+4+" arguments. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createWithFileSpec' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createWithFileSpec' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createWithFileSpec' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'createWithFileSpec' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'createWithFileSpec' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'createWithFileSpec' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
		}
		if(fs instanceof Promise) {throw new TypeError("3rd input argument in function 'createWithFileSpec' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(fs instanceof PDFNet.FileSpec)) {
			if(typeof fs == "object") {throw new TypeError("3rd input argument in function 'createWithFileSpec' is of type '"+fs.name+"'. Expected type 'FileSpec'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
			else {throw new TypeError("3rd input argument '"+fs+"' in function 'createWithFileSpec' is of type '"+(typeof fs)+"'. Expected type 'FileSpec'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
		}
		if(ic instanceof Promise) {throw new TypeError("4th input argument in function 'createWithFileSpec' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ic != "number") {throw new TypeError("4th input argument '"+ic+"' in function 'createWithFileSpec' is of type '"+(typeof ic)+"'. Expected type 'number'. Function Signature: createWithFileSpec(SDFDoc, Rect, FileSpec, number).");}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createWithFileSpec'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreateWithFileSpec', {"doc": doc.id, "pos": pos, "fs": fs.id, "ic": ic}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.createWithIcon = function(doc, pos, path, ic)
	{
		if(typeof ic === "undefined") {ic = exports.PDFNet.FileAttachmentAnnot.Icon.e_PushPin};
		if((arguments.length < 3) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'createWithIcon'. Expected "+3+" to "+4+" arguments. Function Signature: createWithIcon(SDFDoc, Rect, string, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createWithIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createWithIcon' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createWithIcon' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'createWithIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'createWithIcon' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'createWithIcon' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
		}
		if(path instanceof Promise) {throw new TypeError("3rd input argument in function 'createWithIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("3rd input argument '"+path+"' in function 'createWithIcon' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
		if(ic instanceof Promise) {throw new TypeError("4th input argument in function 'createWithIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ic != "number") {throw new TypeError("4th input argument '"+ic+"' in function 'createWithIcon' is of type '"+(typeof ic)+"'. Expected type 'number'. Function Signature: createWithIcon(SDFDoc, Rect, string, number).");}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createWithIcon'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreateWithIcon', {"doc": doc.id, "pos": pos, "path": path, "ic": ic}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.create = function(doc, pos, path, iconname)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+4+" arguments. Function Signature: create(SDFDoc, Rect, string, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect, string, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect, string, string).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect, string, string).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect, string, string).");}
		}
		if(path instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("3rd input argument '"+path+"' in function 'create' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: create(SDFDoc, Rect, string, string).");}
		if(iconname instanceof Promise) {throw new TypeError("4th input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof iconname != "string") {throw new TypeError("4th input argument '"+iconname+"' in function 'create' is of type '"+(typeof iconname)+"'. Expected type 'string'. Function Signature: create(SDFDoc, Rect, string, string).");}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreate', {"doc": doc.id, "pos": pos, "path": path, "iconname": iconname}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.createDefault = function(doc, pos, path)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createDefault'. Expected "+3+" arguments. Function Signature: createDefault(SDFDoc, Rect, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createDefault' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createDefault(SDFDoc, Rect, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createDefault' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createDefault(SDFDoc, Rect, string).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'createDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'createDefault' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: createDefault(SDFDoc, Rect, string).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'createDefault' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: createDefault(SDFDoc, Rect, string).");}
		}
		if(path instanceof Promise) {throw new TypeError("3rd input argument in function 'createDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("3rd input argument '"+path+"' in function 'createDefault' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: createDefault(SDFDoc, Rect, string).");}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createDefault'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreateDefault', {"doc": doc.id, "pos": pos, "path": path}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},

		PDFNet.FileAttachmentAnnot.prototype.getFileSpec = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFileSpec'. Expected "+0+" arguments. Function Signature: getFileSpec()")};
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.getFileSpec', {"fileatt": this.id}, this.userPriority).then(function(id){
			//there is a return type FileSpec
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileSpec(id);
		});
	},

		PDFNet.FileAttachmentAnnot.prototype.setFileSpec = function(fspec)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFileSpec'. Expected "+1+" argument. Function Signature: setFileSpec(FileSpec)")};
		if(fspec instanceof Promise) {throw new TypeError("1st input argument in function 'setFileSpec' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(fspec instanceof PDFNet.FileSpec)) {
			if(typeof fspec == "object") {throw new TypeError("1st input argument in function 'setFileSpec' is of type '"+fspec.name+"'. Expected type 'FileSpec'. Function Signature: setFileSpec(FileSpec).");}
			else {throw new TypeError("1st input argument '"+fspec+"' in function 'setFileSpec' is of type '"+(typeof fspec)+"'. Expected type 'FileSpec'. Function Signature: setFileSpec(FileSpec).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.setFileSpec', {"fileatt": this.id, "fspec": fspec.id}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.prototype.getIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIcon'. Expected "+0+" arguments. Function Signature: getIcon()")};
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.getIcon', {"fileatt": this.id}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.prototype.setIcon = function(icon)
	{
		if(typeof icon === "undefined") {icon = exports.PDFNet.FileAttachmentAnnot.Icon.e_PushPin};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIcon'. Expected at most "+1+" arguments. Function Signature: setIcon(number)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof icon != "number") {throw new TypeError("1st input argument '"+icon+"' in function 'setIcon' is of type '"+(typeof icon)+"'. Expected type 'number'. Function Signature: setIcon(number).");}
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.setIcon', {"fileatt": this.id, "icon": icon}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.prototype.getIconName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconName'. Expected "+0+" arguments. Function Signature: getIconName()")};
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.getIconName', {"fileatt": this.id}, this.userPriority);
	},

		PDFNet.FileAttachmentAnnot.prototype.setIconName = function(iname)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconName'. Expected "+1+" argument. Function Signature: setIconName(string)")};
		if(iname instanceof Promise) {throw new TypeError("1st input argument in function 'setIconName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof iname != "string") {throw new TypeError("1st input argument '"+iname+"' in function 'setIconName' is of type '"+(typeof iname)+"'. Expected type 'string'. Function Signature: setIconName(string).");}
		return PDFNet.messageHandler.sendWithPromise('FileAttachmentAnnot.setIconName', {"fileatt": this.id, "iname": iname}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('freeTextAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type FreeTextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FreeTextAnnot(id);
		});
	},

		PDFNet.FreeTextAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('freeTextAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type FreeTextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FreeTextAnnot(id);
		});
	},

		PDFNet.FreeTextAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('freeTextAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type FreeTextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.FreeTextAnnot(id);
		});
	},

		PDFNet.FreeTextAnnot.prototype.getDefaultAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDefaultAppearance'. Expected "+0+" arguments. Function Signature: getDefaultAppearance()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getDefaultAppearance', {"ft": this.id}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setDefaultAppearance = function(defApp)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultAppearance'. Expected "+1+" argument. Function Signature: setDefaultAppearance(string)")};
		if(defApp instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof defApp != "string") {throw new TypeError("1st input argument '"+defApp+"' in function 'setDefaultAppearance' is of type '"+(typeof defApp)+"'. Expected type 'string'. Function Signature: setDefaultAppearance(string).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setDefaultAppearance', {"ft": this.id, "defApp": defApp}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getQuaddingFormat = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuaddingFormat'. Expected "+0+" arguments. Function Signature: getQuaddingFormat()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getQuaddingFormat', {"ft": this.id}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setQuaddingFormat = function(format)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setQuaddingFormat'. Expected "+1+" argument. Function Signature: setQuaddingFormat(number)")};
		if(format instanceof Promise) {throw new TypeError("1st input argument in function 'setQuaddingFormat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof format != "number") {throw new TypeError("1st input argument '"+format+"' in function 'setQuaddingFormat' is of type '"+(typeof format)+"'. Expected type 'number'. Function Signature: setQuaddingFormat(number).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setQuaddingFormat', {"ft": this.id, "format": format}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getCalloutLinePoints = function(p1, p2, p3)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'getCalloutLinePoints'. Expected "+3+" arguments. Function Signature: getCalloutLinePoints(Point, Point, Point)")};
		if(p1 instanceof Promise) {throw new TypeError("1st input argument in function 'getCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p1 instanceof PDFNet.Point) && p1.name != "Point") {
			if(typeof p1 == "object") {throw new TypeError("1st input argument in function 'getCalloutLinePoints' is of type '"+p1.name+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("1st input argument '"+p1+"' in function 'getCalloutLinePoints' is of type '"+(typeof p1)+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
		}
		if(p2 instanceof Promise) {throw new TypeError("2nd input argument in function 'getCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p2 instanceof PDFNet.Point) && p2.name != "Point") {
			if(typeof p2 == "object") {throw new TypeError("2nd input argument in function 'getCalloutLinePoints' is of type '"+p2.name+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("2nd input argument '"+p2+"' in function 'getCalloutLinePoints' is of type '"+(typeof p2)+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
		}
		if(p3 instanceof Promise) {throw new TypeError("3rd input argument in function 'getCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p3 instanceof PDFNet.Point) && p3.name != "Point") {
			if(typeof p3 == "object") {throw new TypeError("3rd input argument in function 'getCalloutLinePoints' is of type '"+p3.name+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("3rd input argument '"+p3+"' in function 'getCalloutLinePoints' is of type '"+(typeof p3)+"'. Expected type 'Point'. Function Signature: getCalloutLinePoints(Point, Point, Point).");}
		}
		if(typeof p1.yieldFunction != "undefined") {throw new Error("Function '"+p1.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'getCalloutLinePoints'. Perhaps a yield statement is required for '"+p1.yieldFunction+"'?");}
		if(typeof p2.yieldFunction != "undefined") {throw new Error("Function '"+p2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'getCalloutLinePoints'. Perhaps a yield statement is required for '"+p2.yieldFunction+"'?");}
		if(typeof p3.yieldFunction != "undefined") {throw new Error("Function '"+p3.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'getCalloutLinePoints'. Perhaps a yield statement is required for '"+p3.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getCalloutLinePoints', {"ft": this.id, "p1": p1, "p2": p2, "p3": p3}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setCalloutLinePoints = function(p1, p2, p3)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'setCalloutLinePoints'. Expected "+3+" arguments. Function Signature: setCalloutLinePoints(Point, Point, Point)")};
		if(p1 instanceof Promise) {throw new TypeError("1st input argument in function 'setCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p1 instanceof PDFNet.Point) && p1.name != "Point") {
			if(typeof p1 == "object") {throw new TypeError("1st input argument in function 'setCalloutLinePoints' is of type '"+p1.name+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("1st input argument '"+p1+"' in function 'setCalloutLinePoints' is of type '"+(typeof p1)+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
		}
		if(p2 instanceof Promise) {throw new TypeError("2nd input argument in function 'setCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p2 instanceof PDFNet.Point) && p2.name != "Point") {
			if(typeof p2 == "object") {throw new TypeError("2nd input argument in function 'setCalloutLinePoints' is of type '"+p2.name+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("2nd input argument '"+p2+"' in function 'setCalloutLinePoints' is of type '"+(typeof p2)+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
		}
		if(p3 instanceof Promise) {throw new TypeError("3rd input argument in function 'setCalloutLinePoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p3 instanceof PDFNet.Point) && p3.name != "Point") {
			if(typeof p3 == "object") {throw new TypeError("3rd input argument in function 'setCalloutLinePoints' is of type '"+p3.name+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
			else {throw new TypeError("3rd input argument '"+p3+"' in function 'setCalloutLinePoints' is of type '"+(typeof p3)+"'. Expected type 'Point'. Function Signature: setCalloutLinePoints(Point, Point, Point).");}
		}
		if(typeof p1.yieldFunction != "undefined") {throw new Error("Function '"+p1.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setCalloutLinePoints'. Perhaps a yield statement is required for '"+p1.yieldFunction+"'?");}
		if(typeof p2.yieldFunction != "undefined") {throw new Error("Function '"+p2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setCalloutLinePoints'. Perhaps a yield statement is required for '"+p2.yieldFunction+"'?");}
		if(typeof p3.yieldFunction != "undefined") {throw new Error("Function '"+p3.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'setCalloutLinePoints'. Perhaps a yield statement is required for '"+p3.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setCalloutLinePoints', {"ft": this.id, "p1": p1, "p2": p2, "p3": p3}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setCalloutLinePointsTwo = function(p1, p2)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setCalloutLinePointsTwo'. Expected "+2+" arguments. Function Signature: setCalloutLinePointsTwo(Point, Point)")};
		if(p1 instanceof Promise) {throw new TypeError("1st input argument in function 'setCalloutLinePointsTwo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p1 instanceof PDFNet.Point) && p1.name != "Point") {
			if(typeof p1 == "object") {throw new TypeError("1st input argument in function 'setCalloutLinePointsTwo' is of type '"+p1.name+"'. Expected type 'Point'. Function Signature: setCalloutLinePointsTwo(Point, Point).");}
			else {throw new TypeError("1st input argument '"+p1+"' in function 'setCalloutLinePointsTwo' is of type '"+(typeof p1)+"'. Expected type 'Point'. Function Signature: setCalloutLinePointsTwo(Point, Point).");}
		}
		if(p2 instanceof Promise) {throw new TypeError("2nd input argument in function 'setCalloutLinePointsTwo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(p2 instanceof PDFNet.Point) && p2.name != "Point") {
			if(typeof p2 == "object") {throw new TypeError("2nd input argument in function 'setCalloutLinePointsTwo' is of type '"+p2.name+"'. Expected type 'Point'. Function Signature: setCalloutLinePointsTwo(Point, Point).");}
			else {throw new TypeError("2nd input argument '"+p2+"' in function 'setCalloutLinePointsTwo' is of type '"+(typeof p2)+"'. Expected type 'Point'. Function Signature: setCalloutLinePointsTwo(Point, Point).");}
		}
		if(typeof p1.yieldFunction != "undefined") {throw new Error("Function '"+p1.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setCalloutLinePointsTwo'. Perhaps a yield statement is required for '"+p1.yieldFunction+"'?");}
		if(typeof p2.yieldFunction != "undefined") {throw new Error("Function '"+p2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setCalloutLinePointsTwo'. Perhaps a yield statement is required for '"+p2.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setCalloutLinePointsTwo', {"ft": this.id, "p1": p1, "p2": p2}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getIntentName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIntentName'. Expected "+0+" arguments. Function Signature: getIntentName()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getIntentName', {"ft": this.id}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setIntentName = function(mode)
	{
		if(typeof mode === "undefined") {mode = exports.PDFNet.FreeTextAnnot.IntentName.e_FreeText};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIntentName'. Expected at most "+1+" arguments. Function Signature: setIntentName(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setIntentName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setIntentName' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setIntentName(number).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setIntentName', {"ft": this.id, "mode": mode}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setIntentNameDefault = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'setIntentNameDefault'. Expected "+0+" arguments. Function Signature: setIntentNameDefault()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setIntentNameDefault', {"ft": this.id}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getEndingStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEndingStyle'. Expected "+0+" arguments. Function Signature: getEndingStyle()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getEndingStyle', {"ft": this.id}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setEndingStyle = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEndingStyle'. Expected "+1+" argument. Function Signature: setEndingStyle(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setEndingStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setEndingStyle' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setEndingStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setEndingStyle', {"ft": this.id, "style": style}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setEndingStyleName = function(est)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEndingStyleName'. Expected "+1+" argument. Function Signature: setEndingStyleName(string)")};
		if(est instanceof Promise) {throw new TypeError("1st input argument in function 'setEndingStyleName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof est != "string") {throw new TypeError("1st input argument '"+est+"' in function 'setEndingStyleName' is of type '"+(typeof est)+"'. Expected type 'string'. Function Signature: setEndingStyleName(string).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setEndingStyleName', {"ft": this.id, "est": est}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.setTextColor = function(color, col_components)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setTextColor'. Expected "+2+" arguments. Function Signature: setTextColor(ColorPt, number)")};
		if(color instanceof Promise) {throw new TypeError("1st input argument in function 'setTextColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color instanceof PDFNet.ColorPt) && color.name != "ColorPt") {
			if(typeof color == "object") {throw new TypeError("1st input argument in function 'setTextColor' is of type '"+color.name+"'. Expected type 'ColorPt'. Function Signature: setTextColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+color+"' in function 'setTextColor' is of type '"+(typeof color)+"'. Expected type 'ColorPt'. Function Signature: setTextColor(ColorPt, number).");}
		}
		if(col_components instanceof Promise) {throw new TypeError("2nd input argument in function 'setTextColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof col_components != "number") {throw new TypeError("2nd input argument '"+col_components+"' in function 'setTextColor' is of type '"+(typeof col_components)+"'. Expected type 'number'. Function Signature: setTextColor(ColorPt, number).");}
		if(typeof color.yieldFunction != "undefined") {throw new Error("Function '"+color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setTextColor'. Perhaps a yield statement is required for '"+color.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setTextColor', {"ft": this.id, "color": color.id, "col_components": col_components}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getTextColor = function(col_components)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTextColor'. Expected "+1+" argument. Function Signature: getTextColor(number)")};
		if(col_components instanceof Promise) {throw new TypeError("2nd input argument in function 'getTextColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof col_components != "number") {throw new TypeError("2nd input argument '"+col_components+"' in function 'getTextColor' is of type '"+(typeof col_components)+"'. Expected type 'number'. Function Signature: getTextColor(number).");}
		var me = this;
		this.yieldFunction = "FreeTextAnnot.getTextColor"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getTextColor', {"ft": this.id, "col_components": col_components}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.FreeTextAnnot.prototype.setLineColor = function(color, col_components)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setLineColor'. Expected "+2+" arguments. Function Signature: setLineColor(ColorPt, number)")};
		if(color instanceof Promise) {throw new TypeError("1st input argument in function 'setLineColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color instanceof PDFNet.ColorPt) && color.name != "ColorPt") {
			if(typeof color == "object") {throw new TypeError("1st input argument in function 'setLineColor' is of type '"+color.name+"'. Expected type 'ColorPt'. Function Signature: setLineColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+color+"' in function 'setLineColor' is of type '"+(typeof color)+"'. Expected type 'ColorPt'. Function Signature: setLineColor(ColorPt, number).");}
		}
		if(col_components instanceof Promise) {throw new TypeError("2nd input argument in function 'setLineColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof col_components != "number") {throw new TypeError("2nd input argument '"+col_components+"' in function 'setLineColor' is of type '"+(typeof col_components)+"'. Expected type 'number'. Function Signature: setLineColor(ColorPt, number).");}
		if(typeof color.yieldFunction != "undefined") {throw new Error("Function '"+color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setLineColor'. Perhaps a yield statement is required for '"+color.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setLineColor', {"ft": this.id, "color": color.id, "col_components": col_components}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getLineColor = function(col_components)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getLineColor'. Expected "+1+" argument. Function Signature: getLineColor(number)")};
		if(col_components instanceof Promise) {throw new TypeError("2nd input argument in function 'getLineColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof col_components != "number") {throw new TypeError("2nd input argument '"+col_components+"' in function 'getLineColor' is of type '"+(typeof col_components)+"'. Expected type 'number'. Function Signature: getLineColor(number).");}
		var me = this;
		this.yieldFunction = "FreeTextAnnot.getLineColor"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getLineColor', {"ft": this.id, "col_components": col_components}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.FreeTextAnnot.prototype.setFontSize = function(font_size)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFontSize'. Expected "+1+" argument. Function Signature: setFontSize(number)")};
		if(font_size instanceof Promise) {throw new TypeError("1st input argument in function 'setFontSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_size != "number") {throw new TypeError("1st input argument '"+font_size+"' in function 'setFontSize' is of type '"+(typeof font_size)+"'. Expected type 'number'. Function Signature: setFontSize(number).");}
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.setFontSize', {"ft": this.id, "font_size": font_size}, this.userPriority);
	},

		PDFNet.FreeTextAnnot.prototype.getFontSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFontSize'. Expected "+0+" arguments. Function Signature: getFontSize()")};
		return PDFNet.messageHandler.sendWithPromise('FreeTextAnnot.getFontSize', {"ft": this.id}, this.userPriority);
	},

		PDFNet.HighlightAnnot.createFromObj = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('highlightAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type HighlightAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.HighlightAnnot(id);
		});
	},

		PDFNet.HighlightAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('highlightAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type HighlightAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.HighlightAnnot(id);
		});
	},

		PDFNet.HighlightAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('highlightAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type HighlightAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.HighlightAnnot(id);
		});
	},

		PDFNet.InkAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('inkAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type InkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.InkAnnot(id);
		});
	},

		PDFNet.InkAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('inkAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type InkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.InkAnnot(id);
		});
	},

		PDFNet.InkAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('inkAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type InkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.InkAnnot(id);
		});
	},

		PDFNet.InkAnnot.prototype.getPathCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPathCount'. Expected "+0+" arguments. Function Signature: getPathCount()")};
		return PDFNet.messageHandler.sendWithPromise('InkAnnot.getPathCount', {"ink": this.id}, this.userPriority);
	},

		PDFNet.InkAnnot.prototype.getPointCount = function(pathindex)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPointCount'. Expected "+1+" argument. Function Signature: getPointCount(number)")};
		if(pathindex instanceof Promise) {throw new TypeError("1st input argument in function 'getPointCount' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pathindex != "number") {throw new TypeError("1st input argument '"+pathindex+"' in function 'getPointCount' is of type '"+(typeof pathindex)+"'. Expected type 'number'. Function Signature: getPointCount(number).");}
		return PDFNet.messageHandler.sendWithPromise('InkAnnot.getPointCount', {"ink": this.id, "pathindex": pathindex}, this.userPriority);
	},

		PDFNet.InkAnnot.prototype.getPoint = function(pathindex, pointindex)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'getPoint'. Expected "+2+" arguments. Function Signature: getPoint(number, number)")};
		if(pathindex instanceof Promise) {throw new TypeError("1st input argument in function 'getPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pathindex != "number") {throw new TypeError("1st input argument '"+pathindex+"' in function 'getPoint' is of type '"+(typeof pathindex)+"'. Expected type 'number'. Function Signature: getPoint(number, number).");}
		if(pointindex instanceof Promise) {throw new TypeError("2nd input argument in function 'getPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pointindex != "number") {throw new TypeError("2nd input argument '"+pointindex+"' in function 'getPoint' is of type '"+(typeof pointindex)+"'. Expected type 'number'. Function Signature: getPoint(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('InkAnnot.getPoint', {"ink": this.id, "pathindex": pathindex, "pointindex": pointindex}, this.userPriority);
	},

		PDFNet.InkAnnot.prototype.setPoint = function(pathindex, pointindex, point)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'setPoint'. Expected "+3+" arguments. Function Signature: setPoint(number, number, Point)")};
		if(pathindex instanceof Promise) {throw new TypeError("1st input argument in function 'setPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pathindex != "number") {throw new TypeError("1st input argument '"+pathindex+"' in function 'setPoint' is of type '"+(typeof pathindex)+"'. Expected type 'number'. Function Signature: setPoint(number, number, Point).");}
		if(pointindex instanceof Promise) {throw new TypeError("2nd input argument in function 'setPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pointindex != "number") {throw new TypeError("2nd input argument '"+pointindex+"' in function 'setPoint' is of type '"+(typeof pointindex)+"'. Expected type 'number'. Function Signature: setPoint(number, number, Point).");}
		if(point instanceof Promise) {throw new TypeError("3rd input argument in function 'setPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(point instanceof PDFNet.Point) && point.name != "Point") {
			if(typeof point == "object") {throw new TypeError("3rd input argument in function 'setPoint' is of type '"+point.name+"'. Expected type 'Point'. Function Signature: setPoint(number, number, Point).");}
			else {throw new TypeError("3rd input argument '"+point+"' in function 'setPoint' is of type '"+(typeof point)+"'. Expected type 'Point'. Function Signature: setPoint(number, number, Point).");}
		}
		if(typeof point.yieldFunction != "undefined") {throw new Error("Function '"+point.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'setPoint'. Perhaps a yield statement is required for '"+point.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('InkAnnot.setPoint', {"ink": this.id, "pathindex": pathindex, "pointindex": pointindex, "point": point}, this.userPriority);
	},

		PDFNet.InkAnnot.prototype.erase = function(pt1, pt2, width)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'erase'. Expected "+3+" arguments. Function Signature: erase(Point, Point, number)")};
		if(pt1 instanceof Promise) {throw new TypeError("1st input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pt1 instanceof PDFNet.Point) && pt1.name != "Point") {
			if(typeof pt1 == "object") {throw new TypeError("1st input argument in function 'erase' is of type '"+pt1.name+"'. Expected type 'Point'. Function Signature: erase(Point, Point, number).");}
			else {throw new TypeError("1st input argument '"+pt1+"' in function 'erase' is of type '"+(typeof pt1)+"'. Expected type 'Point'. Function Signature: erase(Point, Point, number).");}
		}
		if(pt2 instanceof Promise) {throw new TypeError("2nd input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pt2 instanceof PDFNet.Point) && pt2.name != "Point") {
			if(typeof pt2 == "object") {throw new TypeError("2nd input argument in function 'erase' is of type '"+pt2.name+"'. Expected type 'Point'. Function Signature: erase(Point, Point, number).");}
			else {throw new TypeError("2nd input argument '"+pt2+"' in function 'erase' is of type '"+(typeof pt2)+"'. Expected type 'Point'. Function Signature: erase(Point, Point, number).");}
		}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'erase' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: erase(Point, Point, number).");}
		if(typeof pt1.yieldFunction != "undefined") {throw new Error("Function '"+pt1.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'erase'. Perhaps a yield statement is required for '"+pt1.yieldFunction+"'?");}
		if(typeof pt2.yieldFunction != "undefined") {throw new Error("Function '"+pt2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'erase'. Perhaps a yield statement is required for '"+pt2.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('InkAnnot.erase', {"ink": this.id, "pt1": pt1, "pt2": pt2, "width": width}, this.userPriority);
	},

		PDFNet.LinkAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('linkAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type LinkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LinkAnnot(id);
		});
	},

		PDFNet.LinkAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('linkAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type LinkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LinkAnnot(id);
		});
	},

		PDFNet.LinkAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('linkAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type LinkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.LinkAnnot(id);
		});
	},

		PDFNet.LinkAnnot.prototype.removeAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'removeAction'. Expected "+0+" arguments. Function Signature: removeAction()")};
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.removeAction', {"link": this.id}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.getAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAction'. Expected "+0+" arguments. Function Signature: getAction()")};
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.getAction', {"link": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.LinkAnnot.prototype.setAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAction'. Expected "+1+" argument. Function Signature: setAction(Action)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Action)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setAction' is of type '"+action.name+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setAction' is of type '"+(typeof action)+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.setAction', {"link": this.id, "action": action.id}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.getHighlightingMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHighlightingMode'. Expected "+0+" arguments. Function Signature: getHighlightingMode()")};
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.getHighlightingMode', {"link": this.id}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.setHighlightingMode = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHighlightingMode'. Expected "+1+" argument. Function Signature: setHighlightingMode(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setHighlightingMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'setHighlightingMode' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: setHighlightingMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.setHighlightingMode', {"link": this.id, "value": value}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.getQuadPointCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPointCount'. Expected "+0+" arguments. Function Signature: getQuadPointCount()")};
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.getQuadPointCount', {"link": this.id}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.getQuadPoint = function(idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPoint'. Expected "+1+" argument. Function Signature: getQuadPoint(number)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'getQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'getQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: getQuadPoint(number).");}
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.getQuadPoint', {"link": this.id, "idx": idx}, this.userPriority);
	},

		PDFNet.LinkAnnot.prototype.setQuadPoint = function(idx, qp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setQuadPoint'. Expected "+2+" arguments. Function Signature: setQuadPoint(number, QuadPoint)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'setQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: setQuadPoint(number, QuadPoint).");}
		if(qp instanceof Promise) {throw new TypeError("2nd input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(qp instanceof PDFNet.QuadPoint) && qp.name != "QuadPoint") {
			if(typeof qp == "object") {throw new TypeError("2nd input argument in function 'setQuadPoint' is of type '"+qp.name+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
			else {throw new TypeError("2nd input argument '"+qp+"' in function 'setQuadPoint' is of type '"+(typeof qp)+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
		}
		if(typeof qp.yieldFunction != "undefined") {throw new Error("Function '"+qp.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setQuadPoint'. Perhaps a yield statement is required for '"+qp.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('LinkAnnot.setQuadPoint', {"link": this.id, "idx": idx, "qp": qp}, this.userPriority);
	},

		PDFNet.getNormalizedUrl = function(url)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getNormalizedUrl'. Expected "+1+" argument. Function Signature: getNormalizedUrl(string)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'getNormalizedUrl' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("1st input argument '"+url+"' in function 'getNormalizedUrl' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: getNormalizedUrl(string).");}
		return PDFNet.messageHandler.sendWithPromise('getNormalizedUrl', {"url": url}, this.userPriority);
	},

		PDFNet.MarkupAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('markupAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type MarkupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.MarkupAnnot(id);
		});
	},

		PDFNet.MarkupAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('markupAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type MarkupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.MarkupAnnot(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getTitle', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setTitle = function(title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitle'. Expected "+1+" argument. Function Signature: setTitle(string)")};
		if(title instanceof Promise) {throw new TypeError("1st input argument in function 'setTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof title != "string") {throw new TypeError("1st input argument '"+title+"' in function 'setTitle' is of type '"+(typeof title)+"'. Expected type 'string'. Function Signature: setTitle(string).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setTitle', {"markup": this.id, "title": title}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setTitleUString = function(title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitleUString'. Expected "+1+" argument. Function Signature: setTitleUString(string)")};
		if(title instanceof Promise) {throw new TypeError("1st input argument in function 'setTitleUString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof title != "string") {throw new TypeError("1st input argument '"+title+"' in function 'setTitleUString' is of type '"+(typeof title)+"'. Expected type 'string'. Function Signature: setTitleUString(string).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setTitleUString', {"markup": this.id, "title": title}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getPopup = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPopup'. Expected "+0+" arguments. Function Signature: getPopup()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getPopup', {"markup": this.id}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.setPopup = function(ppup)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPopup'. Expected "+1+" argument. Function Signature: setPopup(Annot)")};
		if(ppup instanceof Promise) {throw new TypeError("1st input argument in function 'setPopup' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ppup instanceof PDFNet.Annot)) {
			if(typeof ppup == "object") {throw new TypeError("1st input argument in function 'setPopup' is of type '"+ppup.name+"'. Expected type 'Annot'. Function Signature: setPopup(Annot).");}
			else {throw new TypeError("1st input argument '"+ppup+"' in function 'setPopup' is of type '"+(typeof ppup)+"'. Expected type 'Annot'. Function Signature: setPopup(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setPopup', {"markup": this.id, "ppup": ppup.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getOpacity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOpacity'. Expected "+0+" arguments. Function Signature: getOpacity()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getOpacity', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setOpacity = function(op)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpacity'. Expected "+1+" argument. Function Signature: setOpacity(number)")};
		if(op instanceof Promise) {throw new TypeError("1st input argument in function 'setOpacity' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof op != "number") {throw new TypeError("1st input argument '"+op+"' in function 'setOpacity' is of type '"+(typeof op)+"'. Expected type 'number'. Function Signature: setOpacity(number).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setOpacity', {"markup": this.id, "op": op}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getSubject = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSubject'. Expected "+0+" arguments. Function Signature: getSubject()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getSubject', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setSubject = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSubject'. Expected "+1+" argument. Function Signature: setSubject(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setSubject' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setSubject' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setSubject(string).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setSubject', {"markup": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getCreationDates = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCreationDates'. Expected "+0+" arguments. Function Signature: getCreationDates()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getCreationDates', {"markup": this.id}, this.userPriority).then(function(id){
			//there is a return type Date
			if(id == "0"){
				return null;
			}
			return new PDFNet.Date(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.getBorderEffect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderEffect'. Expected "+0+" arguments. Function Signature: getBorderEffect()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getBorderEffect', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setBorderEffect = function(effect)
	{
		if(typeof effect === "undefined") {effect = exports.PDFNet.MarkupAnnot.BorderEffect.e_None};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderEffect'. Expected at most "+1+" arguments. Function Signature: setBorderEffect(number)")};
		if(effect instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderEffect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof effect != "number") {throw new TypeError("1st input argument '"+effect+"' in function 'setBorderEffect' is of type '"+(typeof effect)+"'. Expected type 'number'. Function Signature: setBorderEffect(number).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setBorderEffect', {"markup": this.id, "effect": effect}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getBorderEffectIntensity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderEffectIntensity'. Expected "+0+" arguments. Function Signature: getBorderEffectIntensity()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getBorderEffectIntensity', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setBorderEffectIntensity = function(intensity)
	{
		if(typeof intensity === "undefined") {intensity = 0;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderEffectIntensity'. Expected at most "+1+" arguments. Function Signature: setBorderEffectIntensity(number)")};
		if(intensity instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderEffectIntensity' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof intensity != "number") {throw new TypeError("1st input argument '"+intensity+"' in function 'setBorderEffectIntensity' is of type '"+(typeof intensity)+"'. Expected type 'number'. Function Signature: setBorderEffectIntensity(number).");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setBorderEffectIntensity', {"markup": this.id, "intensity": intensity}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setCreationDates = function(date)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCreationDates'. Expected "+1+" argument. Function Signature: setCreationDates(Date)")};
		if(date instanceof Promise) {throw new TypeError("1st input argument in function 'setCreationDates' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(date instanceof PDFNet.Date) && date.name != "Date") {
			if(typeof date == "object") {throw new TypeError("1st input argument in function 'setCreationDates' is of type '"+date.name+"'. Expected type 'Date'. Function Signature: setCreationDates(Date).");}
			else {throw new TypeError("1st input argument '"+date+"' in function 'setCreationDates' is of type '"+(typeof date)+"'. Expected type 'Date'. Function Signature: setCreationDates(Date).");}
		}
		if(typeof date.yieldFunction != "undefined") {throw new Error("Function '"+date.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setCreationDates'. Perhaps a yield statement is required for '"+date.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setCreationDates', {"markup": this.id, "date": date}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getInteriorColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColor'. Expected "+0+" arguments. Function Signature: getInteriorColor()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getInteriorColor', {"markup": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.getInteriorColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColorCompNum'. Expected "+0+" arguments. Function Signature: getInteriorColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getInteriorColorCompNum', {"markup": this.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setInteriorColorRGB = function(col)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColorRGB'. Expected "+1+" argument. Function Signature: setInteriorColorRGB(ColorPt)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColorRGB' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColorRGB' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorRGB(ColorPt).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColorRGB' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorRGB(ColorPt).");}
		}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColorRGB'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setInteriorColorRGB', {"markup": this.id, "col": col.id}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.setInteriorColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColor'. Expected "+2+" arguments. Function Signature: setInteriorColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setInteriorColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setInteriorColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setInteriorColor', {"markup": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getContentRect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContentRect'. Expected "+0+" arguments. Function Signature: getContentRect()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getContentRect', {"markup": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.setContentRect = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setContentRect'. Expected "+1+" argument. Function Signature: setContentRect(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setContentRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setContentRect' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setContentRect' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setContentRect'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setContentRect', {"markup": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.MarkupAnnot.prototype.getPadding = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPadding'. Expected "+0+" arguments. Function Signature: getPadding()")};
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.getPadding', {"markup": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.MarkupAnnot.prototype.setPadding = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPadding'. Expected "+1+" argument. Function Signature: setPadding(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setPadding' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setPadding' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setPadding' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setPadding'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('MarkupAnnot.setPadding', {"markup": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.MovieAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('movieAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type MovieAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.MovieAnnot(id);
		});
	},

		PDFNet.MovieAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('movieAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type MovieAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.MovieAnnot(id);
		});
	},

		PDFNet.MovieAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('movieAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type MovieAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.MovieAnnot(id);
		});
	},

		PDFNet.MovieAnnot.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		return PDFNet.messageHandler.sendWithPromise('MovieAnnot.getTitle', {"movie": this.id}, this.userPriority);
	},

		PDFNet.MovieAnnot.prototype.setTitle = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitle'. Expected "+1+" argument. Function Signature: setTitle(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setTitle' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setTitle(string).");}
		return PDFNet.messageHandler.sendWithPromise('MovieAnnot.setTitle', {"movie": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.MovieAnnot.prototype.isToBePlayed = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isToBePlayed'. Expected "+0+" arguments. Function Signature: isToBePlayed()")};
		return PDFNet.messageHandler.sendWithPromise('MovieAnnot.isToBePlayed', {"movie": this.id}, this.userPriority);
	},

		PDFNet.MovieAnnot.prototype.setToBePlayed = function(playono)
	{
		if(typeof playono === "undefined") {playono = true;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setToBePlayed'. Expected at most "+1+" arguments. Function Signature: setToBePlayed(boolean)")};
		if(playono instanceof Promise) {throw new TypeError("1st input argument in function 'setToBePlayed' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof playono != "boolean") {throw new TypeError("1st input argument '"+playono+"' in function 'setToBePlayed' is of type '"+(typeof playono)+"'. Expected type 'boolean'. Function Signature: setToBePlayed(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('MovieAnnot.setToBePlayed', {"movie": this.id, "playono": playono}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('polyLineAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type PolyLineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolyLineAnnot(id);
		});
	},

		PDFNet.PolyLineAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('polyLineAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type PolyLineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolyLineAnnot(id);
		});
	},

		PDFNet.PolyLineAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('polyLineAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type PolyLineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolyLineAnnot(id);
		});
	},

		PDFNet.PolyLineAnnot.prototype.getVertexCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVertexCount'. Expected "+0+" arguments. Function Signature: getVertexCount()")};
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.getVertexCount', {"polyline": this.id}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.getVertex = function(idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getVertex'. Expected "+1+" argument. Function Signature: getVertex(number)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'getVertex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'getVertex' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: getVertex(number).");}
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.getVertex', {"polyline": this.id, "idx": idx}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.setVertex = function(idx, pt)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setVertex'. Expected "+2+" arguments. Function Signature: setVertex(number, Point)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'setVertex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'setVertex' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: setVertex(number, Point).");}
		if(pt instanceof Promise) {throw new TypeError("2nd input argument in function 'setVertex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pt instanceof PDFNet.Point) && pt.name != "Point") {
			if(typeof pt == "object") {throw new TypeError("2nd input argument in function 'setVertex' is of type '"+pt.name+"'. Expected type 'Point'. Function Signature: setVertex(number, Point).");}
			else {throw new TypeError("2nd input argument '"+pt+"' in function 'setVertex' is of type '"+(typeof pt)+"'. Expected type 'Point'. Function Signature: setVertex(number, Point).");}
		}
		if(typeof pt.yieldFunction != "undefined") {throw new Error("Function '"+pt.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setVertex'. Perhaps a yield statement is required for '"+pt.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.setVertex', {"polyline": this.id, "idx": idx, "pt": pt}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.getStartStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStartStyle'. Expected "+0+" arguments. Function Signature: getStartStyle()")};
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.getStartStyle', {"polyline": this.id}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.setStartStyle = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStartStyle'. Expected "+1+" argument. Function Signature: setStartStyle(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setStartStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setStartStyle' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setStartStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.setStartStyle', {"polyline": this.id, "style": style}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.getEndStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEndStyle'. Expected "+0+" arguments. Function Signature: getEndStyle()")};
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.getEndStyle', {"polyline": this.id}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.setEndStyle = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEndStyle'. Expected "+1+" argument. Function Signature: setEndStyle(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setEndStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setEndStyle' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setEndStyle(number).");}
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.setEndStyle', {"polyline": this.id, "style": style}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.getIntentName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIntentName'. Expected "+0+" arguments. Function Signature: getIntentName()")};
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.getIntentName', {"polyline": this.id}, this.userPriority);
	},

		PDFNet.PolyLineAnnot.prototype.setIntentName = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIntentName'. Expected "+1+" argument. Function Signature: setIntentName(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIntentName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setIntentName' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setIntentName(number).");}
		return PDFNet.messageHandler.sendWithPromise('PolyLineAnnot.setIntentName', {"polyline": this.id, "style": style}, this.userPriority);
	},

		PDFNet.PolygonAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('polygonAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type PolygonAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolygonAnnot(id);
		});
	},

		PDFNet.PolygonAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('polygonAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type PolygonAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolygonAnnot(id);
		});
	},

		PDFNet.PolygonAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('polygonAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type PolygonAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PolygonAnnot(id);
		});
	},

		PDFNet.PopupAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('popupAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type PopupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PopupAnnot(id);
		});
	},

		PDFNet.PopupAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('popupAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type PopupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PopupAnnot(id);
		});
	},

		PDFNet.PopupAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('popupAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type PopupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.PopupAnnot(id);
		});
	},

		PDFNet.PopupAnnot.prototype.getParent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParent'. Expected "+0+" arguments. Function Signature: getParent()")};
		return PDFNet.messageHandler.sendWithPromise('PopupAnnot.getParent', {"popup": this.id}, this.userPriority).then(function(id){
			//there is a return type Annot
			if(id == "0"){
				return null;
			}
			return new PDFNet.Annot(id);
		});
	},

		PDFNet.PopupAnnot.prototype.setParent = function(parent)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setParent'. Expected "+1+" argument. Function Signature: setParent(Annot)")};
		if(parent instanceof Promise) {throw new TypeError("1st input argument in function 'setParent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(parent instanceof PDFNet.Annot)) {
			if(typeof parent == "object") {throw new TypeError("1st input argument in function 'setParent' is of type '"+parent.name+"'. Expected type 'Annot'. Function Signature: setParent(Annot).");}
			else {throw new TypeError("1st input argument '"+parent+"' in function 'setParent' is of type '"+(typeof parent)+"'. Expected type 'Annot'. Function Signature: setParent(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PopupAnnot.setParent', {"popup": this.id, "parent": parent.id}, this.userPriority);
	},

		PDFNet.PopupAnnot.prototype.isOpen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isOpen'. Expected "+0+" arguments. Function Signature: isOpen()")};
		return PDFNet.messageHandler.sendWithPromise('PopupAnnot.isOpen', {"popup": this.id}, this.userPriority);
	},

		PDFNet.PopupAnnot.prototype.setOpen = function(closeono)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpen'. Expected "+1+" argument. Function Signature: setOpen(boolean)")};
		if(closeono instanceof Promise) {throw new TypeError("1st input argument in function 'setOpen' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof closeono != "boolean") {throw new TypeError("1st input argument '"+closeono+"' in function 'setOpen' is of type '"+(typeof closeono)+"'. Expected type 'boolean'. Function Signature: setOpen(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PopupAnnot.setOpen', {"popup": this.id, "closeono": closeono}, this.userPriority);
	},

		PDFNet.RedactionAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('redactionAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type RedactionAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RedactionAnnot(id);
		});
	},

		PDFNet.RedactionAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('redactionAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type RedactionAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RedactionAnnot(id);
		});
	},

		PDFNet.RedactionAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('redactionAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type RedactionAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RedactionAnnot(id);
		});
	},

		PDFNet.RedactionAnnot.prototype.getQuadPointCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPointCount'. Expected "+0+" arguments. Function Signature: getQuadPointCount()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getQuadPointCount', {"redaction": this.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getQuadPoint = function(idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPoint'. Expected "+1+" argument. Function Signature: getQuadPoint(number)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'getQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'getQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: getQuadPoint(number).");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getQuadPoint', {"redaction": this.id, "idx": idx}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setQuadPoint = function(idx, qp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setQuadPoint'. Expected "+2+" arguments. Function Signature: setQuadPoint(number, QuadPoint)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'setQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: setQuadPoint(number, QuadPoint).");}
		if(qp instanceof Promise) {throw new TypeError("2nd input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(qp instanceof PDFNet.QuadPoint) && qp.name != "QuadPoint") {
			if(typeof qp == "object") {throw new TypeError("2nd input argument in function 'setQuadPoint' is of type '"+qp.name+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
			else {throw new TypeError("2nd input argument '"+qp+"' in function 'setQuadPoint' is of type '"+(typeof qp)+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
		}
		if(typeof qp.yieldFunction != "undefined") {throw new Error("Function '"+qp.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setQuadPoint'. Perhaps a yield statement is required for '"+qp.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setQuadPoint', {"redaction": this.id, "idx": idx, "qp": qp}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setAppFormXO = function(formxo)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAppFormXO'. Expected "+1+" argument. Function Signature: setAppFormXO(Obj)")};
		if(formxo instanceof Promise) {throw new TypeError("1st input argument in function 'setAppFormXO' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(formxo instanceof PDFNet.Obj)) {
			if(typeof formxo == "object") {throw new TypeError("1st input argument in function 'setAppFormXO' is of type '"+formxo.name+"'. Expected type 'Obj'. Function Signature: setAppFormXO(Obj).");}
			else {throw new TypeError("1st input argument '"+formxo+"' in function 'setAppFormXO' is of type '"+(typeof formxo)+"'. Expected type 'Obj'. Function Signature: setAppFormXO(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setAppFormXO', {"redaction": this.id, "formxo": formxo.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getOverlayText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOverlayText'. Expected "+0+" arguments. Function Signature: getOverlayText()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getOverlayText', {"redaction": this.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setOverlayText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOverlayText'. Expected "+1+" argument. Function Signature: setOverlayText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setOverlayText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setOverlayText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setOverlayText(string).");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setOverlayText', {"redaction": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getUseRepeat = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUseRepeat'. Expected "+0+" arguments. Function Signature: getUseRepeat()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getUseRepeat', {"redaction": this.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setUseRepeat = function(closeono)
	{
		if(typeof closeono === "undefined") {closeono = false;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUseRepeat'. Expected at most "+1+" arguments. Function Signature: setUseRepeat(boolean)")};
		if(closeono instanceof Promise) {throw new TypeError("1st input argument in function 'setUseRepeat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof closeono != "boolean") {throw new TypeError("1st input argument '"+closeono+"' in function 'setUseRepeat' is of type '"+(typeof closeono)+"'. Expected type 'boolean'. Function Signature: setUseRepeat(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setUseRepeat', {"redaction": this.id, "closeono": closeono}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getOverlayTextAppearance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOverlayTextAppearance'. Expected "+0+" arguments. Function Signature: getOverlayTextAppearance()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getOverlayTextAppearance', {"redaction": this.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setOverlayTextAppearance = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOverlayTextAppearance'. Expected "+1+" argument. Function Signature: setOverlayTextAppearance(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setOverlayTextAppearance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setOverlayTextAppearance' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setOverlayTextAppearance(string).");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setOverlayTextAppearance', {"redaction": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getQuadForm = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadForm'. Expected "+0+" arguments. Function Signature: getQuadForm()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getQuadForm', {"redaction": this.id}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.setQuadForm = function(style)
	{
		if(typeof style === "undefined") {style = exports.PDFNet.RedactionAnnot.QuadForm.e_LeftJustified};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setQuadForm'. Expected at most "+1+" arguments. Function Signature: setQuadForm(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setQuadForm' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setQuadForm' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setQuadForm(number).");}
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.setQuadForm', {"redaction": this.id, "style": style}, this.userPriority);
	},

		PDFNet.RedactionAnnot.prototype.getAppFormXO = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAppFormXO'. Expected "+0+" arguments. Function Signature: getAppFormXO()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAnnot.getAppFormXO', {"redaction": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.RubberStampAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('rubberStampAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type RubberStampAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RubberStampAnnot(id);
		});
	},

		PDFNet.RubberStampAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('rubberStampAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type RubberStampAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RubberStampAnnot(id);
		});
	},

		PDFNet.RubberStampAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('rubberStampAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type RubberStampAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.RubberStampAnnot(id);
		});
	},

		PDFNet.RubberStampAnnot.prototype.getIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIcon'. Expected "+0+" arguments. Function Signature: getIcon()")};
		return PDFNet.messageHandler.sendWithPromise('RubberStampAnnot.getIcon', {"stamp": this.id}, this.userPriority);
	},

		PDFNet.RubberStampAnnot.prototype.setIcon = function(style)
	{
		if(typeof style === "undefined") {style = exports.PDFNet.RubberStampAnnot.Icon.e_Draft};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIcon'. Expected at most "+1+" arguments. Function Signature: setIcon(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setIcon' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setIcon(number).");}
		return PDFNet.messageHandler.sendWithPromise('RubberStampAnnot.setIcon', {"stamp": this.id, "style": style}, this.userPriority);
	},

		PDFNet.RubberStampAnnot.prototype.setIconDefault = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'setIconDefault'. Expected "+0+" arguments. Function Signature: setIconDefault()")};
		return PDFNet.messageHandler.sendWithPromise('RubberStampAnnot.setIconDefault', {"stamp": this.id}, this.userPriority);
	},

		PDFNet.RubberStampAnnot.prototype.getIconName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconName'. Expected "+0+" arguments. Function Signature: getIconName()")};
		return PDFNet.messageHandler.sendWithPromise('RubberStampAnnot.getIconName', {"stamp": this.id}, this.userPriority);
	},

		PDFNet.RubberStampAnnot.prototype.setIconName = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconName'. Expected "+1+" argument. Function Signature: setIconName(string)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIconName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "string") {throw new TypeError("1st input argument '"+style+"' in function 'setIconName' is of type '"+(typeof style)+"'. Expected type 'string'. Function Signature: setIconName(string).");}
		return PDFNet.messageHandler.sendWithPromise('RubberStampAnnot.setIconName', {"stamp": this.id, "style": style}, this.userPriority);
	},

		PDFNet.ScreenAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('screenAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type ScreenAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.ScreenAnnot(id);
		});
	},

		PDFNet.ScreenAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('screenAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type ScreenAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.ScreenAnnot(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getTitle', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setTitle = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitle'. Expected "+1+" argument. Function Signature: setTitle(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setTitle' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setTitle(string).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setTitle', {"s": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.ScreenAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('screenAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type ScreenAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.ScreenAnnot(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.getAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAction'. Expected "+0+" arguments. Function Signature: getAction()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getAction', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAction'. Expected "+1+" argument. Function Signature: setAction(Action)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Action)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setAction' is of type '"+action.name+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setAction' is of type '"+(typeof action)+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setAction', {"s": this.id, "action": action.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getTriggerAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTriggerAction'. Expected "+0+" arguments. Function Signature: getTriggerAction()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getTriggerAction', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setTriggerAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTriggerAction'. Expected "+1+" argument. Function Signature: setTriggerAction(Obj)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setTriggerAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Obj)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setTriggerAction' is of type '"+action.name+"'. Expected type 'Obj'. Function Signature: setTriggerAction(Obj).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setTriggerAction' is of type '"+(typeof action)+"'. Expected type 'Obj'. Function Signature: setTriggerAction(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setTriggerAction', {"s": this.id, "action": action.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getBorderColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderColor'. Expected "+0+" arguments. Function Signature: getBorderColor()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getBorderColor', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setBorderColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderColor'. Expected "+2+" arguments. Function Signature: setBorderColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setBorderColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setBorderColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setBorderColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setBorderColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setBorderColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setBorderColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setBorderColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setBorderColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setBorderColor', {"s": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getBorderColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderColorCompNum'. Expected "+0+" arguments. Function Signature: getBorderColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getBorderColorCompNum', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getBackgroundColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBackgroundColorCompNum'. Expected "+0+" arguments. Function Signature: getBackgroundColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getBackgroundColorCompNum', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getBackgroundColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBackgroundColor'. Expected "+0+" arguments. Function Signature: getBackgroundColor()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getBackgroundColor', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setBackgroundColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBackgroundColor'. Expected "+2+" arguments. Function Signature: setBackgroundColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setBackgroundColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setBackgroundColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setBackgroundColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setBackgroundColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setBackgroundColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setBackgroundColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setBackgroundColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setBackgroundColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setBackgroundColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setBackgroundColor', {"s": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getStaticCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStaticCaptionText'. Expected "+0+" arguments. Function Signature: getStaticCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getStaticCaptionText', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setStaticCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStaticCaptionText'. Expected "+1+" argument. Function Signature: setStaticCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setStaticCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setStaticCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setStaticCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setStaticCaptionText', {"s": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getRolloverCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRolloverCaptionText'. Expected "+0+" arguments. Function Signature: getRolloverCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getRolloverCaptionText', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setRolloverCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRolloverCaptionText'. Expected "+1+" argument. Function Signature: setRolloverCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setRolloverCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setRolloverCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setRolloverCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setRolloverCaptionText', {"s": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getMouseDownCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMouseDownCaptionText'. Expected "+0+" arguments. Function Signature: getMouseDownCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getMouseDownCaptionText', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setMouseDownCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMouseDownCaptionText'. Expected "+1+" argument. Function Signature: setMouseDownCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setMouseDownCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setMouseDownCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setMouseDownCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setMouseDownCaptionText', {"s": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getStaticIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStaticIcon'. Expected "+0+" arguments. Function Signature: getStaticIcon()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getStaticIcon', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setStaticIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStaticIcon'. Expected "+1+" argument. Function Signature: setStaticIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setStaticIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setStaticIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setStaticIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setStaticIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setStaticIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setStaticIcon', {"s": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getRolloverIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRolloverIcon'. Expected "+0+" arguments. Function Signature: getRolloverIcon()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getRolloverIcon', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setRolloverIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRolloverIcon'. Expected "+1+" argument. Function Signature: setRolloverIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setRolloverIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setRolloverIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setRolloverIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setRolloverIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setRolloverIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setRolloverIcon', {"s": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getMouseDownIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMouseDownIcon'. Expected "+0+" arguments. Function Signature: getMouseDownIcon()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getMouseDownIcon', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ScreenAnnot.prototype.setMouseDownIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMouseDownIcon'. Expected "+1+" argument. Function Signature: setMouseDownIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setMouseDownIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setMouseDownIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setMouseDownIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setMouseDownIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setMouseDownIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setMouseDownIcon', {"s": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getScaleType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getScaleType'. Expected "+0+" arguments. Function Signature: getScaleType()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getScaleType', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setScaleType = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setScaleType'. Expected "+1+" argument. Function Signature: setScaleType(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setScaleType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setScaleType' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setScaleType(number).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setScaleType', {"s": this.id, "style": style}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getIconCaptionRelation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconCaptionRelation'. Expected "+0+" arguments. Function Signature: getIconCaptionRelation()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getIconCaptionRelation', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setIconCaptionRelation = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconCaptionRelation'. Expected "+1+" argument. Function Signature: setIconCaptionRelation(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIconCaptionRelation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setIconCaptionRelation' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setIconCaptionRelation(number).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setIconCaptionRelation', {"s": this.id, "style": style}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getScaleCondition = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getScaleCondition'. Expected "+0+" arguments. Function Signature: getScaleCondition()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getScaleCondition', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setScaleCondition = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setScaleCondition'. Expected "+1+" argument. Function Signature: setScaleCondition(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setScaleCondition' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setScaleCondition' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setScaleCondition(number).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setScaleCondition', {"s": this.id, "style": style}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getFitFull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFitFull'. Expected "+0+" arguments. Function Signature: getFitFull()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getFitFull', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setFitFull = function(ff)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFitFull'. Expected "+1+" argument. Function Signature: setFitFull(boolean)")};
		if(ff instanceof Promise) {throw new TypeError("1st input argument in function 'setFitFull' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ff != "boolean") {throw new TypeError("1st input argument '"+ff+"' in function 'setFitFull' is of type '"+(typeof ff)+"'. Expected type 'boolean'. Function Signature: setFitFull(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setFitFull', {"s": this.id, "ff": ff}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getHIconLeftOver = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHIconLeftOver'. Expected "+0+" arguments. Function Signature: getHIconLeftOver()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getHIconLeftOver', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setHIconLeftOver = function(hl)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHIconLeftOver'. Expected "+1+" argument. Function Signature: setHIconLeftOver(number)")};
		if(hl instanceof Promise) {throw new TypeError("1st input argument in function 'setHIconLeftOver' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hl != "number") {throw new TypeError("1st input argument '"+hl+"' in function 'setHIconLeftOver' is of type '"+(typeof hl)+"'. Expected type 'number'. Function Signature: setHIconLeftOver(number).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setHIconLeftOver', {"s": this.id, "hl": hl}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.getVIconLeftOver = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVIconLeftOver'. Expected "+0+" arguments. Function Signature: getVIconLeftOver()")};
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.getVIconLeftOver', {"s": this.id}, this.userPriority);
	},

		PDFNet.ScreenAnnot.prototype.setVIconLeftOver = function(vl)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setVIconLeftOver'. Expected "+1+" argument. Function Signature: setVIconLeftOver(number)")};
		if(vl instanceof Promise) {throw new TypeError("1st input argument in function 'setVIconLeftOver' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vl != "number") {throw new TypeError("1st input argument '"+vl+"' in function 'setVIconLeftOver' is of type '"+(typeof vl)+"'. Expected type 'number'. Function Signature: setVIconLeftOver(number).");}
		return PDFNet.messageHandler.sendWithPromise('ScreenAnnot.setVIconLeftOver', {"s": this.id, "vl": vl}, this.userPriority);
	},

		PDFNet.SoundAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('soundAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type SoundAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SoundAnnot(id);
		});
	},

		PDFNet.SoundAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('soundAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type SoundAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SoundAnnot(id);
		});
	},

		PDFNet.SoundAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('soundAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type SoundAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SoundAnnot(id);
		});
	},

		PDFNet.SoundAnnot.createAtPoint = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createAtPoint'. Expected "+2+" arguments. Function Signature: createAtPoint(SDFDoc, Point)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createAtPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createAtPoint' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createAtPoint(SDFDoc, Point).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createAtPoint' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createAtPoint(SDFDoc, Point).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'createAtPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Point) && pos.name != "Point") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'createAtPoint' is of type '"+pos.name+"'. Expected type 'Point'. Function Signature: createAtPoint(SDFDoc, Point).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'createAtPoint' is of type '"+(typeof pos)+"'. Expected type 'Point'. Function Signature: createAtPoint(SDFDoc, Point).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createAtPoint'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('soundAnnotCreateAtPoint', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type SoundAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SoundAnnot(id);
		});
	},

		PDFNet.SoundAnnot.prototype.getSoundStream = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSoundStream'. Expected "+0+" arguments. Function Signature: getSoundStream()")};
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.getSoundStream', {"sound": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SoundAnnot.prototype.setSoundStream = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSoundStream'. Expected "+1+" argument. Function Signature: setSoundStream(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setSoundStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setSoundStream' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setSoundStream(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setSoundStream' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setSoundStream(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.setSoundStream', {"sound": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.SoundAnnot.prototype.getIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIcon'. Expected "+0+" arguments. Function Signature: getIcon()")};
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.getIcon', {"sound": this.id}, this.userPriority);
	},

		PDFNet.SoundAnnot.prototype.setIcon = function(style)
	{
		if(typeof style === "undefined") {style = exports.PDFNet.SoundAnnot.Icon.e_Speaker};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIcon'. Expected at most "+1+" arguments. Function Signature: setIcon(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setIcon' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setIcon(number).");}
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.setIcon', {"sound": this.id, "style": style}, this.userPriority);
	},

		PDFNet.SoundAnnot.prototype.getIconName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconName'. Expected "+0+" arguments. Function Signature: getIconName()")};
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.getIconName', {"sound": this.id}, this.userPriority);
	},

		PDFNet.SoundAnnot.prototype.setIconName = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconName'. Expected "+1+" argument. Function Signature: setIconName(string)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIconName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "string") {throw new TypeError("1st input argument '"+style+"' in function 'setIconName' is of type '"+(typeof style)+"'. Expected type 'string'. Function Signature: setIconName(string).");}
		return PDFNet.messageHandler.sendWithPromise('SoundAnnot.setIconName', {"sound": this.id, "style": style}, this.userPriority);
	},

		PDFNet.SquareAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('squareAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type SquareAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquareAnnot(id);
		});
	},

		PDFNet.SquareAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('squareAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type SquareAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquareAnnot(id);
		});
	},

		PDFNet.SquareAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('squareAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type SquareAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquareAnnot(id);
		});
	},

		PDFNet.SquareAnnot.prototype.getInteriorColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColor'. Expected "+0+" arguments. Function Signature: getInteriorColor()")};
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.getInteriorColor', {"square": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.SquareAnnot.prototype.getInteriorColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInteriorColorCompNum'. Expected "+0+" arguments. Function Signature: getInteriorColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.getInteriorColorCompNum', {"square": this.id}, this.userPriority);
	},

		PDFNet.SquareAnnot.prototype.setInteriorColorDefault = function(col)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColorDefault'. Expected "+1+" argument. Function Signature: setInteriorColorDefault(ColorPt)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColorDefault' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColorDefault' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorDefault(ColorPt).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColorDefault' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColorDefault(ColorPt).");}
		}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColorDefault'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.setInteriorColorDefault', {"square": this.id, "col": col.id}, this.userPriority);
	},

		PDFNet.SquareAnnot.prototype.setInteriorColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setInteriorColor'. Expected "+2+" arguments. Function Signature: setInteriorColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setInteriorColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setInteriorColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setInteriorColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setInteriorColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setInteriorColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setInteriorColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setInteriorColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.setInteriorColor', {"square": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.SquareAnnot.prototype.getContentRect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getContentRect'. Expected "+0+" arguments. Function Signature: getContentRect()")};
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.getContentRect', {"square": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.SquareAnnot.prototype.setContentRect = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setContentRect'. Expected "+1+" argument. Function Signature: setContentRect(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setContentRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setContentRect' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setContentRect' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setContentRect(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setContentRect'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.setContentRect', {"square": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.SquareAnnot.prototype.getPadding = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPadding'. Expected "+0+" arguments. Function Signature: getPadding()")};
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.getPadding', {"square": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.SquareAnnot.prototype.setPadding = function(cr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPadding'. Expected "+1+" argument. Function Signature: setPadding(Rect)")};
		if(cr instanceof Promise) {throw new TypeError("1st input argument in function 'setPadding' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cr instanceof PDFNet.Rect) && cr.name != "Rect") {
			if(typeof cr == "object") {throw new TypeError("1st input argument in function 'setPadding' is of type '"+cr.name+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
			else {throw new TypeError("1st input argument '"+cr+"' in function 'setPadding' is of type '"+(typeof cr)+"'. Expected type 'Rect'. Function Signature: setPadding(Rect).");}
		}
		if(typeof cr.yieldFunction != "undefined") {throw new Error("Function '"+cr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setPadding'. Perhaps a yield statement is required for '"+cr.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('SquareAnnot.setPadding', {"square": this.id, "cr": cr}, this.userPriority);
	},

		PDFNet.SquigglyAnnot.createFromObj = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('squigglyAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type SquigglyAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquigglyAnnot(id);
		});
	},

		PDFNet.SquigglyAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('squigglyAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type SquigglyAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquigglyAnnot(id);
		});
	},

		PDFNet.SquigglyAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('squigglyAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type SquigglyAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.SquigglyAnnot(id);
		});
	},

		PDFNet.StrikeOutAnnot.createFromObj = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('strikeOutAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type StrikeOutAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.StrikeOutAnnot(id);
		});
	},

		PDFNet.StrikeOutAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('strikeOutAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type StrikeOutAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.StrikeOutAnnot(id);
		});
	},

		PDFNet.StrikeOutAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('strikeOutAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type StrikeOutAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.StrikeOutAnnot(id);
		});
	},

		PDFNet.TextAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('textAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type TextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextAnnot(id);
		});
	},

		PDFNet.TextAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('textAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type TextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextAnnot(id);
		});
	},

		PDFNet.TextAnnot.createAtPoint = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createAtPoint'. Expected "+2+" arguments. Function Signature: createAtPoint(SDFDoc, Point)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createAtPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createAtPoint' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createAtPoint(SDFDoc, Point).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createAtPoint' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createAtPoint(SDFDoc, Point).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'createAtPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Point) && pos.name != "Point") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'createAtPoint' is of type '"+pos.name+"'. Expected type 'Point'. Function Signature: createAtPoint(SDFDoc, Point).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'createAtPoint' is of type '"+(typeof pos)+"'. Expected type 'Point'. Function Signature: createAtPoint(SDFDoc, Point).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createAtPoint'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('textAnnotCreateAtPoint', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type TextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextAnnot(id);
		});
	},

		PDFNet.TextAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('textAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type TextAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextAnnot(id);
		});
	},

		PDFNet.TextAnnot.prototype.isOpen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isOpen'. Expected "+0+" arguments. Function Signature: isOpen()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.isOpen', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setOpen = function(closeono)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpen'. Expected "+1+" argument. Function Signature: setOpen(boolean)")};
		if(closeono instanceof Promise) {throw new TypeError("1st input argument in function 'setOpen' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof closeono != "boolean") {throw new TypeError("1st input argument '"+closeono+"' in function 'setOpen' is of type '"+(typeof closeono)+"'. Expected type 'boolean'. Function Signature: setOpen(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setOpen', {"text": this.id, "closeono": closeono}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.getIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIcon'. Expected "+0+" arguments. Function Signature: getIcon()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.getIcon', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setIcon = function(icon)
	{
		if(typeof icon === "undefined") {icon = exports.PDFNet.TextAnnot.Icon.e_Note};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIcon'. Expected at most "+1+" arguments. Function Signature: setIcon(number)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof icon != "number") {throw new TypeError("1st input argument '"+icon+"' in function 'setIcon' is of type '"+(typeof icon)+"'. Expected type 'number'. Function Signature: setIcon(number).");}
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setIcon', {"text": this.id, "icon": icon}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setIconDefault = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'setIconDefault'. Expected "+0+" arguments. Function Signature: setIconDefault()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setIconDefault', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.getIconName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconName'. Expected "+0+" arguments. Function Signature: getIconName()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.getIconName', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setIconName = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconName'. Expected "+1+" argument. Function Signature: setIconName(string)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIconName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "string") {throw new TypeError("1st input argument '"+style+"' in function 'setIconName' is of type '"+(typeof style)+"'. Expected type 'string'. Function Signature: setIconName(string).");}
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setIconName', {"text": this.id, "style": style}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.getState = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getState'. Expected "+0+" arguments. Function Signature: getState()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.getState', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setState = function(contents)
	{
		if(typeof contents === "undefined") {contents = "";};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setState'. Expected at most "+1+" arguments. Function Signature: setState(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setState' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setState(string).");}
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setState', {"text": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.getStateModel = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStateModel'. Expected "+0+" arguments. Function Signature: getStateModel()")};
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.getStateModel', {"text": this.id}, this.userPriority);
	},

		PDFNet.TextAnnot.prototype.setStateModel = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStateModel'. Expected "+1+" argument. Function Signature: setStateModel(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setStateModel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setStateModel' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setStateModel(string).");}
		return PDFNet.messageHandler.sendWithPromise('TextAnnot.setStateModel', {"text": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.UnderlineAnnot.createFromObj = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('underlineAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type UnderlineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.UnderlineAnnot(id);
		});
	},

		PDFNet.UnderlineAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('underlineAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type UnderlineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.UnderlineAnnot(id);
		});
	},

		PDFNet.UnderlineAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('underlineAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type UnderlineAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.UnderlineAnnot(id);
		});
	},

		PDFNet.WatermarkAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('watermarkAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type WatermarkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.WatermarkAnnot(id);
		});
	},

		PDFNet.WatermarkAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('watermarkAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type WatermarkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.WatermarkAnnot(id);
		});
	},

		PDFNet.WatermarkAnnot.create = function(doc, pos)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, Rect)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('watermarkAnnotCreate', {"doc": doc.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type WatermarkAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.WatermarkAnnot(id);
		});
	},

		PDFNet.TextMarkupAnnot.createFromObj = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('textMarkupAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type TextMarkupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextMarkupAnnot(id);
		});
	},

		PDFNet.TextMarkupAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('textMarkupAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type TextMarkupAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextMarkupAnnot(id);
		});
	},

		PDFNet.TextMarkupAnnot.prototype.getQuadPointCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPointCount'. Expected "+0+" arguments. Function Signature: getQuadPointCount()")};
		return PDFNet.messageHandler.sendWithPromise('TextMarkupAnnot.getQuadPointCount', {"textmarkup": this.id}, this.userPriority);
	},

		PDFNet.TextMarkupAnnot.prototype.getQuadPoint = function(idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getQuadPoint'. Expected "+1+" argument. Function Signature: getQuadPoint(number)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'getQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'getQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: getQuadPoint(number).");}
		return PDFNet.messageHandler.sendWithPromise('TextMarkupAnnot.getQuadPoint', {"textmarkup": this.id, "idx": idx}, this.userPriority);
	},

		PDFNet.TextMarkupAnnot.prototype.setQuadPoint = function(idx, qp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setQuadPoint'. Expected "+2+" arguments. Function Signature: setQuadPoint(number, QuadPoint)")};
		if(idx instanceof Promise) {throw new TypeError("1st input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof idx != "number") {throw new TypeError("1st input argument '"+idx+"' in function 'setQuadPoint' is of type '"+(typeof idx)+"'. Expected type 'number'. Function Signature: setQuadPoint(number, QuadPoint).");}
		if(qp instanceof Promise) {throw new TypeError("2nd input argument in function 'setQuadPoint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(qp instanceof PDFNet.QuadPoint) && qp.name != "QuadPoint") {
			if(typeof qp == "object") {throw new TypeError("2nd input argument in function 'setQuadPoint' is of type '"+qp.name+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
			else {throw new TypeError("2nd input argument '"+qp+"' in function 'setQuadPoint' is of type '"+(typeof qp)+"'. Expected type 'QuadPoint'. Function Signature: setQuadPoint(number, QuadPoint).");}
		}
		if(typeof qp.yieldFunction != "undefined") {throw new Error("Function '"+qp.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setQuadPoint'. Perhaps a yield statement is required for '"+qp.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('TextMarkupAnnot.setQuadPoint', {"textmarkup": this.id, "idx": idx, "qp": qp}, this.userPriority);
	},

		PDFNet.WidgetAnnot.create = function(doc, pos, fd)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+3+" arguments. Function Signature: create(SDFDoc, Rect, Field)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect, Field).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, Rect, Field).");}
		}
		if(pos instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.Rect) && pos.name != "Rect") {
			if(typeof pos == "object") {throw new TypeError("2nd input argument in function 'create' is of type '"+pos.name+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect, Field).");}
			else {throw new TypeError("2nd input argument '"+pos+"' in function 'create' is of type '"+(typeof pos)+"'. Expected type 'Rect'. Function Signature: create(SDFDoc, Rect, Field).");}
		}
		if(fd instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(fd instanceof PDFNet.Field) && fd.name != "Field") {
			if(typeof fd == "object") {throw new TypeError("3rd input argument in function 'create' is of type '"+fd.name+"'. Expected type 'Field'. Function Signature: create(SDFDoc, Rect, Field).");}
			else {throw new TypeError("3rd input argument '"+fd+"' in function 'create' is of type '"+(typeof fd)+"'. Expected type 'Field'. Function Signature: create(SDFDoc, Rect, Field).");}
		}
		if(typeof pos.yieldFunction != "undefined") {throw new Error("Function '"+pos.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'create'. Perhaps a yield statement is required for '"+pos.yieldFunction+"'?");}
		if(typeof fd.yieldFunction != "undefined") {throw new Error("Function '"+fd.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'create'. Perhaps a yield statement is required for '"+fd.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "WidgetAnnot.create"; // TRN_Field* fd
		return PDFNet.messageHandler.sendWithPromise('widgetAnnotCreate', {"doc": doc.id, "pos": pos, "fd": fd}, this.userPriority).then(function(id){
			//there is a return type WidgetAnnot
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.fd, me);
			me.yieldFunction = undefined;
			return new PDFNet.WidgetAnnot(id.result);
		});
	},

		PDFNet.WidgetAnnot.createFromObj = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'createFromObj' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('widgetAnnotCreateFromObj', {"d": d.id}, this.userPriority).then(function(id){
			//there is a return type WidgetAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.WidgetAnnot(id);
		});
	},

		PDFNet.WidgetAnnot.createFromAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromAnnot'. Expected "+1+" argument. Function Signature: createFromAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'createFromAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'createFromAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'createFromAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: createFromAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('widgetAnnotCreateFromAnnot', {"annot": annot.id}, this.userPriority).then(function(id){
			//there is a return type WidgetAnnot
			if(id == "0"){
				return null;
			}
			return new PDFNet.WidgetAnnot(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.getField = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getField'. Expected "+0+" arguments. Function Signature: getField()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getField', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Field
			if(id == "0"){
				return null;
			}
			return new PDFNet.Field(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.getHighlightingMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHighlightingMode'. Expected "+0+" arguments. Function Signature: getHighlightingMode()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getHighlightingMode', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setHighlightingMode = function(value)
	{
		if(typeof value === "undefined") {value = exports.PDFNet.WidgetAnnot.HighlightingMode.e_invert};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHighlightingMode'. Expected at most "+1+" arguments. Function Signature: setHighlightingMode(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setHighlightingMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'setHighlightingMode' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: setHighlightingMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setHighlightingMode', {"widget": this.id, "value": value}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAction'. Expected "+0+" arguments. Function Signature: getAction()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getAction', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAction'. Expected "+1+" argument. Function Signature: setAction(Action)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Action)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setAction' is of type '"+action.name+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setAction' is of type '"+(typeof action)+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setAction', {"widget": this.id, "action": action.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getTriggerAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTriggerAction'. Expected "+0+" arguments. Function Signature: getTriggerAction()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getTriggerAction', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setTriggerAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTriggerAction'. Expected "+1+" argument. Function Signature: setTriggerAction(Obj)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setTriggerAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Obj)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setTriggerAction' is of type '"+action.name+"'. Expected type 'Obj'. Function Signature: setTriggerAction(Obj).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setTriggerAction' is of type '"+(typeof action)+"'. Expected type 'Obj'. Function Signature: setTriggerAction(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setTriggerAction', {"widget": this.id, "action": action.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getBorderColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderColor'. Expected "+0+" arguments. Function Signature: getBorderColor()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getBorderColor', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setBorderColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBorderColor'. Expected "+2+" arguments. Function Signature: setBorderColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setBorderColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setBorderColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setBorderColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setBorderColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setBorderColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setBorderColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setBorderColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setBorderColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setBorderColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setBorderColor', {"widget": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getBorderColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBorderColorCompNum'. Expected "+0+" arguments. Function Signature: getBorderColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getBorderColorCompNum', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getBackgroundColorCompNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBackgroundColorCompNum'. Expected "+0+" arguments. Function Signature: getBackgroundColorCompNum()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getBackgroundColorCompNum', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getBackgroundColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBackgroundColor'. Expected "+0+" arguments. Function Signature: getBackgroundColor()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getBackgroundColor', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setBackgroundColor = function(col, numcomp)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setBackgroundColor'. Expected "+2+" arguments. Function Signature: setBackgroundColor(ColorPt, number)")};
		if(col instanceof Promise) {throw new TypeError("1st input argument in function 'setBackgroundColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(col instanceof PDFNet.ColorPt) && col.name != "ColorPt") {
			if(typeof col == "object") {throw new TypeError("1st input argument in function 'setBackgroundColor' is of type '"+col.name+"'. Expected type 'ColorPt'. Function Signature: setBackgroundColor(ColorPt, number).");}
			else {throw new TypeError("1st input argument '"+col+"' in function 'setBackgroundColor' is of type '"+(typeof col)+"'. Expected type 'ColorPt'. Function Signature: setBackgroundColor(ColorPt, number).");}
		}
		if(numcomp instanceof Promise) {throw new TypeError("2nd input argument in function 'setBackgroundColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof numcomp != "number") {throw new TypeError("2nd input argument '"+numcomp+"' in function 'setBackgroundColor' is of type '"+(typeof numcomp)+"'. Expected type 'number'. Function Signature: setBackgroundColor(ColorPt, number).");}
		if(typeof col.yieldFunction != "undefined") {throw new Error("Function '"+col.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setBackgroundColor'. Perhaps a yield statement is required for '"+col.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setBackgroundColor', {"widget": this.id, "col": col.id, "numcomp": numcomp}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getStaticCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStaticCaptionText'. Expected "+0+" arguments. Function Signature: getStaticCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getStaticCaptionText', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setStaticCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStaticCaptionText'. Expected "+1+" argument. Function Signature: setStaticCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setStaticCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setStaticCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setStaticCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setStaticCaptionText', {"widget": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getRolloverCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRolloverCaptionText'. Expected "+0+" arguments. Function Signature: getRolloverCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getRolloverCaptionText', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setRolloverCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRolloverCaptionText'. Expected "+1+" argument. Function Signature: setRolloverCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setRolloverCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setRolloverCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setRolloverCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setRolloverCaptionText', {"widget": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getMouseDownCaptionText = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMouseDownCaptionText'. Expected "+0+" arguments. Function Signature: getMouseDownCaptionText()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getMouseDownCaptionText', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setMouseDownCaptionText = function(contents)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMouseDownCaptionText'. Expected "+1+" argument. Function Signature: setMouseDownCaptionText(string)")};
		if(contents instanceof Promise) {throw new TypeError("1st input argument in function 'setMouseDownCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof contents != "string") {throw new TypeError("1st input argument '"+contents+"' in function 'setMouseDownCaptionText' is of type '"+(typeof contents)+"'. Expected type 'string'. Function Signature: setMouseDownCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setMouseDownCaptionText', {"widget": this.id, "contents": contents}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getStaticIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStaticIcon'. Expected "+0+" arguments. Function Signature: getStaticIcon()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getStaticIcon', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setStaticIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStaticIcon'. Expected "+1+" argument. Function Signature: setStaticIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setStaticIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setStaticIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setStaticIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setStaticIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setStaticIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setStaticIcon', {"widget": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getRolloverIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRolloverIcon'. Expected "+0+" arguments. Function Signature: getRolloverIcon()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getRolloverIcon', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setRolloverIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRolloverIcon'. Expected "+1+" argument. Function Signature: setRolloverIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setRolloverIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setRolloverIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setRolloverIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setRolloverIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setRolloverIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setRolloverIcon', {"widget": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getMouseDownIcon = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMouseDownIcon'. Expected "+0+" arguments. Function Signature: getMouseDownIcon()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getMouseDownIcon', {"widget": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.WidgetAnnot.prototype.setMouseDownIcon = function(icon)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMouseDownIcon'. Expected "+1+" argument. Function Signature: setMouseDownIcon(Obj)")};
		if(icon instanceof Promise) {throw new TypeError("1st input argument in function 'setMouseDownIcon' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(icon instanceof PDFNet.Obj)) {
			if(typeof icon == "object") {throw new TypeError("1st input argument in function 'setMouseDownIcon' is of type '"+icon.name+"'. Expected type 'Obj'. Function Signature: setMouseDownIcon(Obj).");}
			else {throw new TypeError("1st input argument '"+icon+"' in function 'setMouseDownIcon' is of type '"+(typeof icon)+"'. Expected type 'Obj'. Function Signature: setMouseDownIcon(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setMouseDownIcon', {"widget": this.id, "icon": icon.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getScaleType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getScaleType'. Expected "+0+" arguments. Function Signature: getScaleType()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getScaleType', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setScaleType = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setScaleType'. Expected "+1+" argument. Function Signature: setScaleType(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setScaleType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setScaleType' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setScaleType(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setScaleType', {"widget": this.id, "style": style}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getIconCaptionRelation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIconCaptionRelation'. Expected "+0+" arguments. Function Signature: getIconCaptionRelation()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getIconCaptionRelation', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setIconCaptionRelation = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIconCaptionRelation'. Expected "+1+" argument. Function Signature: setIconCaptionRelation(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setIconCaptionRelation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setIconCaptionRelation' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setIconCaptionRelation(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setIconCaptionRelation', {"widget": this.id, "style": style}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getScaleCondition = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getScaleCondition'. Expected "+0+" arguments. Function Signature: getScaleCondition()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getScaleCondition', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setScaleCondition = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setScaleCondition'. Expected "+1+" argument. Function Signature: setScaleCondition(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setScaleCondition' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setScaleCondition' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setScaleCondition(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setScaleCondition', {"widget": this.id, "style": style}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getFitFull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFitFull'. Expected "+0+" arguments. Function Signature: getFitFull()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getFitFull', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setFitFull = function(ff)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFitFull'. Expected "+1+" argument. Function Signature: setFitFull(boolean)")};
		if(ff instanceof Promise) {throw new TypeError("1st input argument in function 'setFitFull' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ff != "boolean") {throw new TypeError("1st input argument '"+ff+"' in function 'setFitFull' is of type '"+(typeof ff)+"'. Expected type 'boolean'. Function Signature: setFitFull(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setFitFull', {"widget": this.id, "ff": ff}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getHIconLeftOver = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHIconLeftOver'. Expected "+0+" arguments. Function Signature: getHIconLeftOver()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getHIconLeftOver', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setHIconLeftOver = function(hl)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHIconLeftOver'. Expected "+1+" argument. Function Signature: setHIconLeftOver(number)")};
		if(hl instanceof Promise) {throw new TypeError("1st input argument in function 'setHIconLeftOver' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hl != "number") {throw new TypeError("1st input argument '"+hl+"' in function 'setHIconLeftOver' is of type '"+(typeof hl)+"'. Expected type 'number'. Function Signature: setHIconLeftOver(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setHIconLeftOver', {"widget": this.id, "hl": hl}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.getVIconLeftOver = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVIconLeftOver'. Expected "+0+" arguments. Function Signature: getVIconLeftOver()")};
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.getVIconLeftOver', {"widget": this.id}, this.userPriority);
	},

		PDFNet.WidgetAnnot.prototype.setVIconLeftOver = function(vl)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setVIconLeftOver'. Expected "+1+" argument. Function Signature: setVIconLeftOver(number)")};
		if(vl instanceof Promise) {throw new TypeError("1st input argument in function 'setVIconLeftOver' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vl != "number") {throw new TypeError("1st input argument '"+vl+"' in function 'setVIconLeftOver' is of type '"+(typeof vl)+"'. Expected type 'number'. Function Signature: setVIconLeftOver(number).");}
		return PDFNet.messageHandler.sendWithPromise('WidgetAnnot.setVIconLeftOver', {"widget": this.id, "vl": vl}, this.userPriority);
	},

	/**
	* Creates a new valid Bookmark with given title in the
	* specified document.
	*
	* @param in_doc The document in which a Bookmark is to be created.
	* @param in_title The title string value of the new Bookmark.
	*
	* @return A promise that resolves to the new Bookmark.
	*
	* @note The new Bookmark is not linked to the outline tree.
	* Use AddChild()/AddNext()/AddPrev() methods in order to link the Bookmark
	* to the outline tree
	*/
		PDFNet.Bookmark.create = function(in_doc, in_title)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(PDFDoc, string)")};
		if(in_doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_doc instanceof PDFNet.PDFDoc || in_doc instanceof PDFNet.SDFDoc)) {
			if(typeof in_doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+in_doc.name+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_doc+"' in function 'create' is of type '"+(typeof in_doc)+"'. Expected type 'PDFDoc'. Function Signature: create(PDFDoc, string).");}
		}
		if(in_title instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_title != "string") {throw new TypeError("2nd input argument '"+in_title+"' in function 'create' is of type '"+(typeof in_title)+"'. Expected type 'string'. Function Signature: create(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('bookmarkCreate', {"in_doc": in_doc.id, "in_title": in_title}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* A constructor. Creates a Bookmark and initialize it using given Cos/SDF object.
	*
	* @param in_bookmark_dict Pointer to the Cos/SDF object (outline item dictionary).
	*
	* @return A promise that resolves to the new Bookmark.
	*
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.Bookmark.createFromObj = function(in_bookmark_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(in_bookmark_dict instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_bookmark_dict instanceof PDFNet.Obj)) {
			if(typeof in_bookmark_dict == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+in_bookmark_dict.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+in_bookmark_dict+"' in function 'createFromObj' is of type '"+(typeof in_bookmark_dict)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('bookmarkCreateFromObj', {"in_bookmark_dict": in_bookmark_dict.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

		PDFNet.Bookmark.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.copy', {"in_bookmark": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

		PDFNet.Bookmark.prototype.compare = function(in_bookmark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(Bookmark)")};
		if(in_bookmark instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_bookmark instanceof PDFNet.Bookmark)) {
			if(typeof in_bookmark == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+in_bookmark.name+"'. Expected type 'Bookmark'. Function Signature: compare(Bookmark).");}
			else {throw new TypeError("1st input argument '"+in_bookmark+"' in function 'compare' is of type '"+(typeof in_bookmark)+"'. Expected type 'Bookmark'. Function Signature: compare(Bookmark).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.compare', {"bm": this.id, "in_bookmark": in_bookmark.id}, this.userPriority);
	},

	/**
	* Indicates whether the Bookmark is valid (non-null).
	*
	* @return A promise that resolves to true if this is a valid (non-null) Bookmark; otherwise false.
	*
	* @note If this method returns false the underlying SDF/Cos object is null and
	* the Bookmark object should be treated as null as well.
	*/
		PDFNet.Bookmark.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.isValid', {"bm": this.id}, this.userPriority);
	},

	/**
	* Indicates whether the Bookmark has children.
	*
	* @return A promise that resolves to true if the Bookmark has children; otherwise false.
	*/
		PDFNet.Bookmark.prototype.hasChildren = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasChildren'. Expected "+0+" arguments. Function Signature: hasChildren()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.hasChildren', {"bm": this.id}, this.userPriority);
	},

	/**
	* Returns the Bookmark's next (right) sibling.
	*
	* @return A promise that resolves to the Bookmark's next (right) sibling.
	*/
		PDFNet.Bookmark.prototype.getNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNext'. Expected "+0+" arguments. Function Signature: getNext()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getNext', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Returns the Bookmark's previous (left) sibling.
	*
	* @return A promise that resolves to the Bookmark's previous (left) sibling.
	*/
		PDFNet.Bookmark.prototype.getPrev = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPrev'. Expected "+0+" arguments. Function Signature: getPrev()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getPrev', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Returns the Bookmark's first child.
	*
	* @return A promise that resolves to the Bookmark's first child.
	*/
		PDFNet.Bookmark.prototype.getFirstChild = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFirstChild'. Expected "+0+" arguments. Function Signature: getFirstChild()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getFirstChild', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Returns the Bookmark's last child.
	*
	* @return A promise that resolves to the Bookmark's last child.
	*/
		PDFNet.Bookmark.prototype.getLastChild = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLastChild'. Expected "+0+" arguments. Function Signature: getLastChild()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getLastChild', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Returns the Bookmark's parent Bookmark.
	*
	* @return A promise that resolves to the Bookmark's parent Bookmark.
	*/
		PDFNet.Bookmark.prototype.getParent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParent'. Expected "+0+" arguments. Function Signature: getParent()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getParent', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Returns the Bookmark specified by the given title string.
	*
	* @param in_title The title string value of the Bookmark to find.
	*
	* @return A promise that resolves to a Bookmark matching the title string value specified.
	*/
		PDFNet.Bookmark.prototype.find = function(in_title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'find'. Expected "+1+" argument. Function Signature: find(string)")};
		if(in_title instanceof Promise) {throw new TypeError("1st input argument in function 'find' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_title != "string") {throw new TypeError("1st input argument '"+in_title+"' in function 'find' is of type '"+(typeof in_title)+"'. Expected type 'string'. Function Signature: find(string).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.find', {"bm": this.id, "in_title": in_title}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

		PDFNet.Bookmark.prototype.addNewChild = function(in_title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addNewChild'. Expected "+1+" argument. Function Signature: addNewChild(string)")};
		if(in_title instanceof Promise) {throw new TypeError("1st input argument in function 'addNewChild' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_title != "string") {throw new TypeError("1st input argument '"+in_title+"' in function 'addNewChild' is of type '"+(typeof in_title)+"'. Expected type 'string'. Function Signature: addNewChild(string).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addNewChild', {"bm": this.id, "in_title": in_title}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* adds the specified Bookmark as the new last child of this Bookmark.
	*
	* @param in_bookmark The Bookmark object to be added as a last child of this Bookmark.
	*
	* @note Parameter in_bookmark must not be linked to a bookmark tree.
	* @note If this Bookmark previously had no children, it will be open
	* after the child is added.
	*/
		PDFNet.Bookmark.prototype.addChild = function(in_bookmark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addChild'. Expected "+1+" argument. Function Signature: addChild(Bookmark)")};
		if(in_bookmark instanceof Promise) {throw new TypeError("1st input argument in function 'addChild' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_bookmark instanceof PDFNet.Bookmark)) {
			if(typeof in_bookmark == "object") {throw new TypeError("1st input argument in function 'addChild' is of type '"+in_bookmark.name+"'. Expected type 'Bookmark'. Function Signature: addChild(Bookmark).");}
			else {throw new TypeError("1st input argument '"+in_bookmark+"' in function 'addChild' is of type '"+(typeof in_bookmark)+"'. Expected type 'Bookmark'. Function Signature: addChild(Bookmark).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addChild', {"bm": this.id, "in_bookmark": in_bookmark.id}, this.userPriority);
	},

		PDFNet.Bookmark.prototype.addNewNext = function(in_title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addNewNext'. Expected "+1+" argument. Function Signature: addNewNext(string)")};
		if(in_title instanceof Promise) {throw new TypeError("1st input argument in function 'addNewNext' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_title != "string") {throw new TypeError("1st input argument '"+in_title+"' in function 'addNewNext' is of type '"+(typeof in_title)+"'. Expected type 'string'. Function Signature: addNewNext(string).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addNewNext', {"bm": this.id, "in_title": in_title}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* adds the specified Bookmark as the new right sibling to this Bookmark,
	* adjusting the tree containing this Bookmark appropriately.
	*
	* @param in_bookmark The Bookmark object to be added to this Bookmark.
	*
	* @note Parameter in_bookmark must not be linked to a bookmark tree.
	*/
		PDFNet.Bookmark.prototype.addNext = function(in_bookmark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addNext'. Expected "+1+" argument. Function Signature: addNext(Bookmark)")};
		if(in_bookmark instanceof Promise) {throw new TypeError("1st input argument in function 'addNext' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_bookmark instanceof PDFNet.Bookmark)) {
			if(typeof in_bookmark == "object") {throw new TypeError("1st input argument in function 'addNext' is of type '"+in_bookmark.name+"'. Expected type 'Bookmark'. Function Signature: addNext(Bookmark).");}
			else {throw new TypeError("1st input argument '"+in_bookmark+"' in function 'addNext' is of type '"+(typeof in_bookmark)+"'. Expected type 'Bookmark'. Function Signature: addNext(Bookmark).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addNext', {"bm": this.id, "in_bookmark": in_bookmark.id}, this.userPriority);
	},

		PDFNet.Bookmark.prototype.addNewPrev = function(in_title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addNewPrev'. Expected "+1+" argument. Function Signature: addNewPrev(string)")};
		if(in_title instanceof Promise) {throw new TypeError("1st input argument in function 'addNewPrev' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_title != "string") {throw new TypeError("1st input argument '"+in_title+"' in function 'addNewPrev' is of type '"+(typeof in_title)+"'. Expected type 'string'. Function Signature: addNewPrev(string).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addNewPrev', {"bm": this.id, "in_title": in_title}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* adds the specified Bookmark as the new left sibling to this Bookmark,
	* adjusting the tree containing this Bookmark appropriately.
	*
	* @param in_bookmark The Bookmark object to be added to this Bookmark.
	*
	* @note Parameter in_bookmark must not be linked to a bookmark tree.
	*/
		PDFNet.Bookmark.prototype.addPrev = function(in_bookmark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addPrev'. Expected "+1+" argument. Function Signature: addPrev(Bookmark)")};
		if(in_bookmark instanceof Promise) {throw new TypeError("1st input argument in function 'addPrev' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_bookmark instanceof PDFNet.Bookmark)) {
			if(typeof in_bookmark == "object") {throw new TypeError("1st input argument in function 'addPrev' is of type '"+in_bookmark.name+"'. Expected type 'Bookmark'. Function Signature: addPrev(Bookmark).");}
			else {throw new TypeError("1st input argument '"+in_bookmark+"' in function 'addPrev' is of type '"+(typeof in_bookmark)+"'. Expected type 'Bookmark'. Function Signature: addPrev(Bookmark).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.addPrev', {"bm": this.id, "in_bookmark": in_bookmark.id}, this.userPriority);
	},

	/**
	* removes the Bookmark's subtree from the bookmark tree containing it.
	*/
		PDFNet.Bookmark.prototype.delete = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'delete'. Expected "+0+" arguments. Function Signature: delete()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.delete', {"bm": this.id}, this.userPriority);
	},

	/**
	* unlinks this Bookmark from the bookmark tree that contains it, and
	* adjusts the tree appropriately.
	*
	* @note After the bookmark is unlinked is can be moved to another place
	* in the bookmark tree located in the same document.
	*/
		PDFNet.Bookmark.prototype.unlink = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'unlink'. Expected "+0+" arguments. Function Signature: unlink()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.unlink', {"bm": this.id}, this.userPriority);
	},

	/**
	* Returns the indentation level of the Bookmark in its containing tree.
	*
	* @return A promise that resolves to the indentation level of the Bookmark in its containing tree.
	*
	* @note The root level has an indentation level of zero.
	*/
		PDFNet.Bookmark.prototype.getIndent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIndent'. Expected "+0+" arguments. Function Signature: getIndent()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getIndent', {"bm": this.id}, this.userPriority);
	},

	/**
	* Indicates whether the Bookmark is open.
	*
	* @return A promise that resolves to true if this Bookmark is open; otherwise false.
	*
	* @note An open Bookmark shows all its children.
	*/
		PDFNet.Bookmark.prototype.isOpen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isOpen'. Expected "+0+" arguments. Function Signature: isOpen()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.isOpen', {"bm": this.id}, this.userPriority);
	},

	/**
	* Opens or closes the Bookmark.
	*
	* @param in_open Boolean value that contains the status.
	* If true, the Bookmark is opened. Otherwise the Bookmark is closed.
	*
	* @note An opened Bookmark shows its children, while a closed Bookmark does not.
	*/
		PDFNet.Bookmark.prototype.setOpen = function(in_open)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpen'. Expected "+1+" argument. Function Signature: setOpen(boolean)")};
		if(in_open instanceof Promise) {throw new TypeError("1st input argument in function 'setOpen' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_open != "boolean") {throw new TypeError("1st input argument '"+in_open+"' in function 'setOpen' is of type '"+(typeof in_open)+"'. Expected type 'boolean'. Function Signature: setOpen(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.setOpen', {"bm": this.id, "in_open": in_open}, this.userPriority);
	},

	/**
	* Returns the number of opened bookmarks in this subtree.
	*
	* @return A promise that resolves to the number of opened bookmarks in this subtree (not including
	* this Bookmark). If the item is closed, a negative integer whose
	* absolute value specifies how many descendants would appear if the
	* item were reopened.
	*/
		PDFNet.Bookmark.prototype.getOpenCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOpenCount'. Expected "+0+" arguments. Function Signature: getOpenCount()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getOpenCount', {"bm": this.id}, this.userPriority);
	},

	/**
	* Returns the Bookmark's title string.
	*
	* @return A promise that resolves to the Bookmark's title string).
	*/
		PDFNet.Bookmark.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getTitle', {"bm": this.id}, this.userPriority);
	},

	/**
	* Returns the Bookmark's title string object.
	* @return A promise that resolves to the Bookmark's title string object.
	*/
		PDFNet.Bookmark.prototype.getTitleObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitleObj'. Expected "+0+" arguments. Function Signature: getTitleObj()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getTitleObj', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Sets the Bookmark's title string.
	*
	* @param title The new title string for the bookmark.
	*/
		PDFNet.Bookmark.prototype.setTitle = function(title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitle'. Expected "+1+" argument. Function Signature: setTitle(string)")};
		if(title instanceof Promise) {throw new TypeError("1st input argument in function 'setTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof title != "string") {throw new TypeError("1st input argument '"+title+"' in function 'setTitle' is of type '"+(typeof title)+"'. Expected type 'string'. Function Signature: setTitle(string).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.setTitle', {"bm": this.id, "title": title}, this.userPriority);
	},

	/**
	* Returns the Bookmark's action.
	*
	* @return A promise that resolves to the Bookmark's action.
	*/
		PDFNet.Bookmark.prototype.getAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAction'. Expected "+0+" arguments. Function Signature: getAction()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getAction', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* sets the Bookmark's action.
	*
	* @param in_action The new Action for the Bookmark.
	*/
		PDFNet.Bookmark.prototype.setAction = function(in_action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAction'. Expected "+1+" argument. Function Signature: setAction(Action)")};
		if(in_action instanceof Promise) {throw new TypeError("1st input argument in function 'setAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_action instanceof PDFNet.Action)) {
			if(typeof in_action == "object") {throw new TypeError("1st input argument in function 'setAction' is of type '"+in_action.name+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
			else {throw new TypeError("1st input argument '"+in_action+"' in function 'setAction' is of type '"+(typeof in_action)+"'. Expected type 'Action'. Function Signature: setAction(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.setAction', {"bm": this.id, "in_action": in_action.id}, this.userPriority);
	},

	/**
	* removes the Bookmark's action.
	*/
		PDFNet.Bookmark.prototype.removeAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'removeAction'. Expected "+0+" arguments. Function Signature: removeAction()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.removeAction', {"bm": this.id}, this.userPriority);
	},

	/**
	* Returns the Bookmark's flags.
	*
	* @return A promise that resolves to the flags of the Bookmark object.
	* Bit 1 (least-significant bit) indicates italic font whereas
	* bit 2 indicates bold font.
	* Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
	*/
		PDFNet.Bookmark.prototype.getFlags = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFlags'. Expected "+0+" arguments. Function Signature: getFlags()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getFlags', {"bm": this.id}, this.userPriority);
	},

	/**
	* Sets the Bookmark's flags.
	*
	* @param in_flags The new bookmark flags.
	* Bit 1 (the least-significant bit) indicates italic font whereas
	* bit 2 indicates bold font.
	* Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
	*/
		PDFNet.Bookmark.prototype.setFlags = function(in_flags)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFlags'. Expected "+1+" argument. Function Signature: setFlags(number)")};
		if(in_flags instanceof Promise) {throw new TypeError("1st input argument in function 'setFlags' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_flags != "number") {throw new TypeError("1st input argument '"+in_flags+"' in function 'setFlags' is of type '"+(typeof in_flags)+"'. Expected type 'number'. Function Signature: setFlags(number).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.setFlags', {"bm": this.id, "in_flags": in_flags}, this.userPriority);
	},

		PDFNet.Bookmark.prototype.getColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColor'. Expected "+0+" arguments. Function Signature: getColor()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getColor', {"bm": this.id}, this.userPriority);
	},

	/**
	* Sets the Bookmark's color value.
	*
	* @param in_r The red component of the color.
	* @param in_g The green component of the color.
	* @param in_b The blue component of the color.
	*
	* @note The three numbers \a in_r, \a in_g, and \a in_b are in the range 0.0 to 1.0, representing
	* the components in the DeviceRGB color space of the color to be used
	* for the Bookmark's text.
	* Default color value is black, [0.0 0.0 0.0].
	*/
		PDFNet.Bookmark.prototype.setColor = function(in_r, in_g, in_b)
	{
		if(typeof in_r === "undefined") {in_r = 0;};
		if(typeof in_g === "undefined") {in_g = 0;};
		if(typeof in_b === "undefined") {in_b = 0;};
		if(arguments.length > 3) {throw new RangeError(arguments.length+" arguments passed into function 'setColor'. Expected at most "+3+" arguments. Function Signature: setColor(number, number, number)")};
		if(in_r instanceof Promise) {throw new TypeError("1st input argument in function 'setColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_r != "number") {throw new TypeError("1st input argument '"+in_r+"' in function 'setColor' is of type '"+(typeof in_r)+"'. Expected type 'number'. Function Signature: setColor(number, number, number).");}
		if(in_g instanceof Promise) {throw new TypeError("2nd input argument in function 'setColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_g != "number") {throw new TypeError("2nd input argument '"+in_g+"' in function 'setColor' is of type '"+(typeof in_g)+"'. Expected type 'number'. Function Signature: setColor(number, number, number).");}
		if(in_b instanceof Promise) {throw new TypeError("3rd input argument in function 'setColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_b != "number") {throw new TypeError("3rd input argument '"+in_b+"' in function 'setColor' is of type '"+(typeof in_b)+"'. Expected type 'number'. Function Signature: setColor(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Bookmark.setColor', {"bm": this.id, "in_r": in_r, "in_g": in_g, "in_b": in_b}, this.userPriority);
	},

	/**
	* Returns the underlying SDF/Cos object.
	*
	* @return A promise that resolves to the underlying SDF/Cos object.
	*
	* @note A null (non-valid) bookmark returns a null object.
	*/
		PDFNet.Bookmark.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Bookmark.getSDFObj', {"bm": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Constructors and destructor
	*/
		PDFNet.ColorPt.init = function(x, y, z, w)
	{
		if(typeof x === "undefined") {x = 0;};
		if(typeof y === "undefined") {y = 0;};
		if(typeof z === "undefined") {z = 0;};
		if(typeof w === "undefined") {w = 0;};
		if(arguments.length > 4) {throw new RangeError(arguments.length+" arguments passed into function 'init'. Expected at most "+4+" arguments. Function Signature: init(number, number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'init' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'init' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(z instanceof Promise) {throw new TypeError("3rd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof z != "number") {throw new TypeError("3rd input argument '"+z+"' in function 'init' is of type '"+(typeof z)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(w instanceof Promise) {throw new TypeError("4th input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof w != "number") {throw new TypeError("4th input argument '"+w+"' in function 'init' is of type '"+(typeof w)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('colorPtInit', {"x": x, "y": y, "z": z, "w": w}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

		PDFNet.ColorPt.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(ColorPt)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.ColorPt) && right.name != "ColorPt") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'ColorPt'. Function Signature: assign(ColorPt).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'ColorPt'. Function Signature: assign(ColorPt).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "ColorPt.assign"; // TRN_ColorPt* left
		return PDFNet.messageHandler.sendWithPromise('ColorPt.assign', {"left": this, "right": right.id}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.ColorPt.prototype.compare = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(ColorPt)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.ColorPt) && right.name != "ColorPt") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+right.name+"'. Expected type 'ColorPt'. Function Signature: compare(ColorPt).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'compare' is of type '"+(typeof right)+"'. Expected type 'ColorPt'. Function Signature: compare(ColorPt).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'compare'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'compare'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ColorPt.compare', {"left": this, "right": right.id}, this.userPriority);
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ColorPt.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'destroy'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ColorPt.destroy"; // TRN_ColorPt* cp
		return PDFNet.messageHandler.sendWithPromise('ColorPt.destroy', {"cp": this}, this.userPriority).then(function(id){
			copyFunc(id.cp, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* A utility method to set the first 4 tint values. For example,
	* color.Set(red, green, blue) will initialize the ColorPt to given
	* tint values.
	* @note All colorants should be in the range [0..1].
	* @note color.Set(gray) is equivalent to Set(0, gray);
	*/
		PDFNet.ColorPt.prototype.set = function(x, y, z, w)
	{
		if(typeof x === "undefined") {x = 0;};
		if(typeof y === "undefined") {y = 0;};
		if(typeof z === "undefined") {z = 0;};
		if(typeof w === "undefined") {w = 0;};
		if(arguments.length > 4) {throw new RangeError(arguments.length+" arguments passed into function 'set'. Expected at most "+4+" arguments. Function Signature: set(number, number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'set' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'set' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(z instanceof Promise) {throw new TypeError("3rd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof z != "number") {throw new TypeError("3rd input argument '"+z+"' in function 'set' is of type '"+(typeof z)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(w instanceof Promise) {throw new TypeError("4th input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof w != "number") {throw new TypeError("4th input argument '"+w+"' in function 'set' is of type '"+(typeof w)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'set'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ColorPt.set"; // TRN_ColorPt* cp
		return PDFNet.messageHandler.sendWithPromise('ColorPt.set', {"cp": this, "x": x, "y": y, "z": z, "w": w}, this.userPriority).then(function(id){
			copyFunc(id.cp, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Sets a tint value at a given colorant index.
	*
	* @param colorant_index the color index. For example, for a color point
	* associated with a Gray color space the only allowed value for index
	* is 0. For a color point associated with a CMYK color space, the color_index
	* can range from 0 (cyan) to 4 (black).
	*
	* @param colorant_value The new tint value.
	*
	* For example, the following snippet will initialize the color point
	* to [red, green, blue]:
	* @code
	* color.SetColorantNum(3);
	* color.Set(0, red);
	* color.Set(1, green);
	* color.Set(2, blue);
	* @endcode
	*
	* The above code snippet is equivalent to the following line:
	*   color.Set(red, green, blue)
	*
	* @note If a color point has more than 4 colorants, SetColorantNum(num_colorants)
	* must be called before getting or setting tint values.
	*/
		PDFNet.ColorPt.prototype.setByIndex = function(colorant_index, colorant_value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setByIndex'. Expected "+2+" arguments. Function Signature: setByIndex(number, number)")};
		if(colorant_index instanceof Promise) {throw new TypeError("1st input argument in function 'setByIndex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof colorant_index != "number") {throw new TypeError("1st input argument '"+colorant_index+"' in function 'setByIndex' is of type '"+(typeof colorant_index)+"'. Expected type 'number'. Function Signature: setByIndex(number, number).");}
		if(colorant_value instanceof Promise) {throw new TypeError("2nd input argument in function 'setByIndex' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof colorant_value != "number") {throw new TypeError("2nd input argument '"+colorant_value+"' in function 'setByIndex' is of type '"+(typeof colorant_value)+"'. Expected type 'number'. Function Signature: setByIndex(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setByIndex'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ColorPt.setByIndex"; // TRN_ColorPt* cp
		return PDFNet.messageHandler.sendWithPromise('ColorPt.setByIndex', {"cp": this, "colorant_index": colorant_index, "colorant_value": colorant_value}, this.userPriority).then(function(id){
			copyFunc(id.cp, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the tint value at a given colorant index.
	*
	* The number of colorants depends on the associated color space. To find
	* how many colorant are associated with a given color space use
	* color_space.GetComponentNum().
	*
	* For example, if you have a color point in the RGB color space you can
	* extract its colorants as follows:
	* @code
	* UInt8 rgb[3] = { UInt8(c.Get(0)*255), UInt8(c.Get(1)*255), UInt8(c.Get(2)*255) };
	* @endcode
	*/
		PDFNet.ColorPt.prototype.get = function(colorant_index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'get'. Expected "+1+" argument. Function Signature: get(number)")};
		if(colorant_index instanceof Promise) {throw new TypeError("1st input argument in function 'get' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof colorant_index != "number") {throw new TypeError("1st input argument '"+colorant_index+"' in function 'get' is of type '"+(typeof colorant_index)+"'. Expected type 'number'. Function Signature: get(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'get'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('ColorPt.get', {"cp": this, "colorant_index": colorant_index}, this.userPriority);
	},

	/**
	* If a color point has more than 4 colorants, SetColorantNum(num_colorants)
	* must be called before getting or setting tint values.
	* The number of colorants depends on the associated color space. To find
	* how many colorant are associated with a given color space use
	* color_space.GetComponentNum().
	*/
		PDFNet.ColorPt.prototype.setColorantNum = function(num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setColorantNum'. Expected "+1+" argument. Function Signature: setColorantNum(number)")};
		if(num instanceof Promise) {throw new TypeError("1st input argument in function 'setColorantNum' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num != "number") {throw new TypeError("1st input argument '"+num+"' in function 'setColorantNum' is of type '"+(typeof num)+"'. Expected type 'number'. Function Signature: setColorantNum(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setColorantNum'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "ColorPt.setColorantNum"; // TRN_ColorPt* cp
		return PDFNet.messageHandler.sendWithPromise('ColorPt.setColorantNum', {"cp": this, "num": num}, this.userPriority).then(function(id){
			copyFunc(id.cp, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Create a new DeviceGray ColorSpace object
	*/
		PDFNet.ColorSpace.createDeviceGray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createDeviceGray'. Expected "+0+" arguments. Function Signature: createDeviceGray()")};
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateDeviceGray', {}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* Create a new DeviceRGB ColorSpace object
	*/
		PDFNet.ColorSpace.createDeviceRGB = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createDeviceRGB'. Expected "+0+" arguments. Function Signature: createDeviceRGB()")};
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateDeviceRGB', {}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* Create a new DeviceCMYK ColorSpace object
	*/
		PDFNet.ColorSpace.createDeviceCMYK = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createDeviceCMYK'. Expected "+0+" arguments. Function Signature: createDeviceCMYK()")};
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateDeviceCMYK', {}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* Create a new Pattern ColorSpace object
	*/
		PDFNet.ColorSpace.createPattern = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createPattern'. Expected "+0+" arguments. Function Signature: createPattern()")};
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreatePattern', {}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* Create a ColorSpace from the given SDF/Cos object listed under ColorSpaces entry
	* in page Resource dictionary. If color_space dictionary is null, a non valid ColorSpace
	* object is created.
	*/
		PDFNet.ColorSpace.create = function(color_space)
	{
		if(typeof color_space === "undefined") {color_space = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(color_space instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_space instanceof PDFNet.Obj)) {
			if(typeof color_space == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+color_space.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+color_space+"' in function 'create' is of type '"+(typeof color_space)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreate', {"color_space": color_space.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* Create a PDF 'ICCBased' color space given an ICC profile
	*/
		PDFNet.ColorSpace.createICCFromFile = function(doc, filepath)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createICCFromFile'. Expected "+2+" arguments. Function Signature: createICCFromFile(SDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createICCFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createICCFromFile' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createICCFromFile(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createICCFromFile' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createICCFromFile(SDFDoc, string).");}
		}
		if(filepath instanceof Promise) {throw new TypeError("2nd input argument in function 'createICCFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("2nd input argument '"+filepath+"' in function 'createICCFromFile' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createICCFromFile(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateICCFromFile', {"doc": doc.id, "filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

		PDFNet.ColorSpace.createICCFromFilter = function(doc, filter)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createICCFromFilter'. Expected "+2+" arguments. Function Signature: createICCFromFilter(SDFDoc, Filter)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createICCFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createICCFromFilter' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createICCFromFilter(SDFDoc, Filter).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createICCFromFilter' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createICCFromFilter(SDFDoc, Filter).");}
		}
		if(filter instanceof Promise) {throw new TypeError("2nd input argument in function 'createICCFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter instanceof PDFNet.Filter)) {
			if(typeof filter == "object") {throw new TypeError("2nd input argument in function 'createICCFromFilter' is of type '"+filter.name+"'. Expected type 'Filter'. Function Signature: createICCFromFilter(SDFDoc, Filter).");}
			else {throw new TypeError("2nd input argument '"+filter+"' in function 'createICCFromFilter' is of type '"+(typeof filter)+"'. Expected type 'Filter'. Function Signature: createICCFromFilter(SDFDoc, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateICCFromFilter', {"doc": doc.id, "filter": filter.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

		PDFNet.ColorSpace.createICCFromBuffer = function(doc, buf)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createICCFromBuffer'. Expected "+2+" arguments. Function Signature: createICCFromBuffer(SDFDoc, ArrayBuffer)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createICCFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createICCFromBuffer' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createICCFromBuffer(SDFDoc, ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createICCFromBuffer' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createICCFromBuffer(SDFDoc, ArrayBuffer).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createICCFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createICCFromBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createICCFromBuffer(SDFDoc, ArrayBuffer).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createICCFromBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createICCFromBuffer(SDFDoc, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceCreateICCFromBuffer', {"doc": doc.id, "buf": buf.buffer}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

		PDFNet.ColorSpace.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(ColorSpace)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.ColorSpace)) {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'ColorSpace'. Function Signature: assign(ColorSpace).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'ColorSpace'. Function Signature: assign(ColorSpace).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.assign', {"left": this.id, "right": right.id}, this.userPriority);
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ColorSpace.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.destroy', {"cs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of components (tint components) used to represent color
	* point for this color space
	*
	* @param cs_type
	* @param cs Cos/SDF color space object.
	*/
		PDFNet.ColorSpace.getComponentNumFromObj = function(cs_type, cs_obj)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'getComponentNumFromObj'. Expected "+2+" arguments. Function Signature: getComponentNumFromObj(number, Obj)")};
		if(cs_type instanceof Promise) {throw new TypeError("1st input argument in function 'getComponentNumFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cs_type != "number") {throw new TypeError("1st input argument '"+cs_type+"' in function 'getComponentNumFromObj' is of type '"+(typeof cs_type)+"'. Expected type 'number'. Function Signature: getComponentNumFromObj(number, Obj).");}
		if(cs_obj instanceof Promise) {throw new TypeError("2nd input argument in function 'getComponentNumFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cs_obj instanceof PDFNet.Obj)) {
			if(typeof cs_obj == "object") {throw new TypeError("2nd input argument in function 'getComponentNumFromObj' is of type '"+cs_obj.name+"'. Expected type 'Obj'. Function Signature: getComponentNumFromObj(number, Obj).");}
			else {throw new TypeError("2nd input argument '"+cs_obj+"' in function 'getComponentNumFromObj' is of type '"+(typeof cs_obj)+"'. Expected type 'Obj'. Function Signature: getComponentNumFromObj(number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceGetComponentNumFromObj', {"cs_type": cs_type, "cs_obj": cs_obj.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Type of a given SDF/Cos color space, or e_null for if
	* SDF object is not a valid color space
	*
	* @param cs Cos/SDF color space object.
	*/
		PDFNet.ColorSpace.getTypeFromObj = function(cs_obj)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTypeFromObj'. Expected "+1+" argument. Function Signature: getTypeFromObj(Obj)")};
		if(cs_obj instanceof Promise) {throw new TypeError("1st input argument in function 'getTypeFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cs_obj instanceof PDFNet.Obj)) {
			if(typeof cs_obj == "object") {throw new TypeError("1st input argument in function 'getTypeFromObj' is of type '"+cs_obj.name+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+cs_obj+"' in function 'getTypeFromObj' is of type '"+(typeof cs_obj)+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('colorSpaceGetTypeFromObj', {"cs_obj": cs_obj.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the type of this color space
	*/
		PDFNet.ColorSpace.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getType', {"cs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object
	*/
		PDFNet.ColorSpace.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getSDFObj', {"cs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the number of colorants (tint components) used to represent color
	*  point in this color space
	*/
		PDFNet.ColorSpace.prototype.getComponentNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getComponentNum'. Expected "+0+" arguments. Function Signature: getComponentNum()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getComponentNum', {"cs": this.id}, this.userPriority);
	},

	/**
	* Set color to the initial value used for this color space.
	* The initial value depends on the color space (see 4.5.7 in PDF Ref. Manual).
	*/
		PDFNet.ColorSpace.prototype.initColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'initColor'. Expected "+0+" arguments. Function Signature: initColor()")};
		var me = this;
		this.yieldFunction = "ColorSpace.initColor"; // TRN_ColorPt* out_colorants
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.initColor', {"cs": this.id}, this.userPriority).then(function(id){
			copyFunc(id.out_colorants, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.ColorSpace.prototype.initComponentRanges = function(num_comps)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'initComponentRanges'. Expected "+1+" argument. Function Signature: initComponentRanges(number)")};
		if(num_comps instanceof Promise) {throw new TypeError("3rd input argument in function 'initComponentRanges' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof num_comps != "number") {throw new TypeError("3rd input argument '"+num_comps+"' in function 'initComponentRanges' is of type '"+(typeof num_comps)+"'. Expected type 'number'. Function Signature: initComponentRanges(number).");}
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.initComponentRanges', {"cs": this.id, "num_comps": num_comps}, this.userPriority);
	},

		PDFNet.ColorSpace.prototype.convert2Gray = function(in_color)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'convert2Gray'. Expected "+1+" argument. Function Signature: convert2Gray(ColorPt)")};
		if(in_color instanceof Promise) {throw new TypeError("1st input argument in function 'convert2Gray' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_color instanceof PDFNet.ColorPt) && in_color.name != "ColorPt") {
			if(typeof in_color == "object") {throw new TypeError("1st input argument in function 'convert2Gray' is of type '"+in_color.name+"'. Expected type 'ColorPt'. Function Signature: convert2Gray(ColorPt).");}
			else {throw new TypeError("1st input argument '"+in_color+"' in function 'convert2Gray' is of type '"+(typeof in_color)+"'. Expected type 'ColorPt'. Function Signature: convert2Gray(ColorPt).");}
		}
		if(typeof in_color.yieldFunction != "undefined") {throw new Error("Function '"+in_color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'convert2Gray'. Perhaps a yield statement is required for '"+in_color.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "ColorSpace.convert2Gray"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.convert2Gray', {"cs": this.id, "in_color": in_color.id}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.ColorSpace.prototype.convert2RGB = function(in_color)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'convert2RGB'. Expected "+1+" argument. Function Signature: convert2RGB(ColorPt)")};
		if(in_color instanceof Promise) {throw new TypeError("1st input argument in function 'convert2RGB' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_color instanceof PDFNet.ColorPt) && in_color.name != "ColorPt") {
			if(typeof in_color == "object") {throw new TypeError("1st input argument in function 'convert2RGB' is of type '"+in_color.name+"'. Expected type 'ColorPt'. Function Signature: convert2RGB(ColorPt).");}
			else {throw new TypeError("1st input argument '"+in_color+"' in function 'convert2RGB' is of type '"+(typeof in_color)+"'. Expected type 'ColorPt'. Function Signature: convert2RGB(ColorPt).");}
		}
		if(typeof in_color.yieldFunction != "undefined") {throw new Error("Function '"+in_color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'convert2RGB'. Perhaps a yield statement is required for '"+in_color.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "ColorSpace.convert2RGB"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.convert2RGB', {"cs": this.id, "in_color": in_color.id}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.ColorSpace.prototype.convert2CMYK = function(in_color)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'convert2CMYK'. Expected "+1+" argument. Function Signature: convert2CMYK(ColorPt)")};
		if(in_color instanceof Promise) {throw new TypeError("1st input argument in function 'convert2CMYK' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_color instanceof PDFNet.ColorPt) && in_color.name != "ColorPt") {
			if(typeof in_color == "object") {throw new TypeError("1st input argument in function 'convert2CMYK' is of type '"+in_color.name+"'. Expected type 'ColorPt'. Function Signature: convert2CMYK(ColorPt).");}
			else {throw new TypeError("1st input argument '"+in_color+"' in function 'convert2CMYK' is of type '"+(typeof in_color)+"'. Expected type 'ColorPt'. Function Signature: convert2CMYK(ColorPt).");}
		}
		if(typeof in_color.yieldFunction != "undefined") {throw new Error("Function '"+in_color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'convert2CMYK'. Perhaps a yield statement is required for '"+in_color.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "ColorSpace.convert2CMYK"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.convert2CMYK', {"cs": this.id, "in_color": in_color.id}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the alternate color space if it is available or NULL otherwise.
	* Color spaces that include alternate color space are e_separation, e_device_n,
	* and e_icc.
	*/
		PDFNet.ColorSpace.prototype.getAlternateColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAlternateColorSpace'. Expected "+0+" arguments. Function Signature: getAlternateColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getAlternateColorSpace', {"cs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to the base color space if this is an e_indexed or e_pattern with
	* associated base color space; NULL otherwise.
	*/
		PDFNet.ColorSpace.prototype.getBaseColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBaseColorSpace'. Expected "+0+" arguments. Function Signature: getBaseColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getBaseColorSpace', {"cs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to the highest index for the color lookup table for Indexed color space.
	* Since the color table is indexed from zero to highval, the actual number of entries is
	* highval + 1. For color spaces other than indexed the method returns 0.
	*
	* @note for color spaces other than Indexed this method throws an exception.
	*/
		PDFNet.ColorSpace.prototype.getHighVal = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHighVal'. Expected "+0+" arguments. Function Signature: getHighVal()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getHighVal', {"cs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the color lookup table for Indexed color space. for color spaces other
	* than indexed the method returns NULL.
	*
	* @note for color spaces other than Indexed this method throws an exception.
	*/
		PDFNet.ColorSpace.prototype.getLookupTable = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLookupTable'. Expected "+0+" arguments. Function Signature: getLookupTable()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getLookupTable', {"cs": this.id}, this.userPriority);
	},

		PDFNet.ColorSpace.prototype.getBaseColor = function(color_idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getBaseColor'. Expected "+1+" argument. Function Signature: getBaseColor(number)")};
		if(color_idx instanceof Promise) {throw new TypeError("1st input argument in function 'getBaseColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof color_idx != "number") {throw new TypeError("1st input argument '"+color_idx+"' in function 'getBaseColor' is of type '"+(typeof color_idx)+"'. Expected type 'number'. Function Signature: getBaseColor(number).");}
		var me = this;
		this.yieldFunction = "ColorSpace.getBaseColor"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getBaseColor', {"cs": this.id, "color_idx": color_idx}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the function that transforms tint values into color component
	* values in the alternate color space.
	*
	* @note for color spaces other than Separation this method throws an exception.
	*/
		PDFNet.ColorSpace.prototype.getTintFunction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTintFunction'. Expected "+0+" arguments. Function Signature: getTintFunction()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.getTintFunction', {"cs": this.id}, this.userPriority).then(function(id){
			//there is a return type Function
			if(id == "0"){
				return null;
			}
			return new PDFNet.Function(id);
		});
	},

	/**
	* @return A promise that resolves to true if Separation color space contains the colorant All.
	*
	* @note for color spaces other than Separation this method throws an exception.
	*/
		PDFNet.ColorSpace.prototype.isAll = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isAll'. Expected "+0+" arguments. Function Signature: isAll()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.isAll', {"cs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if Separation or DeviceN color space contains None colorants.
	* For DeviceN the function returns true only if component colorant names are all None.
	*
	* @note for color spaces other than Separation or DeviceN this method throws
	* an exception.
	*/
		PDFNet.ColorSpace.prototype.isNone = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isNone'. Expected "+0+" arguments. Function Signature: isNone()")};
		return PDFNet.messageHandler.sendWithPromise('ColorSpace.isNone', {"cs": this.id}, this.userPriority);
	},

	/**
	* Create a new ContentReplacer object, to which replacement rules will be added.
	* The same object can be used to 'Process' multiple pages.
	*/
		PDFNet.ContentReplacer.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('contentReplacerCreate', {}, this.userPriority).then(function(id){
			//there is a return type ContentReplacer
			if(id == "0"){
				return null;
			}
			return new PDFNet.ContentReplacer(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ContentReplacer.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.destroy', {"cr": this.id}, this.userPriority);
	},

		PDFNet.ContentReplacer.prototype.AddImage = function(target_region, replacement_image)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'AddImage'. Expected "+2+" arguments. Function Signature: AddImage(Rect, Obj)")};
		if(target_region instanceof Promise) {throw new TypeError("1st input argument in function 'AddImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(target_region instanceof PDFNet.Rect) && target_region.name != "Rect") {
			if(typeof target_region == "object") {throw new TypeError("1st input argument in function 'AddImage' is of type '"+target_region.name+"'. Expected type 'Rect'. Function Signature: AddImage(Rect, Obj).");}
			else {throw new TypeError("1st input argument '"+target_region+"' in function 'AddImage' is of type '"+(typeof target_region)+"'. Expected type 'Rect'. Function Signature: AddImage(Rect, Obj).");}
		}
		if(replacement_image instanceof Promise) {throw new TypeError("2nd input argument in function 'AddImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(replacement_image instanceof PDFNet.Obj)) {
			if(typeof replacement_image == "object") {throw new TypeError("2nd input argument in function 'AddImage' is of type '"+replacement_image.name+"'. Expected type 'Obj'. Function Signature: AddImage(Rect, Obj).");}
			else {throw new TypeError("2nd input argument '"+replacement_image+"' in function 'AddImage' is of type '"+(typeof replacement_image)+"'. Expected type 'Obj'. Function Signature: AddImage(Rect, Obj).");}
		}
		if(typeof target_region.yieldFunction != "undefined") {throw new Error("Function '"+target_region.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'AddImage'. Perhaps a yield statement is required for '"+target_region.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.AddImage', {"cr": this.id, "target_region": target_region, "replacement_image": replacement_image.id}, this.userPriority);
	},

		PDFNet.ContentReplacer.prototype.AddText = function(target_region, replacement_text)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'AddText'. Expected "+2+" arguments. Function Signature: AddText(Rect, string)")};
		if(target_region instanceof Promise) {throw new TypeError("1st input argument in function 'AddText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(target_region instanceof PDFNet.Rect) && target_region.name != "Rect") {
			if(typeof target_region == "object") {throw new TypeError("1st input argument in function 'AddText' is of type '"+target_region.name+"'. Expected type 'Rect'. Function Signature: AddText(Rect, string).");}
			else {throw new TypeError("1st input argument '"+target_region+"' in function 'AddText' is of type '"+(typeof target_region)+"'. Expected type 'Rect'. Function Signature: AddText(Rect, string).");}
		}
		if(replacement_text instanceof Promise) {throw new TypeError("2nd input argument in function 'AddText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof replacement_text != "string") {throw new TypeError("2nd input argument '"+replacement_text+"' in function 'AddText' is of type '"+(typeof replacement_text)+"'. Expected type 'string'. Function Signature: AddText(Rect, string).");}
		if(typeof target_region.yieldFunction != "undefined") {throw new Error("Function '"+target_region.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'AddText'. Perhaps a yield statement is required for '"+target_region.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.AddText', {"cr": this.id, "target_region": target_region, "replacement_text": replacement_text}, this.userPriority);
	},

		PDFNet.ContentReplacer.prototype.AddString = function(template_text, replacement_text)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'AddString'. Expected "+2+" arguments. Function Signature: AddString(string, string)")};
		if(template_text instanceof Promise) {throw new TypeError("1st input argument in function 'AddString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof template_text != "string") {throw new TypeError("1st input argument '"+template_text+"' in function 'AddString' is of type '"+(typeof template_text)+"'. Expected type 'string'. Function Signature: AddString(string, string).");}
		if(replacement_text instanceof Promise) {throw new TypeError("2nd input argument in function 'AddString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof replacement_text != "string") {throw new TypeError("2nd input argument '"+replacement_text+"' in function 'AddString' is of type '"+(typeof replacement_text)+"'. Expected type 'string'. Function Signature: AddString(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.AddString', {"cr": this.id, "template_text": template_text, "replacement_text": replacement_text}, this.userPriority);
	},

		PDFNet.ContentReplacer.prototype.SetMatchStrings = function(start_str, end_str)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'SetMatchStrings'. Expected "+2+" arguments. Function Signature: SetMatchStrings(string, string)")};
		if(start_str instanceof Promise) {throw new TypeError("1st input argument in function 'SetMatchStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_str != "string") {throw new TypeError("1st input argument '"+start_str+"' in function 'SetMatchStrings' is of type '"+(typeof start_str)+"'. Expected type 'string'. Function Signature: SetMatchStrings(string, string).");}
		if(end_str instanceof Promise) {throw new TypeError("2nd input argument in function 'SetMatchStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof end_str != "string") {throw new TypeError("2nd input argument '"+end_str+"' in function 'SetMatchStrings' is of type '"+(typeof end_str)+"'. Expected type 'string'. Function Signature: SetMatchStrings(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.SetMatchStrings', {"cr": this.id, "start_str": start_str, "end_str": end_str}, this.userPriority);
	},

		PDFNet.ContentReplacer.prototype.Process = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'Process'. Expected "+1+" argument. Function Signature: Process(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'Process' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'Process' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: Process(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'Process' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: Process(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ContentReplacer.Process', {"cr": this.id, "page": page.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.tryConvert = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tryConvert'. Expected "+0+" arguments. Function Signature: tryConvert()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.tryConvert', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.convert = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'convert'. Expected "+0+" arguments. Function Signature: convert()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.convert', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.convertNextPage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'convertNextPage'. Expected "+0+" arguments. Function Signature: convertNextPage()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.convertNextPage', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getConversionStatus = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getConversionStatus'. Expected "+0+" arguments. Function Signature: getConversionStatus()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getConversionStatus', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.cancelConversion = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'cancelConversion'. Expected "+0+" arguments. Function Signature: cancelConversion()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.cancelConversion', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.hasProgressTracking = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasProgressTracking'. Expected "+0+" arguments. Function Signature: hasProgressTracking()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.hasProgressTracking', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getProgress = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getProgress'. Expected "+0+" arguments. Function Signature: getProgress()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getProgress', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getProgressLabel = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getProgressLabel'. Expected "+0+" arguments. Function Signature: getProgressLabel()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getProgressLabel', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getErrorString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getErrorString'. Expected "+0+" arguments. Function Signature: getErrorString()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getErrorString', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getNumWarnings = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumWarnings'. Expected "+0+" arguments. Function Signature: getNumWarnings()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getNumWarnings', {"self": this.id}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.getWarningString = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getWarningString'. Expected "+1+" argument. Function Signature: getWarningString(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getWarningString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getWarningString' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getWarningString(number).");}
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.getWarningString', {"self": this.id, "index": index}, this.userPriority);
	},

		PDFNet.DocumentConversion.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('DocumentConversion.destroy', {"self": this.id}, this.userPriority);
	},

	/**
	* Convert the specified XPS document to PDF and append converted pages
	* to the specified PDF document.
	*
	* @param in_pdfdoc the PDFDoc to append to
	*
	* @param in_filename the path to the XPS document to convert
	*
	*/
		PDFNet.Convert.fromXps = function(in_pdfdoc, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'fromXps'. Expected "+2+" arguments. Function Signature: fromXps(PDFDoc, string)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'fromXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'fromXps' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: fromXps(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'fromXps' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: fromXps(PDFDoc, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'fromXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'fromXps' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: fromXps(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertFromXps', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename}, this.userPriority);
	},

	/**
	* Convert the specified XPS document contained in memory to PDF
	* and append converted pages to the specified PDF document.
	*
	* @param in_pdfdoc the PDFDoc to append to
	*
	* @param buf the buffer containing the xps document
	*
	* @param buf_sz the size of the buffer
	*
	*/
		PDFNet.Convert.fromXpsMem = function(in_pdfdoc, buf)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'fromXpsMem'. Expected "+2+" arguments. Function Signature: fromXpsMem(PDFDoc, ArrayBuffer)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'fromXpsMem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'fromXpsMem' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: fromXpsMem(PDFDoc, ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'fromXpsMem' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: fromXpsMem(PDFDoc, ArrayBuffer).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'fromXpsMem' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'fromXpsMem' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: fromXpsMem(PDFDoc, ArrayBuffer).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'fromXpsMem' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: fromXpsMem(PDFDoc, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertFromXpsMem', {"in_pdfdoc": in_pdfdoc.id, "buf": buf.buffer}, this.userPriority);
	},

	/**
	* Convert the specified EMF to PDF and append converted pages to
	* to the specified PDF document.  EMF will be fitted to the page.
	*
	* @param in_pdfdoc the PDFDoc to append to
	*
	* @param in_filename the path to the EMF document to convert
	*
	* @note This method is available only on Windows platforms.
	*/
		PDFNet.Convert.fromEmf = function(in_pdfdoc, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'fromEmf'. Expected "+2+" arguments. Function Signature: fromEmf(PDFDoc, string)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'fromEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'fromEmf' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: fromEmf(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'fromEmf' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: fromEmf(PDFDoc, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'fromEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'fromEmf' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: fromEmf(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertFromEmf', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename}, this.userPriority);
	},

		PDFNet.Convert.pageToEmf = function(in_page, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'pageToEmf'. Expected "+2+" arguments. Function Signature: pageToEmf(Page, string)")};
		if(in_page instanceof Promise) {throw new TypeError("1st input argument in function 'pageToEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_page instanceof PDFNet.Page)) {
			if(typeof in_page == "object") {throw new TypeError("1st input argument in function 'pageToEmf' is of type '"+in_page.name+"'. Expected type 'Page'. Function Signature: pageToEmf(Page, string).");}
			else {throw new TypeError("1st input argument '"+in_page+"' in function 'pageToEmf' is of type '"+(typeof in_page)+"'. Expected type 'Page'. Function Signature: pageToEmf(Page, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'pageToEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'pageToEmf' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: pageToEmf(Page, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertPageToEmf', {"in_page": in_page.id, "in_filename": in_filename}, this.userPriority);
	},

		PDFNet.Convert.docToEmf = function(in_pdfdoc, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'docToEmf'. Expected "+2+" arguments. Function Signature: docToEmf(PDFDoc, string)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'docToEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'docToEmf' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: docToEmf(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'docToEmf' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: docToEmf(PDFDoc, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'docToEmf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'docToEmf' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: docToEmf(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertDocToEmf', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename}, this.userPriority);
	},

	/**
	* Convert the specified plain Text file to PDF and append converted
	* pages to the specified PDF document.
	*
	* @param in_pdfdoc the PDFDoc to append to
	*
	* @param in_filename the path to the plain text document to convert
	*
	* @note in_options the conversion options
	*/
		PDFNet.Convert.fromText = function(in_pdfdoc, in_filename, options)
	{
		if(typeof options === "undefined") {options = new PDFNet.Obj("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'fromText'. Expected "+2+" to "+3+" arguments. Function Signature: fromText(PDFDoc, string, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'fromText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'fromText' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: fromText(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'fromText' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: fromText(PDFDoc, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'fromText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'fromText' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: fromText(PDFDoc, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'fromText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'fromText' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: fromText(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'fromText' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: fromText(PDFDoc, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertFromText', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.pageToSvg = function(in_page, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'pageToSvg'. Expected "+2+" arguments. Function Signature: pageToSvg(Page, string)")};
		if(in_page instanceof Promise) {throw new TypeError("1st input argument in function 'pageToSvg' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_page instanceof PDFNet.Page)) {
			if(typeof in_page == "object") {throw new TypeError("1st input argument in function 'pageToSvg' is of type '"+in_page.name+"'. Expected type 'Page'. Function Signature: pageToSvg(Page, string).");}
			else {throw new TypeError("1st input argument '"+in_page+"' in function 'pageToSvg' is of type '"+(typeof in_page)+"'. Expected type 'Page'. Function Signature: pageToSvg(Page, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'pageToSvg' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'pageToSvg' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: pageToSvg(Page, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertPageToSvg', {"in_page": in_page.id, "in_filename": in_filename}, this.userPriority);
	},

		PDFNet.Convert.pageToSvgWithOptions = function(in_page, in_filename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'pageToSvgWithOptions'. Expected "+3+" arguments. Function Signature: pageToSvgWithOptions(Page, string, Obj)")};
		if(in_page instanceof Promise) {throw new TypeError("1st input argument in function 'pageToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_page instanceof PDFNet.Page)) {
			if(typeof in_page == "object") {throw new TypeError("1st input argument in function 'pageToSvgWithOptions' is of type '"+in_page.name+"'. Expected type 'Page'. Function Signature: pageToSvgWithOptions(Page, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_page+"' in function 'pageToSvgWithOptions' is of type '"+(typeof in_page)+"'. Expected type 'Page'. Function Signature: pageToSvgWithOptions(Page, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'pageToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'pageToSvgWithOptions' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: pageToSvgWithOptions(Page, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'pageToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'pageToSvgWithOptions' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: pageToSvgWithOptions(Page, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'pageToSvgWithOptions' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: pageToSvgWithOptions(Page, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertPageToSvgWithOptions', {"in_page": in_page.id, "in_filename": in_filename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.docToSvg = function(in_pdfdoc, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'docToSvg'. Expected "+2+" arguments. Function Signature: docToSvg(PDFDoc, string)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'docToSvg' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'docToSvg' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: docToSvg(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'docToSvg' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: docToSvg(PDFDoc, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'docToSvg' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'docToSvg' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: docToSvg(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertDocToSvg', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename}, this.userPriority);
	},

		PDFNet.Convert.docToSvgWithOptions = function(in_pdfdoc, in_filename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'docToSvgWithOptions'. Expected "+3+" arguments. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'docToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'docToSvgWithOptions' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'docToSvgWithOptions' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'docToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'docToSvgWithOptions' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'docToSvgWithOptions' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'docToSvgWithOptions' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'docToSvgWithOptions' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: docToSvgWithOptions(PDFDoc, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertDocToSvgWithOptions', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.toXps = function(in_pdfdoc, in_filename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'toXps'. Expected "+3+" arguments. Function Signature: toXps(PDFDoc, string, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'toXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'toXps' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: toXps(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'toXps' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: toXps(PDFDoc, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'toXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'toXps' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: toXps(PDFDoc, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'toXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'toXps' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: toXps(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'toXps' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: toXps(PDFDoc, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertToXps', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.fileToXps = function(in_inputFilename, in_outputFilename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'fileToXps'. Expected "+3+" arguments. Function Signature: fileToXps(string, string, Obj)")};
		if(in_inputFilename instanceof Promise) {throw new TypeError("1st input argument in function 'fileToXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_inputFilename != "string") {throw new TypeError("1st input argument '"+in_inputFilename+"' in function 'fileToXps' is of type '"+(typeof in_inputFilename)+"'. Expected type 'string'. Function Signature: fileToXps(string, string, Obj).");}
		if(in_outputFilename instanceof Promise) {throw new TypeError("2nd input argument in function 'fileToXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_outputFilename != "string") {throw new TypeError("2nd input argument '"+in_outputFilename+"' in function 'fileToXps' is of type '"+(typeof in_outputFilename)+"'. Expected type 'string'. Function Signature: fileToXps(string, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'fileToXps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'fileToXps' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: fileToXps(string, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'fileToXps' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: fileToXps(string, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertFileToXps', {"in_inputFilename": in_inputFilename, "in_outputFilename": in_outputFilename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.fileToXodStream = function(in_filename, options)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'fileToXodStream'. Expected "+2+" arguments. Function Signature: fileToXodStream(string, Obj)")};
		if(in_filename instanceof Promise) {throw new TypeError("1st input argument in function 'fileToXodStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("1st input argument '"+in_filename+"' in function 'fileToXodStream' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: fileToXodStream(string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("2nd input argument in function 'fileToXodStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("2nd input argument in function 'fileToXodStream' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: fileToXodStream(string, Obj).");}
			else {throw new TypeError("2nd input argument '"+options+"' in function 'fileToXodStream' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: fileToXodStream(string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertFileToXodStream', {"in_filename": in_filename, "options": options.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.Convert.toXodWithMonitor = function(in_pdfdoc, options)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'toXodWithMonitor'. Expected "+2+" arguments. Function Signature: toXodWithMonitor(PDFDoc, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'toXodWithMonitor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'toXodWithMonitor' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: toXodWithMonitor(PDFDoc, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'toXodWithMonitor' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: toXodWithMonitor(PDFDoc, Obj).");}
		}
		if(options instanceof Promise) {throw new TypeError("2nd input argument in function 'toXodWithMonitor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("2nd input argument in function 'toXodWithMonitor' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: toXodWithMonitor(PDFDoc, Obj).");}
			else {throw new TypeError("2nd input argument '"+options+"' in function 'toXodWithMonitor' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: toXodWithMonitor(PDFDoc, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertToXodWithMonitor', {"in_pdfdoc": in_pdfdoc.id, "options": options.id}, this.userPriority).then(function(id){
			//there is a return type ConversionMonitor
			if(id == "0"){
				return null;
			}
			return new PDFNet.ConversionMonitor(id);
		});
	},

		PDFNet.ConversionMonitor.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('ConversionMonitor.next', {"conversionMonitor": this.id}, this.userPriority);
	},

		PDFNet.ConversionMonitor.prototype.ready = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'ready'. Expected "+0+" arguments. Function Signature: ready()")};
		return PDFNet.messageHandler.sendWithPromise('ConversionMonitor.ready', {"conversionMonitor": this.id}, this.userPriority);
	},

		PDFNet.ConversionMonitor.prototype.progress = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'progress'. Expected "+0+" arguments. Function Signature: progress()")};
		return PDFNet.messageHandler.sendWithPromise('ConversionMonitor.progress', {"conversionMonitor": this.id}, this.userPriority);
	},

		PDFNet.ConversionMonitor.prototype.filter = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'filter'. Expected "+0+" arguments. Function Signature: filter()")};
		return PDFNet.messageHandler.sendWithPromise('ConversionMonitor.filter', {"conversionMonitor": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.ConversionMonitor.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ConversionMonitor.destroy', {"conversionMonitor": this.id}, this.userPriority);
	},

		PDFNet.Convert.wordToPdf = function(in_pdfdoc, in_filename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'wordToPdf'. Expected "+3+" arguments. Function Signature: wordToPdf(PDFDoc, string, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'wordToPdf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'wordToPdf' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: wordToPdf(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'wordToPdf' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: wordToPdf(PDFDoc, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'wordToPdf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'wordToPdf' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: wordToPdf(PDFDoc, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'wordToPdf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'wordToPdf' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: wordToPdf(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'wordToPdf' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: wordToPdf(PDFDoc, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertWordToPdf', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.wordToPdfConversion = function(in_pdfdoc, in_filename, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'wordToPdfConversion'. Expected "+3+" arguments. Function Signature: wordToPdfConversion(PDFDoc, string, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'wordToPdfConversion' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'wordToPdfConversion' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfConversion(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'wordToPdfConversion' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfConversion(PDFDoc, string, Obj).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'wordToPdfConversion' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'wordToPdfConversion' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: wordToPdfConversion(PDFDoc, string, Obj).");}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'wordToPdfConversion' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'wordToPdfConversion' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: wordToPdfConversion(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'wordToPdfConversion' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: wordToPdfConversion(PDFDoc, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertWordToPdfConversion', {"in_pdfdoc": in_pdfdoc, "in_filename": in_filename, "options": options.id}, this.userPriority).then(function(id){
			//there is a return type DocumentConversion
			if(id == "0"){
				return null;
			}
			return new PDFNet.DocumentConversion(id);
		});
	},

		PDFNet.Convert.wordToPdfWithFilter = function(in_pdfdoc, in_data, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'wordToPdfWithFilter'. Expected "+3+" arguments. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'wordToPdfWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'wordToPdfWithFilter' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'wordToPdfWithFilter' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
		}
		if(in_data instanceof Promise) {throw new TypeError("2nd input argument in function 'wordToPdfWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_data instanceof PDFNet.Filter)) {
			if(typeof in_data == "object") {throw new TypeError("2nd input argument in function 'wordToPdfWithFilter' is of type '"+in_data.name+"'. Expected type 'Filter'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("2nd input argument '"+in_data+"' in function 'wordToPdfWithFilter' is of type '"+(typeof in_data)+"'. Expected type 'Filter'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
		}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'wordToPdfWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'wordToPdfWithFilter' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'wordToPdfWithFilter' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: wordToPdfWithFilter(PDFDoc, Filter, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertWordToPdfWithFilter', {"in_pdfdoc": in_pdfdoc.id, "in_data": in_data.id, "options": options.id}, this.userPriority);
	},

		PDFNet.Convert.wordToPdfConversionWithFilter = function(in_pdfdoc, in_data, options)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'wordToPdfConversionWithFilter'. Expected "+3+" arguments. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'wordToPdfConversionWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'wordToPdfConversionWithFilter' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'wordToPdfConversionWithFilter' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
		}
		if(in_data instanceof Promise) {throw new TypeError("2nd input argument in function 'wordToPdfConversionWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_data instanceof PDFNet.Filter)) {
			if(typeof in_data == "object") {throw new TypeError("2nd input argument in function 'wordToPdfConversionWithFilter' is of type '"+in_data.name+"'. Expected type 'Filter'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("2nd input argument '"+in_data+"' in function 'wordToPdfConversionWithFilter' is of type '"+(typeof in_data)+"'. Expected type 'Filter'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
		}
		if(options instanceof Promise) {throw new TypeError("3rd input argument in function 'wordToPdfConversionWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(options instanceof PDFNet.Obj)) {
			if(typeof options == "object") {throw new TypeError("3rd input argument in function 'wordToPdfConversionWithFilter' is of type '"+options.name+"'. Expected type 'Obj'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
			else {throw new TypeError("3rd input argument '"+options+"' in function 'wordToPdfConversionWithFilter' is of type '"+(typeof options)+"'. Expected type 'Obj'. Function Signature: wordToPdfConversionWithFilter(PDFDoc, Filter, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('convertWordToPdfConversionWithFilter', {"in_pdfdoc": in_pdfdoc, "in_data": in_data.id, "options": options.id}, this.userPriority).then(function(id){
			//there is a return type DocumentConversion
			if(id == "0"){
				return null;
			}
			return new PDFNet.DocumentConversion(id);
		});
	},

	/**
	* convert the file or document to PDF and append to the specified PDF document
	*
	* @param in_pdfdoc the PDFDoc to append the converted document to. The
	* PDFDoc can then be converted to XPS, EMF or SVG using the other functions
	* in this class.
	*
	* @param in_filename the path to the document to be converted to pdf
	*
	* @note Internally formats include BMP, EMF, JPEG, PNG, TIF, XPS.
	*
	* @note Formats that require external applications for conversion use the
	* Convert::Printer class and the PDFNet printer to be installed. This is
	* only supported on Windows platforms.  Document formats in this category
	* include RTF(MS Word or Wordpad), TXT (Notepad or Wordpad), DOC and DOCX
	* (MS Word), PPT and PPTX (MS PowerPoint), XLS and XLSX (MS Excel),
	* OpenOffice documents, HTML and MHT (Internet Explorer), PUB (MS Publisher),
	* MSG (MS Outlook).
	*/
		PDFNet.Convert.toPdf = function(in_pdfdoc, in_filename)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'toPdf'. Expected "+2+" arguments. Function Signature: toPdf(PDFDoc, string)")};
		if(in_pdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'toPdf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(in_pdfdoc instanceof PDFNet.PDFDoc || in_pdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof in_pdfdoc == "object") {throw new TypeError("1st input argument in function 'toPdf' is of type '"+in_pdfdoc.name+"'. Expected type 'PDFDoc'. Function Signature: toPdf(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+in_pdfdoc+"' in function 'toPdf' is of type '"+(typeof in_pdfdoc)+"'. Expected type 'PDFDoc'. Function Signature: toPdf(PDFDoc, string).");}
		}
		if(in_filename instanceof Promise) {throw new TypeError("2nd input argument in function 'toPdf' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("2nd input argument '"+in_filename+"' in function 'toPdf' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: toPdf(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('convertToPdf', {"in_pdfdoc": in_pdfdoc.id, "in_filename": in_filename}, this.userPriority);
	},

	/**
	* Utility function to determine if ToPdf or ToXps will require the PDFNet
	* printer to convert a specific external file to PDF.
	*
	* @param in_filename the path to the document to be checked
	*
	* @return A promise that resolves to true if ToPdf requires the printer to convert the file, false
	* otherwise.
	*
	* @note Current implementation looks only at the file extension not
	* file contents. If the file extension is missing, false will be returned
	*/
		PDFNet.Convert.requiresPrinter = function(in_filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'requiresPrinter'. Expected "+1+" argument. Function Signature: requiresPrinter(string)")};
		if(in_filename instanceof Promise) {throw new TypeError("1st input argument in function 'requiresPrinter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_filename != "string") {throw new TypeError("1st input argument '"+in_filename+"' in function 'requiresPrinter' is of type '"+(typeof in_filename)+"'. Expected type 'string'. Function Signature: requiresPrinter(string).");}
		return PDFNet.messageHandler.sendWithPromise('convertRequiresPrinter', {"in_filename": in_filename}, this.userPriority);
	},

		PDFNet.Convert.printerInstall = function(in_printerName)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'printerInstall'. Expected "+1+" argument. Function Signature: printerInstall(string)")};
		if(in_printerName instanceof Promise) {throw new TypeError("1st input argument in function 'printerInstall' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_printerName != "string") {throw new TypeError("1st input argument '"+in_printerName+"' in function 'printerInstall' is of type '"+(typeof in_printerName)+"'. Expected type 'string'. Function Signature: printerInstall(string).");}
		return PDFNet.messageHandler.sendWithPromise('convertPrinterInstall', {"in_printerName": in_printerName}, this.userPriority);
	},

		PDFNet.Convert.printerUninstall = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'printerUninstall'. Expected "+0+" arguments. Function Signature: printerUninstall()")};
		return PDFNet.messageHandler.sendWithPromise('convertPrinterUninstall', {}, this.userPriority);
	},

		PDFNet.Convert.printerGetPrinterName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'printerGetPrinterName'. Expected "+0+" arguments. Function Signature: printerGetPrinterName()")};
		return PDFNet.messageHandler.sendWithPromise('convertPrinterGetPrinterName', {}, this.userPriority);
	},

		PDFNet.Convert.printerSetPrinterName = function(in_printerName)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'printerSetPrinterName'. Expected "+1+" argument. Function Signature: printerSetPrinterName(string)")};
		if(in_printerName instanceof Promise) {throw new TypeError("1st input argument in function 'printerSetPrinterName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_printerName != "string") {throw new TypeError("1st input argument '"+in_printerName+"' in function 'printerSetPrinterName' is of type '"+(typeof in_printerName)+"'. Expected type 'string'. Function Signature: printerSetPrinterName(string).");}
		return PDFNet.messageHandler.sendWithPromise('convertPrinterSetPrinterName', {"in_printerName": in_printerName}, this.userPriority);
	},

		PDFNet.Convert.printerIsInstalled = function(in_printerName)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'printerIsInstalled'. Expected "+1+" argument. Function Signature: printerIsInstalled(string)")};
		if(in_printerName instanceof Promise) {throw new TypeError("1st input argument in function 'printerIsInstalled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_printerName != "string") {throw new TypeError("1st input argument '"+in_printerName+"' in function 'printerIsInstalled' is of type '"+(typeof in_printerName)+"'. Expected type 'string'. Function Signature: printerIsInstalled(string).");}
		return PDFNet.messageHandler.sendWithPromise('convertPrinterIsInstalled', {"in_printerName": in_printerName}, this.userPriority);
	},

	/**
	* Create a Date and initialize it using specified parameters.
	* The Date is not attached to any Cos/SDF object.
	*/
		PDFNet.Date.init = function(year, month, day, hour, minute, second)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'init'. Expected "+6+" arguments. Function Signature: init(number, number, number, number, number, number)")};
		if(year instanceof Promise) {throw new TypeError("1st input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof year != "number") {throw new TypeError("1st input argument '"+year+"' in function 'init' is of type '"+(typeof year)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		if(month instanceof Promise) {throw new TypeError("2nd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof month != "number") {throw new TypeError("2nd input argument '"+month+"' in function 'init' is of type '"+(typeof month)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		if(day instanceof Promise) {throw new TypeError("3rd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof day != "number") {throw new TypeError("3rd input argument '"+day+"' in function 'init' is of type '"+(typeof day)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		if(hour instanceof Promise) {throw new TypeError("4th input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hour != "number") {throw new TypeError("4th input argument '"+hour+"' in function 'init' is of type '"+(typeof hour)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		if(minute instanceof Promise) {throw new TypeError("5th input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof minute != "number") {throw new TypeError("5th input argument '"+minute+"' in function 'init' is of type '"+(typeof minute)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		if(second instanceof Promise) {throw new TypeError("6th input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof second != "number") {throw new TypeError("6th input argument '"+second+"' in function 'init' is of type '"+(typeof second)+"'. Expected type 'number'. Function Signature: init(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('dateInit', {"year": year, "month": month, "day": day, "hour": hour, "minute": minute, "second": second}, this.userPriority).then(function(id){
			//there is a return type Date
			if(id == "0"){
				return null;
			}
			return new PDFNet.Date(id);
		});
	},

		PDFNet.Date.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Date)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Date) && right.name != "Date") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Date'. Function Signature: assign(Date).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Date'. Function Signature: assign(Date).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Date.assign"; // TRN_Date* left
		return PDFNet.messageHandler.sendWithPromise('Date.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Indicates whether the Date is valid (non-null).
	*
	* @return A promise that resolves to true if this is a valid (non-null) Date; otherwise false.
	*
	* @note If this method returns false the underlying SDF/Cos object is null and
	* the Date object should be treated as null as well.
	*/
		PDFNet.Date.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Date.isValid', {"date": this}, this.userPriority);
	},

	/**
	* attach the Cos/SDF object to the Date.
	*
	* @param d - underlying Cos/SDF object. Must be an SDF::Str containing
	*  a PDF date object.
	*/
		PDFNet.Date.prototype.attach = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'attach'. Expected "+1+" argument. Function Signature: attach(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'attach' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'attach' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: attach(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'attach' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: attach(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'attach'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Date.attach"; // TRN_Date* date
		return PDFNet.messageHandler.sendWithPromise('Date.attach', {"date": this, "d": d.id}, this.userPriority).then(function(id){
			copyFunc(id.date, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Saves changes made to the Date object in the attached (or specified) SDF/Cos string.
	*
	* @param d - an optional parameter indicating a SDF string that should be
	*  updated and attached to this Date. If parameter d is NULL or is omitted, update
	*  is performed on previously attached Cos/SDF date.
	*
	* @return A promise that resolves to true if the attached Cos/SDF string was successfully updated, false otherwise.
	*/
		PDFNet.Date.prototype.update = function(d)
	{
		if(typeof d === "undefined") {d = new PDFNet.Obj("__null");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'update'. Expected at most "+1+" arguments. Function Signature: update(Obj)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'update' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.Obj)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'update' is of type '"+d.name+"'. Expected type 'Obj'. Function Signature: update(Obj).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'update' is of type '"+(typeof d)+"'. Expected type 'Obj'. Function Signature: update(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'update'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Date.update"; // TRN_Date* date
		return PDFNet.messageHandler.sendWithPromise('Date.update', {"date": this, "d": d.id}, this.userPriority).then(function(id){
			copyFunc(id.date, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* Create a new 'XYZ' Destination.
	*
	* The new Destination displays the page designated by 'page', with the
	* coordinates ('left', 'top') positioned at the top-left corner of the
	* window and the contents of the page magnified by the factor 'zoom'.
	* A null value for any of the parameters 'left', 'top', or 'zoom' specifies
	* that the current value of that parameter is to be retained unchanged.
	* A 'zoom' value of 0 has the same meaning as a null value.
	*/
		PDFNet.Destination.createXYZ = function(page, left, top, zoom)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'createXYZ'. Expected "+4+" arguments. Function Signature: createXYZ(Page, number, number, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createXYZ' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createXYZ' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createXYZ(Page, number, number, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createXYZ' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createXYZ(Page, number, number, number).");}
		}
		if(left instanceof Promise) {throw new TypeError("2nd input argument in function 'createXYZ' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left != "number") {throw new TypeError("2nd input argument '"+left+"' in function 'createXYZ' is of type '"+(typeof left)+"'. Expected type 'number'. Function Signature: createXYZ(Page, number, number, number).");}
		if(top instanceof Promise) {throw new TypeError("3rd input argument in function 'createXYZ' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof top != "number") {throw new TypeError("3rd input argument '"+top+"' in function 'createXYZ' is of type '"+(typeof top)+"'. Expected type 'number'. Function Signature: createXYZ(Page, number, number, number).");}
		if(zoom instanceof Promise) {throw new TypeError("4th input argument in function 'createXYZ' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof zoom != "number") {throw new TypeError("4th input argument '"+zoom+"' in function 'createXYZ' is of type '"+(typeof zoom)+"'. Expected type 'number'. Function Signature: createXYZ(Page, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateXYZ', {"page": page.id, "left": left, "top": top, "zoom": zoom}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'Fit' Destination.
	*
	* The new Destination displays the page designated by 'page', with its contents
	* magnified just enough to fit the entire page within the window both
	* horizontally and vertically. If the required horizontal and vertical
	* magnification factors are different, use the smaller of the two, centering
	* the page within the window in the other dimension.
	*/
		PDFNet.Destination.createFit = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFit'. Expected "+1+" argument. Function Signature: createFit(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFit' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFit' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFit(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFit' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFit(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFit', {"page": page.id}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitH' Destination.
	*
	* The new Destination displays the page designated by 'page', with the
	* vertical coordinate 'top' positioned at the top edge of the window and
	* the contents of the page magnified just enough to fit the entire width
	* of the page within the window.
	*/
		PDFNet.Destination.createFitH = function(page, top)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFitH'. Expected "+2+" arguments. Function Signature: createFitH(Page, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitH' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitH' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitH(Page, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitH' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitH(Page, number).");}
		}
		if(top instanceof Promise) {throw new TypeError("2nd input argument in function 'createFitH' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof top != "number") {throw new TypeError("2nd input argument '"+top+"' in function 'createFitH' is of type '"+(typeof top)+"'. Expected type 'number'. Function Signature: createFitH(Page, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitH', {"page": page.id, "top": top}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitV' Destination.
	*
	* The new Destination displays the page designated by 'page', with the
	* horizontal coordinate 'left' positioned at the left edge of the window
	* and the contents of the page magnified just enough to fit the entire
	* height of the page within the window.
	*/
		PDFNet.Destination.createFitV = function(page, left)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFitV'. Expected "+2+" arguments. Function Signature: createFitV(Page, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitV' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitV' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitV(Page, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitV' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitV(Page, number).");}
		}
		if(left instanceof Promise) {throw new TypeError("2nd input argument in function 'createFitV' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left != "number") {throw new TypeError("2nd input argument '"+left+"' in function 'createFitV' is of type '"+(typeof left)+"'. Expected type 'number'. Function Signature: createFitV(Page, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitV', {"page": page.id, "left": left}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitR' Destination.
	*
	* The new Destination displays the page designated by 'page', with its
	* contents magnified just enough to fit the rectangle specified by the
	* coordinates 'left', 'bottom', 'right', and 'top' entirely within the
	* window both horizontally and vertically. If the required horizontal
	* and vertical magnification factors are different, use the smaller of
	* the two, centering the rectangle within the window in the other
	* dimension.
	*/
		PDFNet.Destination.createFitR = function(page, left, bottom, right, top)
	{
		if(arguments.length != 5) {throw new RangeError(arguments.length+" arguments passed into function 'createFitR'. Expected "+5+" arguments. Function Signature: createFitR(Page, number, number, number, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitR' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitR(Page, number, number, number, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitR' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitR(Page, number, number, number, number).");}
		}
		if(left instanceof Promise) {throw new TypeError("2nd input argument in function 'createFitR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left != "number") {throw new TypeError("2nd input argument '"+left+"' in function 'createFitR' is of type '"+(typeof left)+"'. Expected type 'number'. Function Signature: createFitR(Page, number, number, number, number).");}
		if(bottom instanceof Promise) {throw new TypeError("3rd input argument in function 'createFitR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bottom != "number") {throw new TypeError("3rd input argument '"+bottom+"' in function 'createFitR' is of type '"+(typeof bottom)+"'. Expected type 'number'. Function Signature: createFitR(Page, number, number, number, number).");}
		if(right instanceof Promise) {throw new TypeError("4th input argument in function 'createFitR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof right != "number") {throw new TypeError("4th input argument '"+right+"' in function 'createFitR' is of type '"+(typeof right)+"'. Expected type 'number'. Function Signature: createFitR(Page, number, number, number, number).");}
		if(top instanceof Promise) {throw new TypeError("5th input argument in function 'createFitR' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof top != "number") {throw new TypeError("5th input argument '"+top+"' in function 'createFitR' is of type '"+(typeof top)+"'. Expected type 'number'. Function Signature: createFitR(Page, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitR', {"page": page.id, "left": left, "bottom": bottom, "right": right, "top": top}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitB' Destination.
	*
	* The new Destination displays the page designated by 'page', with its
	* contents magnified just enough to fit its bounding box entirely within
	* the window both horizontally and vertically. If the required
	* horizontal and vertical magnification factors are different, use the
	* smaller of the two, centering the bounding box within the window in
	* the other dimension.
	*/
		PDFNet.Destination.createFitB = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFitB'. Expected "+1+" argument. Function Signature: createFitB(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitB' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitB' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitB(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitB' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitB(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitB', {"page": page.id}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitBH' Destination.
	*
	* The new Destination displays the page designated by 'page', with
	* the vertical coordinate 'top' positioned at the top edge of the window
	* and the contents of the page magnified just enough to fit the entire
	* width of its bounding box within the window.
	*/
		PDFNet.Destination.createFitBH = function(page, top)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFitBH'. Expected "+2+" arguments. Function Signature: createFitBH(Page, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitBH' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitBH' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitBH(Page, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitBH' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitBH(Page, number).");}
		}
		if(top instanceof Promise) {throw new TypeError("2nd input argument in function 'createFitBH' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof top != "number") {throw new TypeError("2nd input argument '"+top+"' in function 'createFitBH' is of type '"+(typeof top)+"'. Expected type 'number'. Function Signature: createFitBH(Page, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitBH', {"page": page.id, "top": top}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a new 'FitBV' Destination.
	*
	* The new Destination displays Display the page designated by 'page',
	* with the horizontal coordinate 'left' positioned at the left edge of
	* the window and the contents of the page magnified just enough to fit
	* the entire height of its bounding box within the window.
	*/
		PDFNet.Destination.createFitBV = function(page, left)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFitBV'. Expected "+2+" arguments. Function Signature: createFitBV(Page, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFitBV' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFitBV' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFitBV(Page, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFitBV' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFitBV(Page, number).");}
		}
		if(left instanceof Promise) {throw new TypeError("2nd input argument in function 'createFitBV' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left != "number") {throw new TypeError("2nd input argument '"+left+"' in function 'createFitBV' is of type '"+(typeof left)+"'. Expected type 'number'. Function Signature: createFitBV(Page, number).");}
		return PDFNet.messageHandler.sendWithPromise('destinationCreateFitBV', {"page": page.id, "left": left}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* Create a Destination and initialize it using given Cos/SDF object.
	*
	* @param dest - a low-level (SDF/Cos) destination object. The low-level
	* destination can be either a named destination (i.e. a Name or a String)
	* or an explicit destination (i.e. an Array Obj). Please refer to section
	* 8.2.1 'Destinations' in PDF Reference Manual for more details.
	*
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*
	* @note Named destinations (in case 'dest' is a Name or a String) are
	* automatically resolved to the explicit destination. If the name can't
	* be resolved to the explicit destination dest.IsValid() will return false.
	*/
		PDFNet.Destination.create = function(dest)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(dest instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest instanceof PDFNet.Obj)) {
			if(typeof dest == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+dest.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+dest+"' in function 'create' is of type '"+(typeof dest)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('destinationCreate', {"dest": dest.id}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

		PDFNet.Destination.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.copy', {"d": this.id}, this.userPriority).then(function(id){
			//there is a return type Destination
			if(id == "0"){
				return null;
			}
			return new PDFNet.Destination(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a valid Destination and can be resolved, false otherwise.
	*
	* @note If this method returns false the underlying SDF/Cos object is null and
	* the Action object should be treated as null as well.
	*/
		PDFNet.Destination.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.isValid', {"dest": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to destination's FitType.
	* @exception An Exception is thrown if this is not a valid Destination.
	*/
		PDFNet.Destination.prototype.getFitType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFitType'. Expected "+0+" arguments. Function Signature: getFitType()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.getFitType', {"dest": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Page that this destination refers to.
	* @exception An Exception is thrown if this is not a valid Destination.
	*/
		PDFNet.Destination.prototype.getPage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPage'. Expected "+0+" arguments. Function Signature: getPage()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.getPage', {"dest": this.id}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

	/**
	* Modify the destination so that it refers to the new 'page' as the destination page.
	*
	* @param page The new page associated with this Destination.
	* @exception An Exception is thrown if this is not a valid Destination.
	*/
		PDFNet.Destination.prototype.setPage = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPage'. Expected "+1+" argument. Function Signature: setPage(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'setPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'setPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: setPage(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'setPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: setPage(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Destination.setPage', {"dest": this.id, "page": page.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the object to the underlying SDF/Cos object.
	* The returned SDF/Cos object is an explicit destination (i.e. the Obj is either
	* an array defining the destination, using the syntax shown in Table 8.2 in PDF
	* Reference Manual), or a dictionary with a 'D' entry whose value is such an
	* array. The latter form allows additional attributes to be associated with
	* the destination
	*/
		PDFNet.Destination.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.getSDFObj', {"dest": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the explicit destination SDF/Cos object. This is always an Array
	* as shown in Table 8.2 in PDF Reference Manual.
	*
	* @exception An Exception is thrown if this is not a valid Destination.
	*/
		PDFNet.Destination.prototype.getExplicitDestObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getExplicitDestObj'. Expected "+0+" arguments. Function Signature: getExplicitDestObj()")};
		return PDFNet.messageHandler.sendWithPromise('Destination.getExplicitDestObj', {"dest": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the transformation matrix for this element.
	* @note If you are looking for a matrix that maps coordinates to the initial
	* user space see Element::GetCTM().
	*/
		PDFNet.GState.prototype.getTransform = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTransform'. Expected "+0+" arguments. Function Signature: getTransform()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getTransform', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to color space used for stroking
	*/
		PDFNet.GState.prototype.getStrokeColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStrokeColorSpace'. Expected "+0+" arguments. Function Signature: getStrokeColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getStrokeColorSpace', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to color space used for filling
	*/
		PDFNet.GState.prototype.getFillColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFillColorSpace'. Expected "+0+" arguments. Function Signature: getFillColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFillColorSpace', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to a color value/point represented in the current stroke color space
	*/
		PDFNet.GState.prototype.getStrokeColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStrokeColor'. Expected "+0+" arguments. Function Signature: getStrokeColor()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getStrokeColor', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* @return A promise that resolves to the SDF pattern object of currently selected PatternColorSpace used for stroking.
	*/
		PDFNet.GState.prototype.getStrokePattern = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStrokePattern'. Expected "+0+" arguments. Function Signature: getStrokePattern()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getStrokePattern', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type PatternColor
			if(id == "0"){
				return null;
			}
			return new PDFNet.PatternColor(id);
		});
	},

	/**
	* @return A promise that resolves to a color value/point represented in the current fill color space
	*/
		PDFNet.GState.prototype.getFillColor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFillColor'. Expected "+0+" arguments. Function Signature: getFillColor()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFillColor', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* @return A promise that resolves to the pattern color of currently selected pattern color space used for filling.
	*/
		PDFNet.GState.prototype.getFillPattern = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFillPattern'. Expected "+0+" arguments. Function Signature: getFillPattern()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFillPattern', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type PatternColor
			if(id == "0"){
				return null;
			}
			return new PDFNet.PatternColor(id);
		});
	},

	/**
	* @return A promise that resolves to current value of flatness tolerance
	*
	* Flatness is a number in the range 0 to 100; a value of 0 specifies the output
	* device's default flatness tolerance.
	*
	* The flatness tolerance controls the maximum permitted distance in device pixels
	* between the mathematically correct path and an approximation constructed from
	* straight line segments.
	*/
		PDFNet.GState.prototype.getFlatness = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFlatness'. Expected "+0+" arguments. Function Signature: getFlatness()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFlatness', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected LineCap style
	*
	* The line cap style specifies the shape to be used at the ends of open sub-paths
	* (and dashes, if any) when they are stroked.
	*/
		PDFNet.GState.prototype.getLineCap = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLineCap'. Expected "+0+" arguments. Function Signature: getLineCap()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getLineCap', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected LineJoin style
	*
	* The line join style specifies the shape to be used at the corners of paths that
	* are stroked.
	*/
		PDFNet.GState.prototype.getLineJoin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLineJoin'. Expected "+0+" arguments. Function Signature: getLineJoin()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getLineJoin', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the thickness of the line used to stroke a path.
	* @note A line width of 0 denotes the thinnest line that can be rendered at device
	* resolution: 1 device pixel wide.
	*/
		PDFNet.GState.prototype.getLineWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLineWidth'. Expected "+0+" arguments. Function Signature: getLineWidth()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getLineWidth', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to current value of miter limit.
	*
	* The miter limit imposes a maximum on the ratio of the miter length to the
	* line width. When the limit is exceeded, the join is converted from a miter
	* to a bevel.
	*/
		PDFNet.GState.prototype.getMiterLimit = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMiterLimit'. Expected "+0+" arguments. Function Signature: getMiterLimit()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getMiterLimit', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the phase of the currently selected dash pattern. dash phase is expressed in
	* user space units.
	*/
		PDFNet.GState.prototype.getPhase = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPhase'. Expected "+0+" arguments. Function Signature: getPhase()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getPhase', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected character spacing.
	*
	* The character spacing parameter is a number specified in unscaled text space
	* units. When the glyph for each character in the string is rendered, the character
	* spacing is added to the horizontal or vertical component of the glyph's displacement,
	* depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.getCharSpacing = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCharSpacing'. Expected "+0+" arguments. Function Signature: getCharSpacing()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getCharSpacing', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected word spacing
	*
	* Word spacing works the same way as character spacing, but applies only to the
	* space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.getWordSpacing = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getWordSpacing'. Expected "+0+" arguments. Function Signature: getWordSpacing()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getWordSpacing', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected horizontal scale
	*
	* The horizontal scaling parameter adjusts the width of glyphs by stretching
	* or compressing them in the horizontal direction. Its value is specified as
	* a percentage of the normal width of the glyphs, with 100 being the normal width.
	* The scaling always applies to the horizontal coordinate in text space, independently
	* of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.getHorizontalScale = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHorizontalScale'. Expected "+0+" arguments. Function Signature: getHorizontalScale()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getHorizontalScale', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected leading parameter
	*
	* The leading parameter is measured in unscaled text space units. It specifies
	* the vertical distance between the baselines of adjacent lines of text.
	* See Section 5.2.4 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.getLeading = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLeading'. Expected "+0+" arguments. Function Signature: getLeading()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getLeading', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected font
	*/
		PDFNet.GState.prototype.getFont = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFont'. Expected "+0+" arguments. Function Signature: getFont()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFont', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* @return A promise that resolves to the font size
	*/
		PDFNet.GState.prototype.getFontSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFontSize'. Expected "+0+" arguments. Function Signature: getFontSize()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFontSize', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to current text rendering mode.
	*
	* The text rendering mode determines whether showing text causes glyph outlines to
	* be stroked, filled, used as a clipping boundary, or some combination of the three.
	* See Section 5.2.5 in PDF Reference Manual for details..
	*/
		PDFNet.GState.prototype.getTextRenderMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextRenderMode'. Expected "+0+" arguments. Function Signature: getTextRenderMode()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getTextRenderMode', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to current value of text rise
	*
	* Text rise specifies the distance, in unscaled text space units, to move the
	* baseline up or down from its default location. Positive values of text rise
	* move the baseline up
	*/
		PDFNet.GState.prototype.getTextRise = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextRise'. Expected "+0+" arguments. Function Signature: getTextRise()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getTextRise', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a boolean flag that determines the text element is considered
	* elementary objects for purposes of color compositing in the transparent imaging
	* model.
	*/
		PDFNet.GState.prototype.isTextKnockout = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isTextKnockout'. Expected "+0+" arguments. Function Signature: isTextKnockout()")};
		return PDFNet.messageHandler.sendWithPromise('GState.isTextKnockout', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the color intent to be used for rendering the Element
	*/
		PDFNet.GState.prototype.getRenderingIntent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRenderingIntent'. Expected "+0+" arguments. Function Signature: getRenderingIntent()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getRenderingIntent', {"gs": this.id}, this.userPriority);
	},

	/**
	* A utility function that maps a string representing a rendering intent to
	* RenderingIntent type.
	*
	* @return A promise that resolves to the color rendering intent type matching the specified string
	*/
		PDFNet.GState.getRenderingIntentType = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getRenderingIntentType'. Expected "+1+" argument. Function Signature: getRenderingIntentType(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getRenderingIntentType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getRenderingIntentType' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getRenderingIntentType(string).");}
		return PDFNet.messageHandler.sendWithPromise('gStateGetRenderingIntentType', {"name": name}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the current blend mode to be used in the transparent imaging model.
	* Corresponds to the /BM key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getBlendMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBlendMode'. Expected "+0+" arguments. Function Signature: getBlendMode()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getBlendMode', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the opacity value for painting operations other than stroking.
	* Returns the value of the /ca key in the ExtGState dictionary. If the value is not
	* found, the default value of 1 is returned.
	*/
		PDFNet.GState.prototype.getFillOpacity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFillOpacity'. Expected "+0+" arguments. Function Signature: getFillOpacity()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFillOpacity', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to opacity value for stroke painting operations for paths and glyph outlines.
	* Returns the value of the /CA key in the ExtGState dictionary. If the value is not
	* found, the default value of 1 is returned.
	*/
		PDFNet.GState.prototype.getStrokeOpacity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStrokeOpacity'. Expected "+0+" arguments. Function Signature: getStrokeOpacity()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getStrokeOpacity', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the alpha source flag ('alpha is shape'), specifying whether the
	* current soft mask and alpha constant are to be interpreted as shape values
	* (true) or opacity values (false).
	*/
		PDFNet.GState.prototype.getAISFlag = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAISFlag'. Expected "+0+" arguments. Function Signature: getAISFlag()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getAISFlag', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to associated soft mask. NULL if the soft mask is not selected or
	* SDF dictionary representing the soft mask otherwise.
	*/
		PDFNet.GState.prototype.getSoftMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSoftMask'. Expected "+0+" arguments. Function Signature: getSoftMask()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getSoftMask', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the soft mask transform. This is the transformation matrix at the moment the soft
	* mask is established in the graphics state with the gs operator. This information is only
	* relevant when applying the soft mask that may be specified in the graphics state to the
	* current element.
	*/
		PDFNet.GState.prototype.getSoftMaskTransform = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSoftMaskTransform'. Expected "+0+" arguments. Function Signature: getSoftMaskTransform()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getSoftMaskTransform', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to whether overprint is enabled for stroke painting operations.
	* Corresponds to the /OP key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getStrokeOverprint = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStrokeOverprint'. Expected "+0+" arguments. Function Signature: getStrokeOverprint()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getStrokeOverprint', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to whether overprint is enabled for fill painting operations.
	* Corresponds to the /op key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getFillOverprint = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFillOverprint'. Expected "+0+" arguments. Function Signature: getFillOverprint()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getFillOverprint', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the overprint mode used by this graphics state.
	* Corresponds to the /OPM key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getOverprintMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOverprintMode'. Expected "+0+" arguments. Function Signature: getOverprintMode()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getOverprintMode', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a flag specifying whether stroke adjustment is enabled in the graphics
	* state. Corresponds to the /SA key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getAutoStrokeAdjust = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAutoStrokeAdjust'. Expected "+0+" arguments. Function Signature: getAutoStrokeAdjust()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getAutoStrokeAdjust', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the smoothness tolerance used to control the quality of smooth
	* shading. Corresponds to the /SM key within the ExtGState's dictionary.
	* The allowable error (or tolerance) is expressed as a fraction of the range
	* of the color component, from 0.0 to 1.0.
	*/
		PDFNet.GState.prototype.getSmoothnessTolerance = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSmoothnessTolerance'. Expected "+0+" arguments. Function Signature: getSmoothnessTolerance()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getSmoothnessTolerance', {"gs": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected transfer function (NULL by default) used during
	* color conversion process. A transfer function adjusts the values of color
	* components to compensate for nonlinear response in an output device and in
	* the human eye. Corresponds to the /TR key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getTransferFunct = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTransferFunct'. Expected "+0+" arguments. Function Signature: getTransferFunct()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getTransferFunct', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to currently selected black-generation function (NULL by default) used
	* during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /BG key
	* within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getBlackGenFunct = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBlackGenFunct'. Expected "+0+" arguments. Function Signature: getBlackGenFunct()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getBlackGenFunct', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to currently selected undercolor-removal function (NULL by default) used
	* during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /UCR key
	* within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.getUCRFunct = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUCRFunct'. Expected "+0+" arguments. Function Signature: getUCRFunct()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getUCRFunct', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to currently selected halftone dictionary or stream (NULL by default).
	* Corresponds to the /HT key within the ExtGState's dictionary.
	* Halftoning is a process by which continuous-tone colors are approximated on an
	* output device that can achieve only a limited number of discrete colors.
	*/
		PDFNet.GState.prototype.getHalftone = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHalftone'. Expected "+0+" arguments. Function Signature: getHalftone()")};
		return PDFNet.messageHandler.sendWithPromise('GState.getHalftone', {"gs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set the transformation matrix associated with this element.
	*
	* @param mtx The new transformation for this text element.
	*
	* @note in PDF associating a transformation matrix with an element
	* ('cm' operator) will also affect all subsequent elements.
	*/
		PDFNet.GState.prototype.setTransformMatrix = function(mtx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTransformMatrix'. Expected "+1+" argument. Function Signature: setTransformMatrix(Matrix2D)")};
		if(mtx instanceof Promise) {throw new TypeError("1st input argument in function 'setTransformMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("1st input argument in function 'setTransformMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: setTransformMatrix(Matrix2D).");}
			else {throw new TypeError("1st input argument '"+mtx+"' in function 'setTransformMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: setTransformMatrix(Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setTransformMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.setTransformMatrix', {"gs": this.id, "mtx": mtx}, this.userPriority);
	},

	/**
	* Set the transformation matrix associated with this element.
	*
	* A transformation matrix in PDF is specified by six numbers, usually
	* in the form of an array containing six elements. In its most general
	* form, this array is denoted [a b c d h v]; it can represent any linear
	* transformation from one coordinate system to another. For more
	* information about PDF matrices please refer to section 4.2.2 'Common
	* Transformations' in PDF Reference Manual, and to documentation for
	* pdftron::Common::Matrix2D class.
	*
	* @param a - horizontal 'scaling' component of the new text matrix.
	* @param b - 'rotation' component of the new text matrix.
	* @param c - vertical 'scaling' component of the new text matrix.
	* @param d - 'rotation' component of the new text matrix.
	* @param h - horizontal translation component of the new text matrix.
	* @param v - vertical translation component of the new text matrix.
	*/
		PDFNet.GState.prototype.setTransform = function(a, b, c, d, h, v)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'setTransform'. Expected "+6+" arguments. Function Signature: setTransform(number, number, number, number, number, number)")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'setTransform' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("2nd input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("2nd input argument '"+b+"' in function 'setTransform' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("3rd input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("3rd input argument '"+c+"' in function 'setTransform' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("4th input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("4th input argument '"+d+"' in function 'setTransform' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("5th input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("5th input argument '"+h+"' in function 'setTransform' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("6th input argument in function 'setTransform' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("6th input argument '"+v+"' in function 'setTransform' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: setTransform(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setTransform', {"gs": this.id, "a": a, "b": b, "c": c, "d": d, "h": h, "v": v}, this.userPriority);
	},

	/**
	* Concatenate the given matrix to the transformation matrix of this element.
	*/
		PDFNet.GState.prototype.concatMatrix = function(mtx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'concatMatrix'. Expected "+1+" argument. Function Signature: concatMatrix(Matrix2D)")};
		if(mtx instanceof Promise) {throw new TypeError("1st input argument in function 'concatMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("1st input argument in function 'concatMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: concatMatrix(Matrix2D).");}
			else {throw new TypeError("1st input argument '"+mtx+"' in function 'concatMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: concatMatrix(Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'concatMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.concatMatrix', {"gs": this.id, "mtx": mtx}, this.userPriority);
	},

		PDFNet.GState.prototype.concat = function(a, b, c, d, h, v)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'concat'. Expected "+6+" arguments. Function Signature: concat(number, number, number, number, number, number)")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'concat' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("2nd input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("2nd input argument '"+b+"' in function 'concat' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("3rd input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("3rd input argument '"+c+"' in function 'concat' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("4th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("4th input argument '"+d+"' in function 'concat' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("5th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("5th input argument '"+h+"' in function 'concat' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("6th input argument in function 'concat' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("6th input argument '"+v+"' in function 'concat' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: concat(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.concat', {"gs": this.id, "a": a, "b": b, "c": c, "d": d, "h": h, "v": v}, this.userPriority);
	},

	/**
	* Sets the color space used for stroking operations
	*/
		PDFNet.GState.prototype.setStrokeColorSpace = function(cs)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeColorSpace'. Expected "+1+" argument. Function Signature: setStrokeColorSpace(ColorSpace)")};
		if(cs instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeColorSpace' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cs instanceof PDFNet.ColorSpace)) {
			if(typeof cs == "object") {throw new TypeError("1st input argument in function 'setStrokeColorSpace' is of type '"+cs.name+"'. Expected type 'ColorSpace'. Function Signature: setStrokeColorSpace(ColorSpace).");}
			else {throw new TypeError("1st input argument '"+cs+"' in function 'setStrokeColorSpace' is of type '"+(typeof cs)+"'. Expected type 'ColorSpace'. Function Signature: setStrokeColorSpace(ColorSpace).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeColorSpace', {"gs": this.id, "cs": cs.id}, this.userPriority);
	},

	/**
	* Sets the color space used for filling operations
	*/
		PDFNet.GState.prototype.setFillColorSpace = function(cs)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFillColorSpace'. Expected "+1+" argument. Function Signature: setFillColorSpace(ColorSpace)")};
		if(cs instanceof Promise) {throw new TypeError("1st input argument in function 'setFillColorSpace' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cs instanceof PDFNet.ColorSpace)) {
			if(typeof cs == "object") {throw new TypeError("1st input argument in function 'setFillColorSpace' is of type '"+cs.name+"'. Expected type 'ColorSpace'. Function Signature: setFillColorSpace(ColorSpace).");}
			else {throw new TypeError("1st input argument '"+cs+"' in function 'setFillColorSpace' is of type '"+(typeof cs)+"'. Expected type 'ColorSpace'. Function Signature: setFillColorSpace(ColorSpace).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillColorSpace', {"gs": this.id, "cs": cs.id}, this.userPriority);
	},

	/**
	* Sets the color value/point used for stroking operations.
	* The color value must be represented in the currently selected color space used
	* for stroking.
	*/
		PDFNet.GState.prototype.setStrokeColorWithColorPt = function(c)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeColorWithColorPt'. Expected "+1+" argument. Function Signature: setStrokeColorWithColorPt(ColorPt)")};
		if(c instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeColorWithColorPt' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(c instanceof PDFNet.ColorPt) && c.name != "ColorPt") {
			if(typeof c == "object") {throw new TypeError("1st input argument in function 'setStrokeColorWithColorPt' is of type '"+c.name+"'. Expected type 'ColorPt'. Function Signature: setStrokeColorWithColorPt(ColorPt).");}
			else {throw new TypeError("1st input argument '"+c+"' in function 'setStrokeColorWithColorPt' is of type '"+(typeof c)+"'. Expected type 'ColorPt'. Function Signature: setStrokeColorWithColorPt(ColorPt).");}
		}
		if(typeof c.yieldFunction != "undefined") {throw new Error("Function '"+c.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setStrokeColorWithColorPt'. Perhaps a yield statement is required for '"+c.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeColorWithColorPt', {"gs": this.id, "c": c.id}, this.userPriority);
	},

	/**
	* Set the stroke color to the given tiling pattern.
	* @param pattern SDF pattern object.
	* @note The currently selected stroke color space must be Pattern color space.
	*/
		PDFNet.GState.prototype.setStrokeColorWithPattern = function(pattern)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeColorWithPattern'. Expected "+1+" argument. Function Signature: setStrokeColorWithPattern(PatternColor)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeColorWithPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.PatternColor)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'setStrokeColorWithPattern' is of type '"+pattern.name+"'. Expected type 'PatternColor'. Function Signature: setStrokeColorWithPattern(PatternColor).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'setStrokeColorWithPattern' is of type '"+(typeof pattern)+"'. Expected type 'PatternColor'. Function Signature: setStrokeColorWithPattern(PatternColor).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeColorWithPattern', {"gs": this.id, "pattern": pattern.id}, this.userPriority);
	},

	/**
	* Set the stroke color to the given uncolored tiling pattern.
	* @param SDF pattern (PatternType = 1 and PaintType = 2) object.
	* @param c is a color in the pattern's underlying color space.
	* @note The currently selected stroke color space must be Pattern color space.
	*/
		PDFNet.GState.prototype.setStrokeColor = function(pattern, c)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeColor'. Expected "+2+" arguments. Function Signature: setStrokeColor(PatternColor, ColorPt)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.PatternColor)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'setStrokeColor' is of type '"+pattern.name+"'. Expected type 'PatternColor'. Function Signature: setStrokeColor(PatternColor, ColorPt).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'setStrokeColor' is of type '"+(typeof pattern)+"'. Expected type 'PatternColor'. Function Signature: setStrokeColor(PatternColor, ColorPt).");}
		}
		if(c instanceof Promise) {throw new TypeError("2nd input argument in function 'setStrokeColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(c instanceof PDFNet.ColorPt) && c.name != "ColorPt") {
			if(typeof c == "object") {throw new TypeError("2nd input argument in function 'setStrokeColor' is of type '"+c.name+"'. Expected type 'ColorPt'. Function Signature: setStrokeColor(PatternColor, ColorPt).");}
			else {throw new TypeError("2nd input argument '"+c+"' in function 'setStrokeColor' is of type '"+(typeof c)+"'. Expected type 'ColorPt'. Function Signature: setStrokeColor(PatternColor, ColorPt).");}
		}
		if(typeof c.yieldFunction != "undefined") {throw new Error("Function '"+c.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setStrokeColor'. Perhaps a yield statement is required for '"+c.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeColor', {"gs": this.id, "pattern": pattern.id, "c": c.id}, this.userPriority);
	},

	/**
	* Sets the color value/point used for filling operations.
	* The color value must be represented in the currently selected color space used
	* for filling.
	*/
		PDFNet.GState.prototype.setFillColorWithColorPt = function(c)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFillColorWithColorPt'. Expected "+1+" argument. Function Signature: setFillColorWithColorPt(ColorPt)")};
		if(c instanceof Promise) {throw new TypeError("1st input argument in function 'setFillColorWithColorPt' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(c instanceof PDFNet.ColorPt) && c.name != "ColorPt") {
			if(typeof c == "object") {throw new TypeError("1st input argument in function 'setFillColorWithColorPt' is of type '"+c.name+"'. Expected type 'ColorPt'. Function Signature: setFillColorWithColorPt(ColorPt).");}
			else {throw new TypeError("1st input argument '"+c+"' in function 'setFillColorWithColorPt' is of type '"+(typeof c)+"'. Expected type 'ColorPt'. Function Signature: setFillColorWithColorPt(ColorPt).");}
		}
		if(typeof c.yieldFunction != "undefined") {throw new Error("Function '"+c.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setFillColorWithColorPt'. Perhaps a yield statement is required for '"+c.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillColorWithColorPt', {"gs": this.id, "c": c.id}, this.userPriority);
	},

	/**
	* Set the fill color to the given tiling pattern.
	* @param pattern New pattern color.
	* @note The currently selected fill color space must be Pattern color space.
	*/
		PDFNet.GState.prototype.setFillColorWithPattern = function(pattern)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFillColorWithPattern'. Expected "+1+" argument. Function Signature: setFillColorWithPattern(PatternColor)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'setFillColorWithPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.PatternColor)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'setFillColorWithPattern' is of type '"+pattern.name+"'. Expected type 'PatternColor'. Function Signature: setFillColorWithPattern(PatternColor).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'setFillColorWithPattern' is of type '"+(typeof pattern)+"'. Expected type 'PatternColor'. Function Signature: setFillColorWithPattern(PatternColor).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillColorWithPattern', {"gs": this.id, "pattern": pattern.id}, this.userPriority);
	},

	/**
	* Set the fill color to the given uncolored tiling pattern.
	* @param SDF pattern (PatternType = 1 and PaintType = 2) object.
	* @param c is a color in the pattern's underlying color space.
	* @note The currently selected fill color space must be Pattern color space.
	*/
		PDFNet.GState.prototype.setFillColor = function(pattern, c)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setFillColor'. Expected "+2+" arguments. Function Signature: setFillColor(PatternColor, ColorPt)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'setFillColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.PatternColor)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'setFillColor' is of type '"+pattern.name+"'. Expected type 'PatternColor'. Function Signature: setFillColor(PatternColor, ColorPt).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'setFillColor' is of type '"+(typeof pattern)+"'. Expected type 'PatternColor'. Function Signature: setFillColor(PatternColor, ColorPt).");}
		}
		if(c instanceof Promise) {throw new TypeError("2nd input argument in function 'setFillColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(c instanceof PDFNet.ColorPt) && c.name != "ColorPt") {
			if(typeof c == "object") {throw new TypeError("2nd input argument in function 'setFillColor' is of type '"+c.name+"'. Expected type 'ColorPt'. Function Signature: setFillColor(PatternColor, ColorPt).");}
			else {throw new TypeError("2nd input argument '"+c+"' in function 'setFillColor' is of type '"+(typeof c)+"'. Expected type 'ColorPt'. Function Signature: setFillColor(PatternColor, ColorPt).");}
		}
		if(typeof c.yieldFunction != "undefined") {throw new Error("Function '"+c.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setFillColor'. Perhaps a yield statement is required for '"+c.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillColor', {"gs": this.id, "pattern": pattern.id, "c": c.id}, this.userPriority);
	},

	/**
	* Sets the value of flatness tolerance.
	*
	* @param flatness is a number in the range 0 to 100; a value of 0 specifies the output
	* device's default flatness tolerance.
	*
	* The flatness tolerance controls the maximum permitted distance in device pixels
	* between the mathematically correct path and an approximation constructed from
	* straight line segments.
	*/
		PDFNet.GState.prototype.setFlatness = function(flatness)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFlatness'. Expected "+1+" argument. Function Signature: setFlatness(number)")};
		if(flatness instanceof Promise) {throw new TypeError("1st input argument in function 'setFlatness' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flatness != "number") {throw new TypeError("1st input argument '"+flatness+"' in function 'setFlatness' is of type '"+(typeof flatness)+"'. Expected type 'number'. Function Signature: setFlatness(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFlatness', {"gs": this.id, "flatness": flatness}, this.userPriority);
	},

	/**
	* Sets LineCap style property.
	* The line cap style specifies the shape to be used at the ends of open subpaths
	* (and dashes, if any) when they are stroked.
	*/
		PDFNet.GState.prototype.setLineCap = function(cap)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLineCap'. Expected "+1+" argument. Function Signature: setLineCap(number)")};
		if(cap instanceof Promise) {throw new TypeError("1st input argument in function 'setLineCap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cap != "number") {throw new TypeError("1st input argument '"+cap+"' in function 'setLineCap' is of type '"+(typeof cap)+"'. Expected type 'number'. Function Signature: setLineCap(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setLineCap', {"gs": this.id, "cap": cap}, this.userPriority);
	},

	/**
	* Sets LineJoin style property.
	*
	* The line join style specifies the shape to be used at the corners of paths that
	* are stroked.
	*/
		PDFNet.GState.prototype.setLineJoin = function(join)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLineJoin'. Expected "+1+" argument. Function Signature: setLineJoin(number)")};
		if(join instanceof Promise) {throw new TypeError("1st input argument in function 'setLineJoin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof join != "number") {throw new TypeError("1st input argument '"+join+"' in function 'setLineJoin' is of type '"+(typeof join)+"'. Expected type 'number'. Function Signature: setLineJoin(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setLineJoin', {"gs": this.id, "join": join}, this.userPriority);
	},

	/**
	* Sets the thickness of the line used to stroke a path.
	* @param width a non-negative number expressed in user space units.
	* A line width of 0 denotes the thinnest line that can be rendered at device
	* resolution: 1 device pixel wide.
	*/
		PDFNet.GState.prototype.setLineWidth = function(width)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLineWidth'. Expected "+1+" argument. Function Signature: setLineWidth(number)")};
		if(width instanceof Promise) {throw new TypeError("1st input argument in function 'setLineWidth' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("1st input argument '"+width+"' in function 'setLineWidth' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: setLineWidth(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setLineWidth', {"gs": this.id, "width": width}, this.userPriority);
	},

	/**
	* Sets miter limit.
	* @param miter_limit A number that imposes a maximum on the ratio of the miter
	* length to the line width. When the limit is exceeded, the join is converted
	* from a miter to a bevel.
	*/
		PDFNet.GState.prototype.setMiterLimit = function(miter_limit)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMiterLimit'. Expected "+1+" argument. Function Signature: setMiterLimit(number)")};
		if(miter_limit instanceof Promise) {throw new TypeError("1st input argument in function 'setMiterLimit' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof miter_limit != "number") {throw new TypeError("1st input argument '"+miter_limit+"' in function 'setMiterLimit' is of type '"+(typeof miter_limit)+"'. Expected type 'number'. Function Signature: setMiterLimit(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setMiterLimit', {"gs": this.id, "miter_limit": miter_limit}, this.userPriority);
	},

		PDFNet.GState.prototype.setDashPattern = function(buf_dash_array, phase)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setDashPattern'. Expected "+2+" arguments. Function Signature: setDashPattern(ArrayBuffer, number)")};
		if(buf_dash_array instanceof Promise) {throw new TypeError("1st input argument in function 'setDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_dash_array.buffer instanceof ArrayBuffer)) {
			if(typeof buf_dash_array == "object") {throw new TypeError("1st input argument in function 'setDashPattern' is of type '"+buf_dash_array.name+"'. Expected type 'ArrayBuffer'. Function Signature: setDashPattern(ArrayBuffer, number).");}
			else {throw new TypeError("1st input argument '"+buf_dash_array+"' in function 'setDashPattern' is of type '"+(typeof buf_dash_array)+"'. Expected type 'ArrayBuffer'. Function Signature: setDashPattern(ArrayBuffer, number).");}
		}
		if(phase instanceof Promise) {throw new TypeError("3rd input argument in function 'setDashPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof phase != "number") {throw new TypeError("3rd input argument '"+phase+"' in function 'setDashPattern' is of type '"+(typeof phase)+"'. Expected type 'number'. Function Signature: setDashPattern(ArrayBuffer, number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setDashPattern', {"gs": this.id, "buf_dash_array": buf_dash_array.buffer, "phase": phase}, this.userPriority);
	},

	/**
	* Sets character spacing.
	* @param char_spacing a number specified in unscaled text space units. When the
	* glyph for each character in the string is rendered, the character spacing is
	* added to the horizontal or vertical component of the glyph's displacement,
	* depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.setCharSpacing = function(char_spacing)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCharSpacing'. Expected "+1+" argument. Function Signature: setCharSpacing(number)")};
		if(char_spacing instanceof Promise) {throw new TypeError("1st input argument in function 'setCharSpacing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_spacing != "number") {throw new TypeError("1st input argument '"+char_spacing+"' in function 'setCharSpacing' is of type '"+(typeof char_spacing)+"'. Expected type 'number'. Function Signature: setCharSpacing(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setCharSpacing', {"gs": this.id, "char_spacing": char_spacing}, this.userPriority);
	},

	/**
	* Sets word spacing.
	* @param word_spacing - a number specified in unscaled text space units.
	* Word spacing works the same way as character spacing, but applies only to the
	* space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.setWordSpacing = function(word_spacing)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setWordSpacing'. Expected "+1+" argument. Function Signature: setWordSpacing(number)")};
		if(word_spacing instanceof Promise) {throw new TypeError("1st input argument in function 'setWordSpacing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof word_spacing != "number") {throw new TypeError("1st input argument '"+word_spacing+"' in function 'setWordSpacing' is of type '"+(typeof word_spacing)+"'. Expected type 'number'. Function Signature: setWordSpacing(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setWordSpacing', {"gs": this.id, "word_spacing": word_spacing}, this.userPriority);
	},

	/**
	* Sets horizontal scale.
	* The horizontal scaling parameter adjusts the width of glyphs by stretching
	* or compressing them in the horizontal direction. Its value is specified as
	* a percentage of the normal width of the glyphs, with 100 being the normal width.
	* The scaling always applies to the horizontal coordinate in text space, independently
	* of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.setHorizontalScale = function(hscale)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHorizontalScale'. Expected "+1+" argument. Function Signature: setHorizontalScale(number)")};
		if(hscale instanceof Promise) {throw new TypeError("1st input argument in function 'setHorizontalScale' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hscale != "number") {throw new TypeError("1st input argument '"+hscale+"' in function 'setHorizontalScale' is of type '"+(typeof hscale)+"'. Expected type 'number'. Function Signature: setHorizontalScale(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setHorizontalScale', {"gs": this.id, "hscale": hscale}, this.userPriority);
	},

	/**
	* Sets the leading parameter.
	*
	* The leading parameter is measured in unscaled text space units. It specifies
	* the vertical distance between the baselines of adjacent lines of text.
	* See Section 5.2.4 in PDF Reference Manual for details.
	*/
		PDFNet.GState.prototype.setLeading = function(leading)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLeading'. Expected "+1+" argument. Function Signature: setLeading(number)")};
		if(leading instanceof Promise) {throw new TypeError("1st input argument in function 'setLeading' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof leading != "number") {throw new TypeError("1st input argument '"+leading+"' in function 'setLeading' is of type '"+(typeof leading)+"'. Expected type 'number'. Function Signature: setLeading(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setLeading', {"gs": this.id, "leading": leading}, this.userPriority);
	},

	/**
	* Sets the font and font size used to draw text.
	*/
		PDFNet.GState.prototype.setFont = function(font, font_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setFont'. Expected "+2+" arguments. Function Signature: setFont(Font, number)")};
		if(font instanceof Promise) {throw new TypeError("1st input argument in function 'setFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("1st input argument in function 'setFont' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: setFont(Font, number).");}
			else {throw new TypeError("1st input argument '"+font+"' in function 'setFont' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: setFont(Font, number).");}
		}
		if(font_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'setFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_sz != "number") {throw new TypeError("2nd input argument '"+font_sz+"' in function 'setFont' is of type '"+(typeof font_sz)+"'. Expected type 'number'. Function Signature: setFont(Font, number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFont', {"gs": this.id, "font": font.id, "font_sz": font_sz}, this.userPriority);
	},

	/**
	* Sets text rendering mode.
	* The text rendering mode determines whether showing text causes glyph outlines to
	* be stroked, filled, used as a clipping boundary, or some combination of the three.
	* See Section 5.2.5 in PDF Reference Manual for details..
	*/
		PDFNet.GState.prototype.setTextRenderMode = function(rmode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextRenderMode'. Expected "+1+" argument. Function Signature: setTextRenderMode(number)")};
		if(rmode instanceof Promise) {throw new TypeError("1st input argument in function 'setTextRenderMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rmode != "number") {throw new TypeError("1st input argument '"+rmode+"' in function 'setTextRenderMode' is of type '"+(typeof rmode)+"'. Expected type 'number'. Function Signature: setTextRenderMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setTextRenderMode', {"gs": this.id, "rmode": rmode}, this.userPriority);
	},

	/**
	* Sets text rise.
	* Text rise specifies the distance, in unscaled text space units, to move the
	* baseline up or down from its default location. Positive values of text rise
	* move the baseline up
	*/
		PDFNet.GState.prototype.setTextRise = function(rise)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextRise'. Expected "+1+" argument. Function Signature: setTextRise(number)")};
		if(rise instanceof Promise) {throw new TypeError("1st input argument in function 'setTextRise' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rise != "number") {throw new TypeError("1st input argument '"+rise+"' in function 'setTextRise' is of type '"+(typeof rise)+"'. Expected type 'number'. Function Signature: setTextRise(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setTextRise', {"gs": this.id, "rise": rise}, this.userPriority);
	},

	/**
	* Mark the object as elementary for purposes of color compositing in the
	* transparent imaging model.
	*/
		PDFNet.GState.prototype.setTextKnockout = function(knockout)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextKnockout'. Expected "+1+" argument. Function Signature: setTextKnockout(boolean)")};
		if(knockout instanceof Promise) {throw new TypeError("1st input argument in function 'setTextKnockout' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof knockout != "boolean") {throw new TypeError("1st input argument '"+knockout+"' in function 'setTextKnockout' is of type '"+(typeof knockout)+"'. Expected type 'boolean'. Function Signature: setTextKnockout(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setTextKnockout', {"gs": this.id, "knockout": knockout}, this.userPriority);
	},

	/**
	* Sets the color intent to be used for rendering the Element.
	*/
		PDFNet.GState.prototype.setRenderingIntent = function(intent)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRenderingIntent'. Expected "+1+" argument. Function Signature: setRenderingIntent(number)")};
		if(intent instanceof Promise) {throw new TypeError("1st input argument in function 'setRenderingIntent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof intent != "number") {throw new TypeError("1st input argument '"+intent+"' in function 'setRenderingIntent' is of type '"+(typeof intent)+"'. Expected type 'number'. Function Signature: setRenderingIntent(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setRenderingIntent', {"gs": this.id, "intent": intent}, this.userPriority);
	},

	/**
	* Sets the current blend mode to be used in the transparent imaging model.
	* Corresponds to the /BM key within the ExtGState's dictionary.
	* @param BM - New blending mode type.
	*
	* @code
	* // C#
	* gs.SetBlendMode(GState.BlendMode.e_lighten);
	*
	* // C++
	* gs->SetBlendMode(GState::e_lighten);
	* @endcode
	*/
		PDFNet.GState.prototype.setBlendMode = function(BM)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBlendMode'. Expected "+1+" argument. Function Signature: setBlendMode(number)")};
		if(BM instanceof Promise) {throw new TypeError("1st input argument in function 'setBlendMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof BM != "number") {throw new TypeError("1st input argument '"+BM+"' in function 'setBlendMode' is of type '"+(typeof BM)+"'. Expected type 'number'. Function Signature: setBlendMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setBlendMode', {"gs": this.id, "BM": BM}, this.userPriority);
	},

	/**
	* Sets the opacity value for painting operations other than stroking.
	* Corresponds to the value of the /ca key in the ExtGState dictionary.
	*/
		PDFNet.GState.prototype.setFillOpacity = function(ca)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFillOpacity'. Expected "+1+" argument. Function Signature: setFillOpacity(number)")};
		if(ca instanceof Promise) {throw new TypeError("1st input argument in function 'setFillOpacity' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ca != "number") {throw new TypeError("1st input argument '"+ca+"' in function 'setFillOpacity' is of type '"+(typeof ca)+"'. Expected type 'number'. Function Signature: setFillOpacity(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillOpacity', {"gs": this.id, "ca": ca}, this.userPriority);
	},

	/**
	* Sets opacity value for stroke painting operations for paths and glyph outlines.
	* Corresponds to the value of the /CA key in the ExtGState dictionary.
	*/
		PDFNet.GState.prototype.setStrokeOpacity = function(CA)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeOpacity'. Expected "+1+" argument. Function Signature: setStrokeOpacity(number)")};
		if(CA instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeOpacity' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof CA != "number") {throw new TypeError("1st input argument '"+CA+"' in function 'setStrokeOpacity' is of type '"+(typeof CA)+"'. Expected type 'number'. Function Signature: setStrokeOpacity(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeOpacity', {"gs": this.id, "CA": CA}, this.userPriority);
	},

	/**
	* specifies if the alpha is to be interpreted as a shape or opacity mask.
	* The alpha source flag ('alpha is shape'), specifies whether the
	* current soft mask and alpha constant are to be interpreted as shape values
	* (true) or opacity values (false).
	*/
		PDFNet.GState.prototype.setAISFlag = function(AIS)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAISFlag'. Expected "+1+" argument. Function Signature: setAISFlag(boolean)")};
		if(AIS instanceof Promise) {throw new TypeError("1st input argument in function 'setAISFlag' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof AIS != "boolean") {throw new TypeError("1st input argument '"+AIS+"' in function 'setAISFlag' is of type '"+(typeof AIS)+"'. Expected type 'boolean'. Function Signature: setAISFlag(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setAISFlag', {"gs": this.id, "AIS": AIS}, this.userPriority);
	},

	/**
	* Sets the soft mask of the extended graphics state.
	* Corresponds to the /SMask key within the ExtGState's dictionary.
	* @param BG - SDF/Cos black-generation function or name
	*/
		PDFNet.GState.prototype.setSoftMask = function(SM)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSoftMask'. Expected "+1+" argument. Function Signature: setSoftMask(Obj)")};
		if(SM instanceof Promise) {throw new TypeError("1st input argument in function 'setSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(SM instanceof PDFNet.Obj)) {
			if(typeof SM == "object") {throw new TypeError("1st input argument in function 'setSoftMask' is of type '"+SM.name+"'. Expected type 'Obj'. Function Signature: setSoftMask(Obj).");}
			else {throw new TypeError("1st input argument '"+SM+"' in function 'setSoftMask' is of type '"+(typeof SM)+"'. Expected type 'Obj'. Function Signature: setSoftMask(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setSoftMask', {"gs": this.id, "SM": SM.id}, this.userPriority);
	},

	/**
	* specifies if overprint is enabled for stroke operations. Corresponds to the /OP
	* key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.setStrokeOverprint = function(OP)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStrokeOverprint'. Expected "+1+" argument. Function Signature: setStrokeOverprint(boolean)")};
		if(OP instanceof Promise) {throw new TypeError("1st input argument in function 'setStrokeOverprint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof OP != "boolean") {throw new TypeError("1st input argument '"+OP+"' in function 'setStrokeOverprint' is of type '"+(typeof OP)+"'. Expected type 'boolean'. Function Signature: setStrokeOverprint(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setStrokeOverprint', {"gs": this.id, "OP": OP}, this.userPriority);
	},

	/**
	* specifies if overprint is enabled for fill operations. Corresponds to the /op
	* key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.setFillOverprint = function(op)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFillOverprint'. Expected "+1+" argument. Function Signature: setFillOverprint(boolean)")};
		if(op instanceof Promise) {throw new TypeError("1st input argument in function 'setFillOverprint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof op != "boolean") {throw new TypeError("1st input argument '"+op+"' in function 'setFillOverprint' is of type '"+(typeof op)+"'. Expected type 'boolean'. Function Signature: setFillOverprint(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setFillOverprint', {"gs": this.id, "op": op}, this.userPriority);
	},

	/**
	* Sets the overprint mode. Corresponds to the /OPM key within the ExtGState's
	* dictionary.
	*/
		PDFNet.GState.prototype.setOverprintMode = function(OPM)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOverprintMode'. Expected "+1+" argument. Function Signature: setOverprintMode(number)")};
		if(OPM instanceof Promise) {throw new TypeError("1st input argument in function 'setOverprintMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof OPM != "number") {throw new TypeError("1st input argument '"+OPM+"' in function 'setOverprintMode' is of type '"+(typeof OPM)+"'. Expected type 'number'. Function Signature: setOverprintMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setOverprintMode', {"gs": this.id, "OPM": OPM}, this.userPriority);
	},

	/**
	* Specify whether to apply automatic stroke adjustment.
	* Corresponds to the /SA key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.setAutoStrokeAdjust = function(SA)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAutoStrokeAdjust'. Expected "+1+" argument. Function Signature: setAutoStrokeAdjust(boolean)")};
		if(SA instanceof Promise) {throw new TypeError("1st input argument in function 'setAutoStrokeAdjust' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof SA != "boolean") {throw new TypeError("1st input argument '"+SA+"' in function 'setAutoStrokeAdjust' is of type '"+(typeof SA)+"'. Expected type 'boolean'. Function Signature: setAutoStrokeAdjust(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setAutoStrokeAdjust', {"gs": this.id, "SA": SA}, this.userPriority);
	},

	/**
	* Sets the smoothness tolerance used to control the quality of smooth
	* shading. Corresponds to the /SM key within the ExtGState's dictionary.
	*/
		PDFNet.GState.prototype.setSmoothnessTolerance = function(SM)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSmoothnessTolerance'. Expected "+1+" argument. Function Signature: setSmoothnessTolerance(number)")};
		if(SM instanceof Promise) {throw new TypeError("1st input argument in function 'setSmoothnessTolerance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof SM != "number") {throw new TypeError("1st input argument '"+SM+"' in function 'setSmoothnessTolerance' is of type '"+(typeof SM)+"'. Expected type 'number'. Function Signature: setSmoothnessTolerance(number).");}
		return PDFNet.messageHandler.sendWithPromise('GState.setSmoothnessTolerance', {"gs": this.id, "SM": SM}, this.userPriority);
	},

	/**
	* Sets black-generation function used during conversion between DeviceRGB
	* and DeviceCMYK. Corresponds to the /BG key within the ExtGState's
	* dictionary.
	* @param BG - SDF/Cos black-generation function or name
	*/
		PDFNet.GState.prototype.setBlackGenFunct = function(BG)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBlackGenFunct'. Expected "+1+" argument. Function Signature: setBlackGenFunct(Obj)")};
		if(BG instanceof Promise) {throw new TypeError("1st input argument in function 'setBlackGenFunct' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(BG instanceof PDFNet.Obj)) {
			if(typeof BG == "object") {throw new TypeError("1st input argument in function 'setBlackGenFunct' is of type '"+BG.name+"'. Expected type 'Obj'. Function Signature: setBlackGenFunct(Obj).");}
			else {throw new TypeError("1st input argument '"+BG+"' in function 'setBlackGenFunct' is of type '"+(typeof BG)+"'. Expected type 'Obj'. Function Signature: setBlackGenFunct(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setBlackGenFunct', {"gs": this.id, "BG": BG.id}, this.userPriority);
	},

	/**
	* Sets undercolor-removal function used during conversion between DeviceRGB
	* and DeviceCMYK. Corresponds to the /UCR key within the ExtGState's
	* dictionary.
	* @param UCR - SDF/Cos undercolor-removal function or name
	*/
		PDFNet.GState.prototype.setUCRFunct = function(UCR)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUCRFunct'. Expected "+1+" argument. Function Signature: setUCRFunct(Obj)")};
		if(UCR instanceof Promise) {throw new TypeError("1st input argument in function 'setUCRFunct' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(UCR instanceof PDFNet.Obj)) {
			if(typeof UCR == "object") {throw new TypeError("1st input argument in function 'setUCRFunct' is of type '"+UCR.name+"'. Expected type 'Obj'. Function Signature: setUCRFunct(Obj).");}
			else {throw new TypeError("1st input argument '"+UCR+"' in function 'setUCRFunct' is of type '"+(typeof UCR)+"'. Expected type 'Obj'. Function Signature: setUCRFunct(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setUCRFunct', {"gs": this.id, "UCR": UCR.id}, this.userPriority);
	},

	/**
	* Sets transfer function used during color conversion process. A transfer
	* function adjusts the values of color components to compensate for nonlinear
	* response in an output device and in the human eye. Corresponds to the /TR key
	* within the ExtGState's dictionary.
	* @param TR - SDF/Cos transfer function, array, or name
	*/
		PDFNet.GState.prototype.setTransferFunct = function(TR)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTransferFunct'. Expected "+1+" argument. Function Signature: setTransferFunct(Obj)")};
		if(TR instanceof Promise) {throw new TypeError("1st input argument in function 'setTransferFunct' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(TR instanceof PDFNet.Obj)) {
			if(typeof TR == "object") {throw new TypeError("1st input argument in function 'setTransferFunct' is of type '"+TR.name+"'. Expected type 'Obj'. Function Signature: setTransferFunct(Obj).");}
			else {throw new TypeError("1st input argument '"+TR+"' in function 'setTransferFunct' is of type '"+(typeof TR)+"'. Expected type 'Obj'. Function Signature: setTransferFunct(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setTransferFunct', {"gs": this.id, "TR": TR.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected halftone dictionary or stream (NULL by default).
	* Corresponds to the /HT key within the ExtGState's dictionary.
	* Halftoning is a process by which continuous-tone colors are approximated on an
	* output device that can achieve only a limited number of discrete colors.
	* @param HT - SDF/Cos halftone dictionary, stream, or name
	*/
		PDFNet.GState.prototype.setHalftone = function(HT)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHalftone'. Expected "+1+" argument. Function Signature: setHalftone(Obj)")};
		if(HT instanceof Promise) {throw new TypeError("1st input argument in function 'setHalftone' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(HT instanceof PDFNet.Obj)) {
			if(typeof HT == "object") {throw new TypeError("1st input argument in function 'setHalftone' is of type '"+HT.name+"'. Expected type 'Obj'. Function Signature: setHalftone(Obj).");}
			else {throw new TypeError("1st input argument '"+HT+"' in function 'setHalftone' is of type '"+(typeof HT)+"'. Expected type 'Obj'. Function Signature: setHalftone(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('GState.setHalftone', {"gs": this.id, "HT": HT.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the current element type.
	*/
		PDFNet.Element.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getType', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to gState of this Element
	*/
		PDFNet.Element.prototype.getGState = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getGState'. Expected "+0+" arguments. Function Signature: getGState()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getGState', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type GState
			if(id == "0"){
				return null;
			}
			return new PDFNet.GState(id);
		});
	},

	/**
	* @return A promise that resolves to current Transformation Matrix (CTM) that maps coordinates to the
	* initial user space.
	*/
		PDFNet.Element.prototype.getCTM = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCTM'. Expected "+0+" arguments. Function Signature: getCTM()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getCTM', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

		PDFNet.Element.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		var me = this;
		this.yieldFunction = "Element.getBBox"; // TRN_Rect* out_bbox
		return PDFNet.messageHandler.sendWithPromise('Element.getBBox', {"e": this.id}, this.userPriority).then(function(id){
			copyFunc(id.out_bbox, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to parent logical structure element (such as 'span' or 'paragraph').
	* If the Element is not associated with any structure element, the returned
	* SElement will not be valid (i.e. selem.IsValid() -> false).
	*/
		PDFNet.Element.prototype.getParentStructElement = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParentStructElement'. Expected "+0+" arguments. Function Signature: getParentStructElement()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getParentStructElement', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type SElement
			if(id == "0"){
				return null;
			}
			return new PDFNet.SElement(id);
		});
	},

	/**
	* @return A promise that resolves to marked Content Identifier (MCID) for this Element or
	* a negative number if the element is not assigned an identifier/MCID.
	*
	* Marked content identifier can be used to associate an Element with
	* logical structure element that refers to the Element.
	*/
		PDFNet.Element.prototype.getStructMCID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStructMCID'. Expected "+0+" arguments. Function Signature: getStructMCID()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getStructMCID', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this element is visible in the optional-content
	* context (OCG::Context). The method considers the context's current OCMD stack,
	* the group ON-OFF states, the non-OC drawing status, the drawing and enumeration mode,
	* and the intent.
	*
	* When enumerating page content, OCG::Context can be passed as a parameter in
	* ElementReader.Begin() method. When using PDFDraw, PDFRasterizer, or PDFView class to
	* render PDF pages use PDFDraw::SetOCGContext() method to select an OC context.
	*/
		PDFNet.Element.prototype.isOCVisible = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isOCVisible'. Expected "+0+" arguments. Function Signature: isOCVisible()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isOCVisible', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the current path element is a clipping path and should be added
	* to clipping path stack.
	*/
		PDFNet.Element.prototype.isClippingPath = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isClippingPath'. Expected "+0+" arguments. Function Signature: isClippingPath()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isClippingPath', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the current path element should be stroked
	*/
		PDFNet.Element.prototype.isStroked = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isStroked'. Expected "+0+" arguments. Function Signature: isStroked()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isStroked', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the current path element should be filled
	*/
		PDFNet.Element.prototype.isFilled = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isFilled'. Expected "+0+" arguments. Function Signature: isFilled()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isFilled', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the current path should be filled using non-zero winding rule,
	* or false if the path should be filled using even-odd rule.
	*
	* According non-zero winding rule, you can determine whether a test point is inside or
	* outside a closed curve as follows: Draw a line from a test point to a point that
	* is distant from the curve. Count the number of times the curve crosses the test
	* line from left to right, and count the number of times the curve crosses the test
	* line from right to left. If those two numbers are the same, the test point is
	* outside the curve; otherwise, the test point is inside the curve.
	*
	* According to even-odd rule, you can determine whether a test point is inside
	* or outside a closed curve as follows: Draw a line from the test point to a point
	* that is distant from the curve. If that line crosses the curve an odd number of
	* times, the test point is inside the curve; otherwise, the test point is outside
	* the curve.
	*/
		PDFNet.Element.prototype.isWindingFill = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isWindingFill'. Expected "+0+" arguments. Function Signature: isWindingFill()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isWindingFill', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the current clip path is using non-zero winding rule, or false
	* for even-odd rule.
	*/
		PDFNet.Element.prototype.isClipWindingFill = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isClipWindingFill'. Expected "+0+" arguments. Function Signature: isClipWindingFill()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isClipWindingFill', {"e": this.id}, this.userPriority);
	},

	/**
	* indicate whether the path is a clipping path or non-clipping path
	*/
		PDFNet.Element.prototype.setPathClip = function(clip)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathClip'. Expected "+1+" argument. Function Signature: setPathClip(boolean)")};
		if(clip instanceof Promise) {throw new TypeError("1st input argument in function 'setPathClip' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof clip != "boolean") {throw new TypeError("1st input argument '"+clip+"' in function 'setPathClip' is of type '"+(typeof clip)+"'. Expected type 'boolean'. Function Signature: setPathClip(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setPathClip', {"e": this.id, "clip": clip}, this.userPriority);
	},

	/**
	* indicate whether the path should be stroked
	*/
		PDFNet.Element.prototype.setPathStroke = function(stroke)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathStroke'. Expected "+1+" argument. Function Signature: setPathStroke(boolean)")};
		if(stroke instanceof Promise) {throw new TypeError("1st input argument in function 'setPathStroke' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof stroke != "boolean") {throw new TypeError("1st input argument '"+stroke+"' in function 'setPathStroke' is of type '"+(typeof stroke)+"'. Expected type 'boolean'. Function Signature: setPathStroke(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setPathStroke', {"e": this.id, "stroke": stroke}, this.userPriority);
	},

	/**
	* indicate whether the path should be filled
	*/
		PDFNet.Element.prototype.setPathFill = function(fill)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathFill'. Expected "+1+" argument. Function Signature: setPathFill(boolean)")};
		if(fill instanceof Promise) {throw new TypeError("1st input argument in function 'setPathFill' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof fill != "boolean") {throw new TypeError("1st input argument '"+fill+"' in function 'setPathFill' is of type '"+(typeof fill)+"'. Expected type 'boolean'. Function Signature: setPathFill(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setPathFill', {"e": this.id, "fill": fill}, this.userPriority);
	},

	/**
	* sets path's fill rule.
	* @param winding_rule if winding_rule is true path will be filled using non-zero
	* winding fill rule, otherwise even-odd fill will be used.
	*/
		PDFNet.Element.prototype.setWindingFill = function(winding_rule)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setWindingFill'. Expected "+1+" argument. Function Signature: setWindingFill(boolean)")};
		if(winding_rule instanceof Promise) {throw new TypeError("1st input argument in function 'setWindingFill' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof winding_rule != "boolean") {throw new TypeError("1st input argument '"+winding_rule+"' in function 'setWindingFill' is of type '"+(typeof winding_rule)+"'. Expected type 'boolean'. Function Signature: setWindingFill(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setWindingFill', {"e": this.id, "winding_rule": winding_rule}, this.userPriority);
	},

	/**
	* sets clipping path's fill rule.
	* @param winding_rule if winding_rule is true clipping should use non-zero
	* winding rule, or false for even-odd rule.
	*/
		PDFNet.Element.prototype.setClipWindingFill = function(winding_rule)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setClipWindingFill'. Expected "+1+" argument. Function Signature: setClipWindingFill(boolean)")};
		if(winding_rule instanceof Promise) {throw new TypeError("1st input argument in function 'setClipWindingFill' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof winding_rule != "boolean") {throw new TypeError("1st input argument '"+winding_rule+"' in function 'setClipWindingFill' is of type '"+(typeof winding_rule)+"'. Expected type 'boolean'. Function Signature: setClipWindingFill(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setClipWindingFill', {"e": this.id, "winding_rule": winding_rule}, this.userPriority);
	},

		PDFNet.Element.prototype.setPathPoints = function(buf_in_points, buf_count)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPathPoints'. Expected "+2+" arguments. Function Signature: setPathPoints(ArrayBuffer, ArrayBuffer)")};
		if(buf_in_points instanceof Promise) {throw new TypeError("1st input argument in function 'setPathPoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_in_points.buffer instanceof ArrayBuffer)) {
			if(typeof buf_in_points == "object") {throw new TypeError("1st input argument in function 'setPathPoints' is of type '"+buf_in_points.name+"'. Expected type 'ArrayBuffer'. Function Signature: setPathPoints(ArrayBuffer, ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf_in_points+"' in function 'setPathPoints' is of type '"+(typeof buf_in_points)+"'. Expected type 'ArrayBuffer'. Function Signature: setPathPoints(ArrayBuffer, ArrayBuffer).");}
		}
		if(buf_count instanceof Promise) {throw new TypeError("2nd input argument in function 'setPathPoints' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_count.buffer instanceof ArrayBuffer)) {
			if(typeof buf_count == "object") {throw new TypeError("2nd input argument in function 'setPathPoints' is of type '"+buf_count.name+"'. Expected type 'ArrayBuffer'. Function Signature: setPathPoints(ArrayBuffer, ArrayBuffer).");}
			else {throw new TypeError("2nd input argument '"+buf_count+"' in function 'setPathPoints' is of type '"+(typeof buf_count)+"'. Expected type 'ArrayBuffer'. Function Signature: setPathPoints(ArrayBuffer, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Element.setPathPoints', {"e": this.id, "buf_in_points": buf_in_points.buffer, "buf_count": buf_count.buffer}, this.userPriority);
	},

		PDFNet.Element.prototype.setPathTypes = function(in_seg_types, count)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPathTypes'. Expected "+2+" arguments. Function Signature: setPathTypes(string, number)")};
		if(in_seg_types instanceof Promise) {throw new TypeError("1st input argument in function 'setPathTypes' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof in_seg_types != "string") {throw new TypeError("1st input argument '"+in_seg_types+"' in function 'setPathTypes' is of type '"+(typeof in_seg_types)+"'. Expected type 'string'. Function Signature: setPathTypes(string, number).");}
		if(count instanceof Promise) {throw new TypeError("2nd input argument in function 'setPathTypes' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof count != "number") {throw new TypeError("2nd input argument '"+count+"' in function 'setPathTypes' is of type '"+(typeof count)+"'. Expected type 'number'. Function Signature: setPathTypes(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setPathTypes', {"e": this.id, "in_seg_types": in_seg_types, "count": count}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the SDF object of the Image/Form object.
	*/
		PDFNet.Element.prototype.getXObject = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getXObject'. Expected "+0+" arguments. Function Signature: getXObject()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getXObject', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to a stream (filter) containing decoded image data
	*/
		PDFNet.Element.prototype.getImageData = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageData'. Expected "+0+" arguments. Function Signature: getImageData()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageData', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to the size of image data in bytes
	*/
		PDFNet.Element.prototype.getImageDataSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageDataSize'. Expected "+0+" arguments. Function Signature: getImageDataSize()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageDataSize', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the SDF object representing the color space in which image
	* are specified or NULL if the image is an image mask
	*
	* The returned color space may be any type of color space except Pattern.
	*/
		PDFNet.Element.prototype.getImageColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageColorSpace'. Expected "+0+" arguments. Function Signature: getImageColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageColorSpace', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to the width of the image, in samples.
	*/
		PDFNet.Element.prototype.getImageWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageWidth'. Expected "+0+" arguments. Function Signature: getImageWidth()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageWidth', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the height of the image, in samples.
	*/
		PDFNet.Element.prototype.getImageHeight = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageHeight'. Expected "+0+" arguments. Function Signature: getImageHeight()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageHeight', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
	* array of numbers describing how to map image samples into the range of values
	* appropriate for the color space of the image. If ImageMask is true, the array must be
	* either [0 1] or [1 0]; otherwise, its length must be twice the number of color
	* components required by ColorSpace. Default value depends on the color space,
	* See Table 4.36 in PDF Ref. Manual.
	*/
		PDFNet.Element.prototype.getDecodeArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDecodeArray'. Expected "+0+" arguments. Function Signature: getDecodeArray()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getDecodeArray', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the number of bits used to represent each color component. Only a
	* single value may be specified; the number of bits is the same for all color
	* components. Valid values are 1, 2, 4, and 8.
	*/
		PDFNet.Element.prototype.getBitsPerComponent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBitsPerComponent'. Expected "+0+" arguments. Function Signature: getBitsPerComponent()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getBitsPerComponent', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of color components per sample.
	*/
		PDFNet.Element.prototype.getComponentNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getComponentNum'. Expected "+0+" arguments. Function Signature: getComponentNum()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getComponentNum', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
	*/
		PDFNet.Element.prototype.isImageMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isImageMask'. Expected "+0+" arguments. Function Signature: isImageMask()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isImageMask', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a boolean indicating whether image interpolation is to be performed.
	*/
		PDFNet.Element.prototype.isImageInterpolate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isImageInterpolate'. Expected "+0+" arguments. Function Signature: isImageInterpolate()")};
		return PDFNet.messageHandler.sendWithPromise('Element.isImageInterpolate', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an image XObject defining an image mask to be applied to this image (See
	* 'Explicit Masking', 4.8.5), or an array specifying a range of colors
	* to be applied to it as a color key mask (See 'Color Key Masking').
	*
	* If IsImageMask() return true, this method will return NULL.
	*/
		PDFNet.Element.prototype.getMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMask'. Expected "+0+" arguments. Function Signature: getMask()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getMask', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the color rendering intent to be used in rendering the image.
	*/
		PDFNet.Element.prototype.getImageRenderingIntent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageRenderingIntent'. Expected "+0+" arguments. Function Signature: getImageRenderingIntent()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getImageRenderingIntent', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a pointer to Unicode string for this text Element. The
	* function maps character codes to Unicode array defined by Adobe
	* Glyph List (http://partners.adobe.com/asn/developer/type/glyphlist.txt).
	*
	* @note In PDF text can be encoded using various encoding schemes
	* and in some cases it is not possible to extract Unicode encoding.
	* If it is not possible to map charcode to Unicode the function will
	* map a character to undefined code, 0xFFFD. This code is defined in
	* private Unicode range.
	*
	* @note If you would like to map raw text to Unicode (or some other encoding)
	* yourself use CharIterators returned by CharBegin()/CharEnd() and
	* PDF::Font code mapping methods.
	*
	* @note The string owner is the current element (i.e. ElementReader or ElementBuilder).
	*/
		PDFNet.Element.prototype.getTextString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextString'. Expected "+0+" arguments. Function Signature: getTextString()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getTextString', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a reference to the current text matrix (Tm).
	*/
		PDFNet.Element.prototype.getTextMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextMatrix'. Expected "+0+" arguments. Function Signature: getTextMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getTextMatrix', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to a CharIterator addressing the first CharData element in the text run.
	*
	* CharIterator points to CharData. CharData is a data structure that contains
	* the char_code number (used to retrieve glyph outlines, to map to Unicode, etc.),
	* character positioning information (x, y), and the number of bytes taken by the
	* character within the text buffer.
	*
	* @note CharIterator follows the standard STL forward-iterator interface.
	*
	* An example of how to use CharIterator.
	* @code
	*     for (CharIterator itr = element.GetCharIterator(); itr.HasNext(); itr.Next()) {
	* 			unsigned int char_code = itr.Current().char_code;
	* 			double char_pos_x = itr.Current().x;
	* 			double char_pos_y = itr.Current().y;
	*     }
	* @endcode
	*
	* @note Character positioning information (x, y) is represented in text space.
	* In order to get the positioning in the user space, the returned value should
	* be scaled using the text matrix (GetTextMatrix()) and the current transformation
	* matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
	* Manual for details and PDFNet FAQ - "How do I get absolute/relative text and
	* character positioning?".
	*
	* @note within a text run a character may occupy more than a single byte (e.g.
	* in case of composite/Type0 fonts). The role of CharIterator/CharData is to
	* provide a uniform and easy to use interface to access character information.
	*/
		PDFNet.Element.prototype.getCharIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCharIterator'. Expected "+0+" arguments. Function Signature: getCharIterator()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getCharIterator', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* @return A promise that resolves to the text advance distance in text space.
	*
	* The total sum of all of the advance values from rendering all of the characters
	* within this element, including the advance value on the glyphs, the effect of
	* properties such as 'char-spacing', 'word-spacing' and positioning adjustments
	* on 'TJ' elements.
	*
	* @note Computed text length is represented in text space. In order to get the
	* length of the text run in the user space, the returned value should be scaled
	* using the text matrix (GetTextMatrix()) and the current transformation
	* matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
	* Manual for details.
	*/
		PDFNet.Element.prototype.getTextLength = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTextLength'. Expected "+0+" arguments. Function Signature: getTextLength()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getTextLength', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number used to adjust text matrix in horizontal direction when drawing
	* text. The number is expressed in thousandths of a unit of text space. The returned
	* number corresponds to a number value within TJ array. For 'Tj' text strings the
	* returned value is always 0.
	*
	* @note because CharIterator positioning information already accounts for TJ
	* adjustments this method is rarely used.
	*/
		PDFNet.Element.prototype.getPosAdjustment = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPosAdjustment'. Expected "+0+" arguments. Function Signature: getPosAdjustment()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getPosAdjustment', {"e": this.id}, this.userPriority);
	},

		PDFNet.Element.prototype.getNewTextLineOffset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNewTextLineOffset'. Expected "+0+" arguments. Function Signature: getNewTextLineOffset()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getNewTextLineOffset', {"e": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this element is directly associated with a text matrix
	* (that is Tm operator is just before this text element) or false if the text
	* matrix is default or is inherited from previous text elements.
	*/
		PDFNet.Element.prototype.hasTextMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasTextMatrix'. Expected "+0+" arguments. Function Signature: hasTextMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('Element.hasTextMatrix', {"e": this.id}, this.userPriority);
	},

	/**
	* set the text data for the current e_text Element.
	* @param text_data a pointer to a buffer containing text.
	* @param text_data_size the size of the internal text buffer
	*/
		PDFNet.Element.prototype.setTextData = function(buf_text_data)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextData'. Expected "+1+" argument. Function Signature: setTextData(ArrayBuffer)")};
		if(buf_text_data instanceof Promise) {throw new TypeError("1st input argument in function 'setTextData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_text_data.buffer instanceof ArrayBuffer)) {
			if(typeof buf_text_data == "object") {throw new TypeError("1st input argument in function 'setTextData' is of type '"+buf_text_data.name+"'. Expected type 'ArrayBuffer'. Function Signature: setTextData(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf_text_data+"' in function 'setTextData' is of type '"+(typeof buf_text_data)+"'. Expected type 'ArrayBuffer'. Function Signature: setTextData(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Element.setTextData', {"e": this.id, "buf_text_data": buf_text_data.buffer}, this.userPriority);
	},

	/**
	* Sets the text matrix for a text element.
	*
	* @param mtx The new text matrix for this text element
	*/
		PDFNet.Element.prototype.setTextMatrix = function(mtx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextMatrix'. Expected "+1+" argument. Function Signature: setTextMatrix(Matrix2D)")};
		if(mtx instanceof Promise) {throw new TypeError("1st input argument in function 'setTextMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("1st input argument in function 'setTextMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: setTextMatrix(Matrix2D).");}
			else {throw new TypeError("1st input argument '"+mtx+"' in function 'setTextMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: setTextMatrix(Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setTextMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Element.setTextMatrix', {"e": this.id, "mtx": mtx}, this.userPriority);
	},

	/**
	* Sets the text matrix for a text element. This method accepts text
	* transformation matrix components directly.
	*
	* A transformation matrix in PDF is specified by six numbers, usually
	* in the form of an array containing six elements. In its most general
	* form, this array is denoted [a b c d h v]; it can represent any linear
	* transformation from one coordinate system to another. For more
	* information about PDF matrices please refer to section 4.2.2 'Common
	* Transformations' in PDF Reference Manual, and to documentation for
	* Matrix2D class.
	*
	* @param a - horizontal 'scaling' component of the new text matrix.
	* @param b - 'rotation' component of the new text matrix.
	* @param c - 'rotation' component of the new text matrix.
	* @param d - vertical 'scaling' component of the new text matrix.
	* @param h - horizontal translation component of the new text matrix.
	* @param v - vertical translation component of the new text matrix.
	*/
		PDFNet.Element.prototype.setTextMatrixEntries = function(a, b, c, d, h, v)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'setTextMatrixEntries'. Expected "+6+" arguments. Function Signature: setTextMatrixEntries(number, number, number, number, number, number)")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'setTextMatrixEntries' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("2nd input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("2nd input argument '"+b+"' in function 'setTextMatrixEntries' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("3rd input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("3rd input argument '"+c+"' in function 'setTextMatrixEntries' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("4th input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("4th input argument '"+d+"' in function 'setTextMatrixEntries' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("5th input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("5th input argument '"+h+"' in function 'setTextMatrixEntries' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("6th input argument in function 'setTextMatrixEntries' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("6th input argument '"+v+"' in function 'setTextMatrixEntries' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: setTextMatrixEntries(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setTextMatrixEntries', {"e": this.id, "a": a, "b": b, "c": c, "d": d, "h": h, "v": v}, this.userPriority);
	},

	/**
	* @return A promise that resolves to set the horizontal adjustment factor (i.e. a number value within TJ array)
	*
	* @note Positive values move the current text element backwards (along text direction).
	*       Negative values move the current text element forward (along text direction).
	*/
		PDFNet.Element.prototype.setPosAdjustment = function(adjust)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPosAdjustment'. Expected "+1+" argument. Function Signature: setPosAdjustment(number)")};
		if(adjust instanceof Promise) {throw new TypeError("1st input argument in function 'setPosAdjustment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof adjust != "number") {throw new TypeError("1st input argument '"+adjust+"' in function 'setPosAdjustment' is of type '"+(typeof adjust)+"'. Expected type 'number'. Function Signature: setPosAdjustment(number).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setPosAdjustment', {"e": this.id, "adjust": adjust}, this.userPriority);
	},

	/**
	* Recompute the character positioning information (i.e. CharIterator-s) and
	* text length.
	*
	* Element objects caches text length and character positioning information.
	* If the user modifies the text data or graphics state the cached information
	* is not correct. UpdateTextMetrics() can be used to recalculate the correct
	* positioning and length information.
	*/
		PDFNet.Element.prototype.updateTextMetrics = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'updateTextMetrics'. Expected "+0+" arguments. Function Signature: updateTextMetrics()")};
		return PDFNet.messageHandler.sendWithPromise('Element.updateTextMetrics', {"e": this.id}, this.userPriority);
	},

	/**
	* sets the offset (dx, dy) to the start of the current line relative to the beginning
	* of the previous line.
	*/
		PDFNet.Element.prototype.setNewTextLineOffset = function(dx, dy)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setNewTextLineOffset'. Expected "+2+" arguments. Function Signature: setNewTextLineOffset(number, number)")};
		if(dx instanceof Promise) {throw new TypeError("1st input argument in function 'setNewTextLineOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dx != "number") {throw new TypeError("1st input argument '"+dx+"' in function 'setNewTextLineOffset' is of type '"+(typeof dx)+"'. Expected type 'number'. Function Signature: setNewTextLineOffset(number, number).");}
		if(dy instanceof Promise) {throw new TypeError("2nd input argument in function 'setNewTextLineOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dy != "number") {throw new TypeError("2nd input argument '"+dy+"' in function 'setNewTextLineOffset' is of type '"+(typeof dy)+"'. Expected type 'number'. Function Signature: setNewTextLineOffset(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Element.setNewTextLineOffset', {"e": this.id, "dx": dx, "dy": dy}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the SDF object of the Shading object.
	*/
		PDFNet.Element.prototype.getShading = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getShading'. Expected "+0+" arguments. Function Signature: getShading()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getShading', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Shading
			if(id == "0"){
				return null;
			}
			return new PDFNet.Shading(id);
		});
	},

	/**
	* @return A promise that resolves to a dictionary containing the property list or NULL if property
	* dictionary is not present.
	*
	* @note the function automatically looks under Properties sub-dictionary of the
	* current resource dictionary if the dictionary is not in-line. Therefore you
	* can assume that returned Obj is dictionary if it is not NULL.
	*/
		PDFNet.Element.prototype.getMCPropertyDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMCPropertyDict'. Expected "+0+" arguments. Function Signature: getMCPropertyDict()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getMCPropertyDict', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to a tag is a name object indicating the role or significance of
	* the marked content point/sequence.
	*/
		PDFNet.Element.prototype.getMCTag = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMCTag'. Expected "+0+" arguments. Function Signature: getMCTag()")};
		return PDFNet.messageHandler.sendWithPromise('Element.getMCTag', {"e": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ElementBuilder.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('elementBuilderCreate', {}, this.userPriority).then(function(id){
			//there is a return type ElementBuilder
			if(id == "0"){
				return null;
			}
			return new PDFNet.ElementBuilder(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ElementBuilder.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.destroy', {"b": this.id}, this.userPriority);
	},

	/**
	* The function sets the graphics state of this Element to the given value.
	* If 'gs' parameter is not specified or is NULL the function resets the
	* graphics state of this Element to the default graphics state (i.e. the
	* graphics state at the beginning of the display list).
	*
	* The function can be used in situations where the same ElementBuilder is used
	* to create content on several pages, XObjects, etc. If the graphics state is not
	* Reset() when moving to a new display list, the new Element will have the same
	* graphics state as the last Element in the previous display list (and this may
	* or may not be your intent).
	*
	* Another use of Reset(gs) is to make sure that two Elements have the graphics
	* state.
	*/
		PDFNet.ElementBuilder.prototype.reset = function(gs)
	{
		if(typeof gs === "undefined") {gs = new PDFNet.GState("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'reset'. Expected at most "+1+" arguments. Function Signature: reset(GState)")};
		if(gs instanceof Promise) {throw new TypeError("1st input argument in function 'reset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(gs instanceof PDFNet.GState)) {
			if(typeof gs == "object") {throw new TypeError("1st input argument in function 'reset' is of type '"+gs.name+"'. Expected type 'GState'. Function Signature: reset(GState).");}
			else {throw new TypeError("1st input argument '"+gs+"' in function 'reset' is of type '"+(typeof gs)+"'. Expected type 'GState'. Function Signature: reset(GState).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.reset', {"b": this.id, "gs": gs.id}, this.userPriority);
	},

	/**
	* Create a content image Element out of a given document Image.
	*/
		PDFNet.ElementBuilder.prototype.createImage = function(img)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createImage'. Expected "+1+" argument. Function Signature: createImage(Image)")};
		if(img instanceof Promise) {throw new TypeError("1st input argument in function 'createImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("1st input argument in function 'createImage' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: createImage(Image).");}
			else {throw new TypeError("1st input argument '"+img+"' in function 'createImage' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: createImage(Image).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createImage', {"b": this.id, "img": img.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a content image Element out of a given document Image.
	* @param mtx the image transformation matrix.
	*/
		PDFNet.ElementBuilder.prototype.createImageFromMatrix = function(img, mtx)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createImageFromMatrix'. Expected "+2+" arguments. Function Signature: createImageFromMatrix(Image, Matrix2D)")};
		if(img instanceof Promise) {throw new TypeError("1st input argument in function 'createImageFromMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("1st input argument in function 'createImageFromMatrix' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: createImageFromMatrix(Image, Matrix2D).");}
			else {throw new TypeError("1st input argument '"+img+"' in function 'createImageFromMatrix' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: createImageFromMatrix(Image, Matrix2D).");}
		}
		if(mtx instanceof Promise) {throw new TypeError("2nd input argument in function 'createImageFromMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("2nd input argument in function 'createImageFromMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: createImageFromMatrix(Image, Matrix2D).");}
			else {throw new TypeError("2nd input argument '"+mtx+"' in function 'createImageFromMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: createImageFromMatrix(Image, Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'createImageFromMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createImageFromMatrix', {"b": this.id, "img": img.id, "mtx": mtx}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a content image Element out of a given document Image with
	* the lower left corner at (x, y), and scale factors (hscale, vscale).
	*/
		PDFNet.ElementBuilder.prototype.createImageScaled = function(img, x, y, hscale, vscale)
	{
		if(arguments.length != 5) {throw new RangeError(arguments.length+" arguments passed into function 'createImageScaled'. Expected "+5+" arguments. Function Signature: createImageScaled(Image, number, number, number, number)")};
		if(img instanceof Promise) {throw new TypeError("1st input argument in function 'createImageScaled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("1st input argument in function 'createImageScaled' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: createImageScaled(Image, number, number, number, number).");}
			else {throw new TypeError("1st input argument '"+img+"' in function 'createImageScaled' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: createImageScaled(Image, number, number, number, number).");}
		}
		if(x instanceof Promise) {throw new TypeError("2nd input argument in function 'createImageScaled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("2nd input argument '"+x+"' in function 'createImageScaled' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: createImageScaled(Image, number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("3rd input argument in function 'createImageScaled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("3rd input argument '"+y+"' in function 'createImageScaled' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: createImageScaled(Image, number, number, number, number).");}
		if(hscale instanceof Promise) {throw new TypeError("4th input argument in function 'createImageScaled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hscale != "number") {throw new TypeError("4th input argument '"+hscale+"' in function 'createImageScaled' is of type '"+(typeof hscale)+"'. Expected type 'number'. Function Signature: createImageScaled(Image, number, number, number, number).");}
		if(vscale instanceof Promise) {throw new TypeError("5th input argument in function 'createImageScaled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vscale != "number") {throw new TypeError("5th input argument '"+vscale+"' in function 'createImageScaled' is of type '"+(typeof vscale)+"'. Expected type 'number'. Function Signature: createImageScaled(Image, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createImageScaled', {"b": this.id, "img": img.id, "x": x, "y": y, "hscale": hscale, "vscale": vscale}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create e_group_begin Element (i.e. 'q' operator in PDF content stream).
	* The function saves the current graphics state.
	*/
		PDFNet.ElementBuilder.prototype.createGroupBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createGroupBegin'. Expected "+0+" arguments. Function Signature: createGroupBegin()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createGroupBegin', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create e_group_end Element (i.e. 'Q' operator in PDF content stream).
	* The function restores the previous graphics state.
	*/
		PDFNet.ElementBuilder.prototype.createGroupEnd = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createGroupEnd'. Expected "+0+" arguments. Function Signature: createGroupEnd()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createGroupEnd', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a shading Element.
	*/
		PDFNet.ElementBuilder.prototype.createShading = function(sh)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createShading'. Expected "+1+" argument. Function Signature: createShading(Shading)")};
		if(sh instanceof Promise) {throw new TypeError("1st input argument in function 'createShading' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sh instanceof PDFNet.Shading)) {
			if(typeof sh == "object") {throw new TypeError("1st input argument in function 'createShading' is of type '"+sh.name+"'. Expected type 'Shading'. Function Signature: createShading(Shading).");}
			else {throw new TypeError("1st input argument '"+sh+"' in function 'createShading' is of type '"+(typeof sh)+"'. Expected type 'Shading'. Function Signature: createShading(Shading).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createShading', {"b": this.id, "sh": sh.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a Form XObject Element.
	* @param form a Form XObject content stream
	*/
		PDFNet.ElementBuilder.prototype.createFormFromStream = function(form)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFormFromStream'. Expected "+1+" argument. Function Signature: createFormFromStream(Obj)")};
		if(form instanceof Promise) {throw new TypeError("1st input argument in function 'createFormFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(form instanceof PDFNet.Obj)) {
			if(typeof form == "object") {throw new TypeError("1st input argument in function 'createFormFromStream' is of type '"+form.name+"'. Expected type 'Obj'. Function Signature: createFormFromStream(Obj).");}
			else {throw new TypeError("1st input argument '"+form+"' in function 'createFormFromStream' is of type '"+(typeof form)+"'. Expected type 'Obj'. Function Signature: createFormFromStream(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createFormFromStream', {"b": this.id, "form": form.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a Form XObject Element using the content of the existing page.
	* This method assumes that the XObject will be used in the same
	* document as the given page. If you need to create the Form XObject
	* in a different document use CreateForm(Page, Doc) method.
	*
	* @param page A page used to create the Form XObject.
	*/
		PDFNet.ElementBuilder.prototype.createFormFromPage = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFormFromPage'. Expected "+1+" argument. Function Signature: createFormFromPage(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFormFromPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFormFromPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFormFromPage(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFormFromPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFormFromPage(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createFormFromPage', {"b": this.id, "page": page.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a Form XObject Element using the content of the existing page.
	* Unlike CreateForm(Page) method, you can use this method to create form
	* in another document.
	*
	* @param page A page used to create the Form XObject.
	* @param doc Destination document for the Form XObject.
	*/
		PDFNet.ElementBuilder.prototype.createFormFromDoc = function(page, doc)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createFormFromDoc'. Expected "+2+" arguments. Function Signature: createFormFromDoc(Page, PDFDoc)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'createFormFromDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'createFormFromDoc' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: createFormFromDoc(Page, PDFDoc).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'createFormFromDoc' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: createFormFromDoc(Page, PDFDoc).");}
		}
		if(doc instanceof Promise) {throw new TypeError("2nd input argument in function 'createFormFromDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("2nd input argument in function 'createFormFromDoc' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: createFormFromDoc(Page, PDFDoc).");}
			else {throw new TypeError("2nd input argument '"+doc+"' in function 'createFormFromDoc' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: createFormFromDoc(Page, PDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createFormFromDoc', {"b": this.id, "page": page.id, "doc": doc.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Start a text block ('BT' operator in PDF content stream).
	* The function installs the given font in the current graphics state.
	*/
		PDFNet.ElementBuilder.prototype.createTextBeginWithFont = function(font, font_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createTextBeginWithFont'. Expected "+2+" arguments. Function Signature: createTextBeginWithFont(Font, number)")};
		if(font instanceof Promise) {throw new TypeError("1st input argument in function 'createTextBeginWithFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("1st input argument in function 'createTextBeginWithFont' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: createTextBeginWithFont(Font, number).");}
			else {throw new TypeError("1st input argument '"+font+"' in function 'createTextBeginWithFont' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: createTextBeginWithFont(Font, number).");}
		}
		if(font_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'createTextBeginWithFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_sz != "number") {throw new TypeError("2nd input argument '"+font_sz+"' in function 'createTextBeginWithFont' is of type '"+(typeof font_sz)+"'. Expected type 'number'. Function Signature: createTextBeginWithFont(Font, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextBeginWithFont', {"b": this.id, "font": font.id, "font_sz": font_sz}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Start a text block ('BT' operator in PDF content stream).
	*/
		PDFNet.ElementBuilder.prototype.createTextBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createTextBegin'. Expected "+0+" arguments. Function Signature: createTextBegin()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextBegin', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Ends a text block.
	*/
		PDFNet.ElementBuilder.prototype.createTextEnd = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createTextEnd'. Expected "+0+" arguments. Function Signature: createTextEnd()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextEnd', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a text run using the given font.
	* @note a text run can be created only within a text block
	*/
		PDFNet.ElementBuilder.prototype.createTextRun = function(text_data, font, font_sz)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createTextRun'. Expected "+3+" arguments. Function Signature: createTextRun(string, Font, number)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createTextRun' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createTextRun' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createTextRun(string, Font, number).");}
		if(font instanceof Promise) {throw new TypeError("2nd input argument in function 'createTextRun' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("2nd input argument in function 'createTextRun' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: createTextRun(string, Font, number).");}
			else {throw new TypeError("2nd input argument '"+font+"' in function 'createTextRun' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: createTextRun(string, Font, number).");}
		}
		if(font_sz instanceof Promise) {throw new TypeError("3rd input argument in function 'createTextRun' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_sz != "number") {throw new TypeError("3rd input argument '"+font_sz+"' in function 'createTextRun' is of type '"+(typeof font_sz)+"'. Expected type 'number'. Function Signature: createTextRun(string, Font, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextRun', {"b": this.id, "text_data": text_data, "font": font.id, "font_sz": font_sz}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createTextRunWithSize = function(text_data, text_data_sz, font, font_sz)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'createTextRunWithSize'. Expected "+4+" arguments. Function Signature: createTextRunWithSize(string, number, Font, number)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createTextRunWithSize' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createTextRunWithSize(string, number, Font, number).");}
		if(text_data_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'createTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data_sz != "number") {throw new TypeError("2nd input argument '"+text_data_sz+"' in function 'createTextRunWithSize' is of type '"+(typeof text_data_sz)+"'. Expected type 'number'. Function Signature: createTextRunWithSize(string, number, Font, number).");}
		if(font instanceof Promise) {throw new TypeError("3rd input argument in function 'createTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("3rd input argument in function 'createTextRunWithSize' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: createTextRunWithSize(string, number, Font, number).");}
			else {throw new TypeError("3rd input argument '"+font+"' in function 'createTextRunWithSize' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: createTextRunWithSize(string, number, Font, number).");}
		}
		if(font_sz instanceof Promise) {throw new TypeError("4th input argument in function 'createTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_sz != "number") {throw new TypeError("4th input argument '"+font_sz+"' in function 'createTextRunWithSize' is of type '"+(typeof font_sz)+"'. Expected type 'number'. Function Signature: createTextRunWithSize(string, number, Font, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextRunWithSize', {"b": this.id, "text_data": text_data, "text_data_sz": text_data_sz, "font": font.id, "font_sz": font_sz}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createTextRunUnsigned = function(text_data, font, font_sz)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createTextRunUnsigned'. Expected "+3+" arguments. Function Signature: createTextRunUnsigned(string, Font, number)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createTextRunUnsigned' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createTextRunUnsigned' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createTextRunUnsigned(string, Font, number).");}
		if(font instanceof Promise) {throw new TypeError("2nd input argument in function 'createTextRunUnsigned' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("2nd input argument in function 'createTextRunUnsigned' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: createTextRunUnsigned(string, Font, number).");}
			else {throw new TypeError("2nd input argument '"+font+"' in function 'createTextRunUnsigned' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: createTextRunUnsigned(string, Font, number).");}
		}
		if(font_sz instanceof Promise) {throw new TypeError("3rd input argument in function 'createTextRunUnsigned' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_sz != "number") {throw new TypeError("3rd input argument '"+font_sz+"' in function 'createTextRunUnsigned' is of type '"+(typeof font_sz)+"'. Expected type 'number'. Function Signature: createTextRunUnsigned(string, Font, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextRunUnsigned', {"b": this.id, "text_data": text_data, "font": font.id, "font_sz": font_sz}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createNewTextRun = function(text_data)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createNewTextRun'. Expected "+1+" argument. Function Signature: createNewTextRun(string)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createNewTextRun' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createNewTextRun' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createNewTextRun(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createNewTextRun', {"b": this.id, "text_data": text_data}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createNewTextRunWithSize = function(text_data, text_data_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createNewTextRunWithSize'. Expected "+2+" arguments. Function Signature: createNewTextRunWithSize(string, number)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createNewTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createNewTextRunWithSize' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createNewTextRunWithSize(string, number).");}
		if(text_data_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'createNewTextRunWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data_sz != "number") {throw new TypeError("2nd input argument '"+text_data_sz+"' in function 'createNewTextRunWithSize' is of type '"+(typeof text_data_sz)+"'. Expected type 'number'. Function Signature: createNewTextRunWithSize(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createNewTextRunWithSize', {"b": this.id, "text_data": text_data, "text_data_sz": text_data_sz}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createNewTextRunUnsigned = function(text_data)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createNewTextRunUnsigned'. Expected "+1+" argument. Function Signature: createNewTextRunUnsigned(string)")};
		if(text_data instanceof Promise) {throw new TypeError("1st input argument in function 'createNewTextRunUnsigned' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_data != "string") {throw new TypeError("1st input argument '"+text_data+"' in function 'createNewTextRunUnsigned' is of type '"+(typeof text_data)+"'. Expected type 'string'. Function Signature: createNewTextRunUnsigned(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createNewTextRunUnsigned', {"b": this.id, "text_data": text_data}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create e_text_new_line Element (i.e. a Td operator in PDF content stream).
	* Move to the start of the next line, offset from the start of the current
	* line by (dx , dy). dx and dy are numbers expressed in unscaled text space
	* units.
	*/
		PDFNet.ElementBuilder.prototype.createTextNewLineWithOffset = function(dx, dy)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createTextNewLineWithOffset'. Expected "+2+" arguments. Function Signature: createTextNewLineWithOffset(number, number)")};
		if(dx instanceof Promise) {throw new TypeError("1st input argument in function 'createTextNewLineWithOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dx != "number") {throw new TypeError("1st input argument '"+dx+"' in function 'createTextNewLineWithOffset' is of type '"+(typeof dx)+"'. Expected type 'number'. Function Signature: createTextNewLineWithOffset(number, number).");}
		if(dy instanceof Promise) {throw new TypeError("2nd input argument in function 'createTextNewLineWithOffset' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dy != "number") {throw new TypeError("2nd input argument '"+dy+"' in function 'createTextNewLineWithOffset' is of type '"+(typeof dy)+"'. Expected type 'number'. Function Signature: createTextNewLineWithOffset(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextNewLineWithOffset', {"b": this.id, "dx": dx, "dy": dy}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create e_text_new_line Element (i.e. a T* operator in PDF content stream).
	*/
		PDFNet.ElementBuilder.prototype.createTextNewLine = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createTextNewLine'. Expected "+0+" arguments. Function Signature: createTextNewLine()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createTextNewLine', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

		PDFNet.ElementBuilder.prototype.createPath = function(buf_points, buf_seg_types)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createPath'. Expected "+2+" arguments. Function Signature: createPath(ArrayBuffer, ArrayBuffer)")};
		if(buf_points instanceof Promise) {throw new TypeError("1st input argument in function 'createPath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_points.buffer instanceof ArrayBuffer)) {
			if(typeof buf_points == "object") {throw new TypeError("1st input argument in function 'createPath' is of type '"+buf_points.name+"'. Expected type 'ArrayBuffer'. Function Signature: createPath(ArrayBuffer, ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf_points+"' in function 'createPath' is of type '"+(typeof buf_points)+"'. Expected type 'ArrayBuffer'. Function Signature: createPath(ArrayBuffer, ArrayBuffer).");}
		}
		if(buf_seg_types instanceof Promise) {throw new TypeError("3rd input argument in function 'createPath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_seg_types.buffer instanceof ArrayBuffer)) {
			if(typeof buf_seg_types == "object") {throw new TypeError("3rd input argument in function 'createPath' is of type '"+buf_seg_types.name+"'. Expected type 'ArrayBuffer'. Function Signature: createPath(ArrayBuffer, ArrayBuffer).");}
			else {throw new TypeError("3rd input argument '"+buf_seg_types+"' in function 'createPath' is of type '"+(typeof buf_seg_types)+"'. Expected type 'ArrayBuffer'. Function Signature: createPath(ArrayBuffer, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createPath', {"b": this.id, "buf_points": buf_points.buffer, "buf_seg_types": buf_seg_types.buffer}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create a rectangle path Element.
	*
	* @param x, y The coordinates of the lower left corner of the rectangle.
	* @param width, height - The width and height of the rectangle.
	*/
		PDFNet.ElementBuilder.prototype.createRect = function(x, y, width, height)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'createRect'. Expected "+4+" arguments. Function Signature: createRect(number, number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'createRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'createRect' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: createRect(number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'createRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'createRect' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: createRect(number, number, number, number).");}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'createRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'createRect' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createRect(number, number, number, number).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'createRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'createRect' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createRect(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createRect', {"b": this.id, "x": x, "y": y, "width": width, "height": height}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Create an ellipse (or circle, if rx == ry) path Element.
	*
	* @param cx, cy The coordinates of the ellipse center.
	* @param rx, ry - The width and height of the ellipse rectangle.
	*/
		PDFNet.ElementBuilder.prototype.createEllipse = function(cx, cy, rx, ry)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'createEllipse'. Expected "+4+" arguments. Function Signature: createEllipse(number, number, number, number)")};
		if(cx instanceof Promise) {throw new TypeError("1st input argument in function 'createEllipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cx != "number") {throw new TypeError("1st input argument '"+cx+"' in function 'createEllipse' is of type '"+(typeof cx)+"'. Expected type 'number'. Function Signature: createEllipse(number, number, number, number).");}
		if(cy instanceof Promise) {throw new TypeError("2nd input argument in function 'createEllipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cy != "number") {throw new TypeError("2nd input argument '"+cy+"' in function 'createEllipse' is of type '"+(typeof cy)+"'. Expected type 'number'. Function Signature: createEllipse(number, number, number, number).");}
		if(rx instanceof Promise) {throw new TypeError("3rd input argument in function 'createEllipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rx != "number") {throw new TypeError("3rd input argument '"+rx+"' in function 'createEllipse' is of type '"+(typeof rx)+"'. Expected type 'number'. Function Signature: createEllipse(number, number, number, number).");}
		if(ry instanceof Promise) {throw new TypeError("4th input argument in function 'createEllipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ry != "number") {throw new TypeError("4th input argument '"+ry+"' in function 'createEllipse' is of type '"+(typeof ry)+"'. Expected type 'number'. Function Signature: createEllipse(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.createEllipse', {"b": this.id, "cx": cx, "cy": cy, "rx": rx, "ry": ry}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Starts building a new path Element that can contain an arbitrary sequence
	* of lines, curves, and rectangles.
	*/
		PDFNet.ElementBuilder.prototype.pathBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'pathBegin'. Expected "+0+" arguments. Function Signature: pathBegin()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.pathBegin', {"b": this.id}, this.userPriority);
	},

	/**
	* Finishes building of the path Element.
	* @return A promise that resolves to the path Element
	*/
		PDFNet.ElementBuilder.prototype.pathEnd = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'pathEnd'. Expected "+0+" arguments. Function Signature: pathEnd()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.pathEnd', {"b": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* Add a rectangle to the current path as a complete subpath.
	* Setting the current point is not required before using this function.
	*
	* @param x, y The coordinates of the lower left corner of the rectangle.
	* @param width, height - The width and height of the rectangle.
	*/
		PDFNet.ElementBuilder.prototype.rect = function(cx, cy, rx, ry)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'rect'. Expected "+4+" arguments. Function Signature: rect(number, number, number, number)")};
		if(cx instanceof Promise) {throw new TypeError("1st input argument in function 'rect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cx != "number") {throw new TypeError("1st input argument '"+cx+"' in function 'rect' is of type '"+(typeof cx)+"'. Expected type 'number'. Function Signature: rect(number, number, number, number).");}
		if(cy instanceof Promise) {throw new TypeError("2nd input argument in function 'rect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cy != "number") {throw new TypeError("2nd input argument '"+cy+"' in function 'rect' is of type '"+(typeof cy)+"'. Expected type 'number'. Function Signature: rect(number, number, number, number).");}
		if(rx instanceof Promise) {throw new TypeError("3rd input argument in function 'rect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rx != "number") {throw new TypeError("3rd input argument '"+rx+"' in function 'rect' is of type '"+(typeof rx)+"'. Expected type 'number'. Function Signature: rect(number, number, number, number).");}
		if(ry instanceof Promise) {throw new TypeError("4th input argument in function 'rect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ry != "number") {throw new TypeError("4th input argument '"+ry+"' in function 'rect' is of type '"+(typeof ry)+"'. Expected type 'number'. Function Signature: rect(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.rect', {"b": this.id, "cx": cx, "cy": cy, "rx": rx, "ry": ry}, this.userPriority);
	},

	/**
	* Add an ellipse (or circle, if rx == ry) to the current path as a complete subpath.
	* Setting the current point is not required before using this function.
	*
	* @param cx, cy The coordinates of the ellipse center.
	* @param rx, ry - The radii of the ellipse.
	*/
		PDFNet.ElementBuilder.prototype.ellipse = function(x, y, width, height)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'ellipse'. Expected "+4+" arguments. Function Signature: ellipse(number, number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'ellipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'ellipse' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: ellipse(number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'ellipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'ellipse' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: ellipse(number, number, number, number).");}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'ellipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'ellipse' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: ellipse(number, number, number, number).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'ellipse' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'ellipse' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: ellipse(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.ellipse', {"b": this.id, "x": x, "y": y, "width": width, "height": height}, this.userPriority);
	},

	/**
	* Set the current point.
	*/
		PDFNet.ElementBuilder.prototype.moveTo = function(x, y)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'moveTo'. Expected "+2+" arguments. Function Signature: moveTo(number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'moveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'moveTo' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: moveTo(number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'moveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'moveTo' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: moveTo(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.moveTo', {"b": this.id, "x": x, "y": y}, this.userPriority);
	},

	/**
	* Draw a line from the current point to the given point.
	*/
		PDFNet.ElementBuilder.prototype.lineTo = function(x, y)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'lineTo'. Expected "+2+" arguments. Function Signature: lineTo(number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'lineTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'lineTo' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: lineTo(number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'lineTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'lineTo' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: lineTo(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.lineTo', {"b": this.id, "x": x, "y": y}, this.userPriority);
	},

	/**
	* Draw a Bezier curve from the current point to the given point (x2, y2) using
	* (cx1, cy1) and (cx2, cy2) as control points.
	*/
		PDFNet.ElementBuilder.prototype.curveTo = function(cx1, cy1, cx2, cy2, x2, y2)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'curveTo'. Expected "+6+" arguments. Function Signature: curveTo(number, number, number, number, number, number)")};
		if(cx1 instanceof Promise) {throw new TypeError("1st input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cx1 != "number") {throw new TypeError("1st input argument '"+cx1+"' in function 'curveTo' is of type '"+(typeof cx1)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		if(cy1 instanceof Promise) {throw new TypeError("2nd input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cy1 != "number") {throw new TypeError("2nd input argument '"+cy1+"' in function 'curveTo' is of type '"+(typeof cy1)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		if(cx2 instanceof Promise) {throw new TypeError("3rd input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cx2 != "number") {throw new TypeError("3rd input argument '"+cx2+"' in function 'curveTo' is of type '"+(typeof cx2)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		if(cy2 instanceof Promise) {throw new TypeError("4th input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cy2 != "number") {throw new TypeError("4th input argument '"+cy2+"' in function 'curveTo' is of type '"+(typeof cy2)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("5th input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("5th input argument '"+x2+"' in function 'curveTo' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("6th input argument in function 'curveTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("6th input argument '"+y2+"' in function 'curveTo' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: curveTo(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.curveTo', {"b": this.id, "cx1": cx1, "cy1": cy1, "cx2": cx2, "cy2": cy2, "x2": x2, "y2": y2}, this.userPriority);
	},

	/**
	* Draw an arc with the specified parameters (lower left corner, width, height and angles).
	*
	* @param	x, y			coordinates of the lower left corner of the ellipse encompassing rectangle
	* @param	width, height	overall width and height of the full ellipse (not considering the angular extents).
	* @param	start			starting angle of the arc in degrees
	* @param	extent			angular extent of the arc in degrees
	*/
		PDFNet.ElementBuilder.prototype.arcTo = function(x, y, width, height, start, extent)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'arcTo'. Expected "+6+" arguments. Function Signature: arcTo(number, number, number, number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'arcTo' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'arcTo' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'arcTo' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'arcTo' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		if(start instanceof Promise) {throw new TypeError("5th input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start != "number") {throw new TypeError("5th input argument '"+start+"' in function 'arcTo' is of type '"+(typeof start)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		if(extent instanceof Promise) {throw new TypeError("6th input argument in function 'arcTo' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof extent != "number") {throw new TypeError("6th input argument '"+extent+"' in function 'arcTo' is of type '"+(typeof extent)+"'. Expected type 'number'. Function Signature: arcTo(number, number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.arcTo', {"b": this.id, "x": x, "y": y, "width": width, "height": height, "start": start, "extent": extent}, this.userPriority);
	},

	/**
	* Draw an arc from the current point to the end point.
	*
	* @param xr, yr				x and y radius for the arc
	* @param rx					x-axis rotation in degrees
	* @param isLargeArc			indicates if smaller or larger arc is chosen
	*								1 - one of the two larger arc sweeps is chosen
	*								0 - one of the two smaller arc sweeps is chosen
	* @param sweep					direction in which arc is drawn (1 - clockwise, 0 - counterclockwise)
	* @param endX, endY			end point
	*
	* @note The Arc is defined the same way as it is specified by SVG or XPS standards. For
	*		further questions please refer to the XPS or SVG standards.
	*/
		PDFNet.ElementBuilder.prototype.arcTo2 = function(xr, yr, rx, isLargeArc, sweep, endX, endY)
	{
		if(arguments.length != 7) {throw new RangeError(arguments.length+" arguments passed into function 'arcTo2'. Expected "+7+" arguments. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number)")};
		if(xr instanceof Promise) {throw new TypeError("1st input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof xr != "number") {throw new TypeError("1st input argument '"+xr+"' in function 'arcTo2' is of type '"+(typeof xr)+"'. Expected type 'number'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(yr instanceof Promise) {throw new TypeError("2nd input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof yr != "number") {throw new TypeError("2nd input argument '"+yr+"' in function 'arcTo2' is of type '"+(typeof yr)+"'. Expected type 'number'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(rx instanceof Promise) {throw new TypeError("3rd input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rx != "number") {throw new TypeError("3rd input argument '"+rx+"' in function 'arcTo2' is of type '"+(typeof rx)+"'. Expected type 'number'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(isLargeArc instanceof Promise) {throw new TypeError("4th input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof isLargeArc != "boolean") {throw new TypeError("4th input argument '"+isLargeArc+"' in function 'arcTo2' is of type '"+(typeof isLargeArc)+"'. Expected type 'boolean'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(sweep instanceof Promise) {throw new TypeError("5th input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof sweep != "boolean") {throw new TypeError("5th input argument '"+sweep+"' in function 'arcTo2' is of type '"+(typeof sweep)+"'. Expected type 'boolean'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(endX instanceof Promise) {throw new TypeError("6th input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof endX != "number") {throw new TypeError("6th input argument '"+endX+"' in function 'arcTo2' is of type '"+(typeof endX)+"'. Expected type 'number'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		if(endY instanceof Promise) {throw new TypeError("7th input argument in function 'arcTo2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof endY != "number") {throw new TypeError("7th input argument '"+endY+"' in function 'arcTo2' is of type '"+(typeof endY)+"'. Expected type 'number'. Function Signature: arcTo2(number, number, number, boolean, boolean, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.arcTo2', {"b": this.id, "xr": xr, "yr": yr, "rx": rx, "isLargeArc": isLargeArc, "sweep": sweep, "endX": endX, "endY": endY}, this.userPriority);
	},

	/**
	* Closes the current subpath.
	*/
		PDFNet.ElementBuilder.prototype.closePath = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'closePath'. Expected "+0+" arguments. Function Signature: closePath()")};
		return PDFNet.messageHandler.sendWithPromise('ElementBuilder.closePath', {"b": this.id}, this.userPriority);
	},

		PDFNet.ElementReader.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('elementReaderCreate', {}, this.userPriority).then(function(id){
			//there is a return type ElementReader
			if(id == "0"){
				return null;
			}
			return new PDFNet.ElementReader(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ElementReader.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.destroy', {"r": this.id}, this.userPriority);
	},

	/**
	* begin processing a page.
	*
	* @param page A page to start processing.
	*
	* @param ocg_context An optional parameter used to specify the Optional Content (OC)
	* Context that should be used when processing the page. When the OCG::Context is specified,
	* Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
	* current Optional Content Group (OCG) and the states of flags in the given context.
	*
	* @note When page processing is completed, make sure to call ElementReader.End().
	*/
		PDFNet.ElementReader.prototype.beginOnPage = function(page, ctx)
	{
		if(typeof ctx === "undefined") {ctx = new PDFNet.OCGContext("0");};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'beginOnPage'. Expected "+1+" to "+2+" arguments. Function Signature: beginOnPage(Page, OCGContext)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'beginOnPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: beginOnPage(Page, OCGContext).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'beginOnPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: beginOnPage(Page, OCGContext).");}
		}
		if(ctx instanceof Promise) {throw new TypeError("2nd input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("2nd input argument in function 'beginOnPage' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: beginOnPage(Page, OCGContext).");}
			else {throw new TypeError("2nd input argument '"+ctx+"' in function 'beginOnPage' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: beginOnPage(Page, OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.beginOnPage', {"r": this.id, "page": page.id, "ctx": ctx.id}, this.userPriority);
	},

	/**
	* begin processing given content stream. The content stream may be
	* a Form XObject, Type3 glyph stream, pattern stream or any other content stream.
	*
	* @param content_stream - A stream object representing the content stream (usually
	* a Form XObject).
	*
	* @param resource_dict - An optional '/Resource' dictionary parameter.
	* If content stream refers to named resources that are not present in
	* the local Resource dictionary, the names are looked up in the supplied
	* resource dictionary.
	*
	* @param ocg_context An optional parameter used to specify the Optional Content (OC)
	* Context that should be used when processing the page. When the OCG::Context is specified,
	* Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
	* current Optional Content Group (OCG) and the states of flags in the given context.
	*
	* @note When page processing is completed, make sure to call ElementReader.End().
	*/
		PDFNet.ElementReader.prototype.begin = function(content_stream, resource_dict, ctx)
	{
		if(typeof resource_dict === "undefined") {resource_dict = new PDFNet.Obj("0");};
		if(typeof ctx === "undefined") {ctx = new PDFNet.OCGContext("0");};
		if((arguments.length < 1) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+1+" to "+3+" arguments. Function Signature: begin(Obj, Obj, OCGContext)")};
		if(content_stream instanceof Promise) {throw new TypeError("1st input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(content_stream instanceof PDFNet.Obj)) {
			if(typeof content_stream == "object") {throw new TypeError("1st input argument in function 'begin' is of type '"+content_stream.name+"'. Expected type 'Obj'. Function Signature: begin(Obj, Obj, OCGContext).");}
			else {throw new TypeError("1st input argument '"+content_stream+"' in function 'begin' is of type '"+(typeof content_stream)+"'. Expected type 'Obj'. Function Signature: begin(Obj, Obj, OCGContext).");}
		}
		if(resource_dict instanceof Promise) {throw new TypeError("2nd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(resource_dict instanceof PDFNet.Obj)) {
			if(typeof resource_dict == "object") {throw new TypeError("2nd input argument in function 'begin' is of type '"+resource_dict.name+"'. Expected type 'Obj'. Function Signature: begin(Obj, Obj, OCGContext).");}
			else {throw new TypeError("2nd input argument '"+resource_dict+"' in function 'begin' is of type '"+(typeof resource_dict)+"'. Expected type 'Obj'. Function Signature: begin(Obj, Obj, OCGContext).");}
		}
		if(ctx instanceof Promise) {throw new TypeError("3rd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("3rd input argument in function 'begin' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: begin(Obj, Obj, OCGContext).");}
			else {throw new TypeError("3rd input argument '"+ctx+"' in function 'begin' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: begin(Obj, Obj, OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.begin', {"r": this.id, "content_stream": content_stream.id, "resource_dict": resource_dict.id, "ctx": ctx.id}, this.userPriority);
	},

	/**
	* @param extra resource dictionary for finding images, fonts, etc.
	*/
		PDFNet.ElementReader.prototype.appendResource = function(res)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'appendResource'. Expected "+1+" argument. Function Signature: appendResource(Obj)")};
		if(res instanceof Promise) {throw new TypeError("1st input argument in function 'appendResource' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(res instanceof PDFNet.Obj)) {
			if(typeof res == "object") {throw new TypeError("1st input argument in function 'appendResource' is of type '"+res.name+"'. Expected type 'Obj'. Function Signature: appendResource(Obj).");}
			else {throw new TypeError("1st input argument '"+res+"' in function 'appendResource' is of type '"+(typeof res)+"'. Expected type 'Obj'. Function Signature: appendResource(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.appendResource', {"r": this.id, "res": res.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a page Element or a 'NULL' element if the end of current-display list was
	* reached. You may use GetType() to determine the type of the returned Element.
	*
	* @note Every call to ElementReader::Next() destroys the current Element.
	* Therefore, an Element becomes invalid after subsequent
	* ElementReader::Next() operation.
	*/
		PDFNet.ElementReader.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.next', {"r": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* @return A promise that resolves to the current Element or a 'NULL' Element. The current element is the one
	* returned in the last call to Next().
	*
	* @note Every call to ElementReader::Next() destroys the current Element. Therefore, an
	* Element becomes invalid after subsequent ElementReader::Next() operation.
	*/
		PDFNet.ElementReader.prototype.current = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'current'. Expected "+0+" arguments. Function Signature: current()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.current', {"r": this.id}, this.userPriority).then(function(id){
			//there is a return type Element
			if(id == "0"){
				return null;
			}
			return new PDFNet.Element(id);
		});
	},

	/**
	* when the current element is a form XObject you have the option to skip form
	* processing (by not calling FormBegin()) or to open the form stream and
	* continue Element traversal into the form.
	*
	* To open a form XObject display list use FormBegin() method. The Next() returned
	* Element will be the first Element in the form XObject display list. Subsequent calls to Next()
	* will traverse form's display list until NULL is returned. At any point you can
	* close the form sub-list using ElementReader::End() method. After the form display
	* list is closed (using End()) the processing will return to the parent display list
	* at the point where it left off before entering the form XObject.
	*/
		PDFNet.ElementReader.prototype.formBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'formBegin'. Expected "+0+" arguments. Function Signature: formBegin()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.formBegin', {"r": this.id}, this.userPriority);
	},

	/**
	* a method used to spawn the sub-display list representing the tiling pattern
	* of the current element in the ElementReader. You can call this method at any
	* point as long as the current element is valid.
	*
	* @param fill_pattern If true, the filling pattern of the current element will
	* be spawned; otherwise, the stroking pattern of the current element will be
	* spawned. Note that the graphics state will be inherited from the parent content
	* stream (the content stream in which the pattern is defined as a resource) automatically.
	*
	* @param reset_ctm_tfm An optional parameter used to indicate whether the pattern's
	* display list should set its initial CTM and transformation matrices to identity matrix.
	* In general, we should leave it to be false.
	*
	* To open a tiling pattern sub-display list use PatternBegin(pattern) method.
	* The Next() returned Element will be the first Element in the pattern display list.
	* Subsequent calls to Next() will traverse pattern's display list until NULL is
	* encountered. At any point you can close the pattern sub-list using
	* ElementReader::End() method. After the pattern display list is closed,
	* the processing will return to the parent display list at the point where
	* pattern display list was spawned.
	*/
		PDFNet.ElementReader.prototype.patternBegin = function(fill_pattern, reset_ctm_tfm)
	{
		if(typeof reset_ctm_tfm === "undefined") {reset_ctm_tfm = false;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'patternBegin'. Expected "+1+" to "+2+" arguments. Function Signature: patternBegin(boolean, boolean)")};
		if(fill_pattern instanceof Promise) {throw new TypeError("1st input argument in function 'patternBegin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof fill_pattern != "boolean") {throw new TypeError("1st input argument '"+fill_pattern+"' in function 'patternBegin' is of type '"+(typeof fill_pattern)+"'. Expected type 'boolean'. Function Signature: patternBegin(boolean, boolean).");}
		if(reset_ctm_tfm instanceof Promise) {throw new TypeError("2nd input argument in function 'patternBegin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof reset_ctm_tfm != "boolean") {throw new TypeError("2nd input argument '"+reset_ctm_tfm+"' in function 'patternBegin' is of type '"+(typeof reset_ctm_tfm)+"'. Expected type 'boolean'. Function Signature: patternBegin(boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.patternBegin', {"r": this.id, "fill_pattern": fill_pattern, "reset_ctm_tfm": reset_ctm_tfm}, this.userPriority);
	},

	/**
	* A method used to spawn a sub-display list representing a Type3 Font glyph. You can
	* call this method at any point as long as the current element in the ElementReader
	* is a text element whose font type is type 3.
	*
	* @param char_data The information about the glyph to process. You can get this information
	* by dereferencing a CharIterator.
	*
	* @param resource_dict - An optional '/Resource' dictionary parameter.
	* If any glyph descriptions refer to named resources but Font Resource dictionary
	* is absent, the names are looked up in the supplied resource dictionary.
	*
	* To open a Type3 font sub-display list use Type3FontBegin() method. The Next()
	* returned Element will be the first Element in the glyph's display list.
	* Subsequent calls to Next() will traverse glyph's display list until NULL is
	* returned. At any point you can close the glyph sub-list using ElementReader::End()
	* method. After the glyph display list is closed, the processing will return to the
	* parent display list at the point where glyph display list was spawned.
	*/
		PDFNet.ElementReader.prototype.type3FontBegin = function(char_data, resource_dict)
	{
		if(typeof resource_dict === "undefined") {resource_dict = new PDFNet.Obj("0");};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'type3FontBegin'. Expected "+1+" to "+2+" arguments. Function Signature: type3FontBegin(CharData, Obj)")};
		if(char_data instanceof Promise) {throw new TypeError("1st input argument in function 'type3FontBegin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(char_data instanceof PDFNet.CharData) && char_data.name != "CharData") {
			if(typeof char_data == "object") {throw new TypeError("1st input argument in function 'type3FontBegin' is of type '"+char_data.name+"'. Expected type 'CharData'. Function Signature: type3FontBegin(CharData, Obj).");}
			else {throw new TypeError("1st input argument '"+char_data+"' in function 'type3FontBegin' is of type '"+(typeof char_data)+"'. Expected type 'CharData'. Function Signature: type3FontBegin(CharData, Obj).");}
		}
		if(resource_dict instanceof Promise) {throw new TypeError("2nd input argument in function 'type3FontBegin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(resource_dict instanceof PDFNet.Obj)) {
			if(typeof resource_dict == "object") {throw new TypeError("2nd input argument in function 'type3FontBegin' is of type '"+resource_dict.name+"'. Expected type 'Obj'. Function Signature: type3FontBegin(CharData, Obj).");}
			else {throw new TypeError("2nd input argument '"+resource_dict+"' in function 'type3FontBegin' is of type '"+(typeof resource_dict)+"'. Expected type 'Obj'. Function Signature: type3FontBegin(CharData, Obj).");}
		}
		if(typeof char_data.yieldFunction != "undefined") {throw new Error("Function '"+char_data.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'type3FontBegin'. Perhaps a yield statement is required for '"+char_data.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "ElementReader.type3FontBegin"; // TRN_CharData* char_data
		return PDFNet.messageHandler.sendWithPromise('ElementReader.type3FontBegin', {"r": this.id, "char_data": char_data, "resource_dict": resource_dict.id}, this.userPriority).then(function(id){
			copyFunc(id.char_data, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Close the current display list.
	*
	* If the current display list is a sub-list created using FormBegin(), PatternBegin(),
	* or Type3FontBegin() methods, the function will end the sub-list and will return
	* processing to the parent display list at the point where it left off before
	* entering the sub-list.
	*
	* @return A promise that resolves to true if the closed display list is a sub-list or false if it is a root
	* display list.
	*/
		PDFNet.ElementReader.prototype.end = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'end'. Expected "+0+" arguments. Function Signature: end()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.end', {"r": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an iterator to the beginning of the list containing identifiers of modified
	* graphics state attributes since the last call to ClearChangeList(). The list can
	* be consulted to determine which graphics states were modified between two
	* Elements. Attributes are ordered in the same way as they are set in the content
	* stream. Duplicate attributes are eliminated.
	*/
		PDFNet.ElementReader.prototype.getChangesIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getChangesIterator'. Expected "+0+" arguments. Function Signature: getChangesIterator()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getChangesIterator', {"r": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* @return A promise that resolves to true if given GState attribute was changed since the last call to
	* ClearChangeList().
	*/
		PDFNet.ElementReader.prototype.isChanged = function(attrib)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isChanged'. Expected "+1+" argument. Function Signature: isChanged(number)")};
		if(attrib instanceof Promise) {throw new TypeError("1st input argument in function 'isChanged' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof attrib != "number") {throw new TypeError("1st input argument '"+attrib+"' in function 'isChanged' is of type '"+(typeof attrib)+"'. Expected type 'number'. Function Signature: isChanged(number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.isChanged', {"r": this.id, "attrib": attrib}, this.userPriority);
	},

	/**
	* Clear the list containing identifiers of modified graphics state attributes.
	* The list of modified attributes is then accumulated during a subsequent call(s)
	* to ElementReader.Next().
	*/
		PDFNet.ElementReader.prototype.clearChangeList = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'clearChangeList'. Expected "+0+" arguments. Function Signature: clearChangeList()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.clearChangeList', {"r": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos object matching the specified name in the current resource
	* dictionary. For 'Page' the name is looked up in the page's /Resources/<Class>
	* dictionary. For Form XObjects, Patterns, and Type3 fonts that have a content
	* stream within page content stream the specified resource is first looked-up in the
	* resource dictionary of the inner stream. If the resource is not found, the name is
	* looked up in the outer content stream's resource dictionary. The function returns
	* NULL if the resource was not found.
	*/
		PDFNet.ElementReader.prototype.getFont = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFont'. Expected "+1+" argument. Function Signature: getFont(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getFont' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getFont(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getFont', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note see ElementReader::GetFont
	*/
		PDFNet.ElementReader.prototype.getXObject = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getXObject'. Expected "+1+" argument. Function Signature: getXObject(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getXObject' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getXObject' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getXObject(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getXObject', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note see ElementReader::GetFont
	*/
		PDFNet.ElementReader.prototype.getShading = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getShading'. Expected "+1+" argument. Function Signature: getShading(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getShading' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getShading' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getShading(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getShading', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note see ElementReader::GetFont
	*/
		PDFNet.ElementReader.prototype.getColorSpace = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getColorSpace'. Expected "+1+" argument. Function Signature: getColorSpace(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getColorSpace' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getColorSpace' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getColorSpace(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getColorSpace', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note see ElementReader::GetFont
	*/
		PDFNet.ElementReader.prototype.getPattern = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPattern'. Expected "+1+" argument. Function Signature: getPattern(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getPattern' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getPattern(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getPattern', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note see ElementReader::GetFont
	*/
		PDFNet.ElementReader.prototype.getExtGState = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getExtGState'. Expected "+1+" argument. Function Signature: getExtGState(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'getExtGState' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'getExtGState' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: getExtGState(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getExtGState', {"r": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.ElementWriter.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('elementWriterCreate', {}, this.userPriority).then(function(id){
			//there is a return type ElementWriter
			if(id == "0"){
				return null;
			}
			return new PDFNet.ElementWriter(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ElementWriter.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.destroy', {"w": this.id}, this.userPriority);
	},

	/**
	* begin writing to the given page.
	*
	* By default, new content will be appended to the page, as foreground graphics.
	* It is possible to add new page content as background graphics by setting the
	* second parameter in begin method to 'true' (e.g. writer.Begin(page, true)).
	*
	* @param page The page to write content.
	*
	* @param placement An optional flag indicating whether the new content should
	* be added as a foreground or background layer to the existing page. By default, the new
	* content will appear on top of the existing graphics.
	*
	* @param page_coord_sys An optional flag used to select the target coordinate system
	* if true (default), the coordinates are relative to the lower-left corner of the page,
	* otherwise the coordinates are defined in PDF user coordinate system (which may,
	* or may not coincide with the page coordinates).
	*
	* @param compress An optional flag indicating whether the page content stream
	* should be compressed. This may be useful for debugging content streams. Also
	* some applications need to do a clear text search on strings in the PDF files.
	* By default, all content streams are compressed.
	*/
		PDFNet.ElementWriter.prototype.beginOnPage = function(page, placement, page_coord_sys, compress)
	{
		if(typeof placement === "undefined") {placement = exports.PDFNet.ElementWriter.WriteMode.e_overlay};
		if(typeof page_coord_sys === "undefined") {page_coord_sys = true;};
		if(typeof compress === "undefined") {compress = true;};
		if((arguments.length < 1) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'beginOnPage'. Expected "+1+" to "+4+" arguments. Function Signature: beginOnPage(Page, number, boolean, boolean)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'beginOnPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: beginOnPage(Page, number, boolean, boolean).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'beginOnPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: beginOnPage(Page, number, boolean, boolean).");}
		}
		if(placement instanceof Promise) {throw new TypeError("2nd input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof placement != "number") {throw new TypeError("2nd input argument '"+placement+"' in function 'beginOnPage' is of type '"+(typeof placement)+"'. Expected type 'number'. Function Signature: beginOnPage(Page, number, boolean, boolean).");}
		if(page_coord_sys instanceof Promise) {throw new TypeError("3rd input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_coord_sys != "boolean") {throw new TypeError("3rd input argument '"+page_coord_sys+"' in function 'beginOnPage' is of type '"+(typeof page_coord_sys)+"'. Expected type 'boolean'. Function Signature: beginOnPage(Page, number, boolean, boolean).");}
		if(compress instanceof Promise) {throw new TypeError("4th input argument in function 'beginOnPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof compress != "boolean") {throw new TypeError("4th input argument '"+compress+"' in function 'beginOnPage' is of type '"+(typeof compress)+"'. Expected type 'boolean'. Function Signature: beginOnPage(Page, number, boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.beginOnPage', {"w": this.id, "page": page.id, "placement": placement, "page_coord_sys": page_coord_sys, "compress": compress}, this.userPriority);
	},

	/**
	* begin writing an Element sequence to a new stream. Use this function to write
	* Elements to a content stream other than the page. For example, you can create
	* Form XObjects (See Section '4.9 Form XObjects' in PDF Reference for more details)
	* pattern streams, Type3 font glyph streams, etc.
	*
	* @param doc - A low-level SDF/Cos document that will contain the new stream. You can
	* access low-level document using PDFDoc::GetSDFDoc() or Obj::GetDoc() methods.
	*
	* @param compress An optional flag indicating whether the page content stream
	* should be compressed. This may be useful for debugging content streams. Also
	* some applications need to do a clear text search on strings in the PDF files.
	* By default, all content streams are compressed.
	*
	* @note the newly created content stream object is returned when writing operations
	* are completed (i.e. after the call to ElementWriter::End()).
	*/
		PDFNet.ElementWriter.prototype.begin = function(doc, compress)
	{
		if(typeof compress === "undefined") {compress = true;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+1+" to "+2+" arguments. Function Signature: begin(SDFDoc, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'begin' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: begin(SDFDoc, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'begin' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: begin(SDFDoc, boolean).");}
		}
		if(compress instanceof Promise) {throw new TypeError("2nd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof compress != "boolean") {throw new TypeError("2nd input argument '"+compress+"' in function 'begin' is of type '"+(typeof compress)+"'. Expected type 'boolean'. Function Signature: begin(SDFDoc, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.begin', {"w": this.id, "doc": doc.id, "compress": compress}, this.userPriority);
	},

	/**
	* begin writing an Element sequence to a stream. Use this function to write
	* Elements to a content stream which will replace an existing content stream in an
	* object passed as a parameter.
	*
	* @param stream_obj_to_update - A low-level SDF stream object that will contain the new stream.
	* Old stream inside that object will be discarded.
	*
	* @param compress An optional flag indicating whether the content stream
	* should be compressed. This may be useful for debugging content streams. Also
	* some applications need to do a clear text search on strings in the PDF files.
	* By default, all content streams are compressed.
	*
	* @note The content stream object is returned when writing operations
	* are completed (i.e. after the call to ElementWriter::End()).
	*/
		PDFNet.ElementWriter.prototype.beginOnObj = function(obj, compress)
	{
		if(typeof compress === "undefined") {compress = true;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'beginOnObj'. Expected "+1+" to "+2+" arguments. Function Signature: beginOnObj(Obj, boolean)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'beginOnObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'beginOnObj' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: beginOnObj(Obj, boolean).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'beginOnObj' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: beginOnObj(Obj, boolean).");}
		}
		if(compress instanceof Promise) {throw new TypeError("2nd input argument in function 'beginOnObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof compress != "boolean") {throw new TypeError("2nd input argument '"+compress+"' in function 'beginOnObj' is of type '"+(typeof compress)+"'. Expected type 'boolean'. Function Signature: beginOnObj(Obj, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.beginOnObj', {"w": this.id, "obj": obj.id, "compress": compress}, this.userPriority);
	},

	/**
	* Finish writing to a page
	*
	* @return A promise that resolves to a low-level stream object that was used to store Elements.
	*/
		PDFNet.ElementWriter.prototype.end = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'end'. Expected "+0+" arguments. Function Signature: end()")};
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.end', {"w": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Writes the Element to the content stream.
	*/
		PDFNet.ElementWriter.prototype.writeElement = function(element)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeElement'. Expected "+1+" argument. Function Signature: writeElement(Element)")};
		if(element instanceof Promise) {throw new TypeError("1st input argument in function 'writeElement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(element instanceof PDFNet.Element)) {
			if(typeof element == "object") {throw new TypeError("1st input argument in function 'writeElement' is of type '"+element.name+"'. Expected type 'Element'. Function Signature: writeElement(Element).");}
			else {throw new TypeError("1st input argument '"+element+"' in function 'writeElement' is of type '"+(typeof element)+"'. Expected type 'Element'. Function Signature: writeElement(Element).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.writeElement', {"w": this.id, "element": element.id}, this.userPriority);
	},

	/**
	* A utility function that surrounds the given Element with a graphics state
	* Save/Restore Element (i.e. in PDF content stream represented as 'q element Q').
	*
	* The function is equivalent to calling WriteElement three times:
	*	 WriteElement(eSave);
	*	 WriteElement(element);
	*	 WriteElement(eRestore);
	*
	* where eSave is 'e_group_begin' and eRestore is 'e_group_end' Element
	*
	* The function is useful when XObjects such as Images and Forms are drawn on
	* the page.
	*/
		PDFNet.ElementWriter.prototype.writePlacedElement = function(element)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writePlacedElement'. Expected "+1+" argument. Function Signature: writePlacedElement(Element)")};
		if(element instanceof Promise) {throw new TypeError("1st input argument in function 'writePlacedElement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(element instanceof PDFNet.Element)) {
			if(typeof element == "object") {throw new TypeError("1st input argument in function 'writePlacedElement' is of type '"+element.name+"'. Expected type 'Element'. Function Signature: writePlacedElement(Element).");}
			else {throw new TypeError("1st input argument '"+element+"' in function 'writePlacedElement' is of type '"+(typeof element)+"'. Expected type 'Element'. Function Signature: writePlacedElement(Element).");}
		}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.writePlacedElement', {"w": this.id, "element": element.id}, this.userPriority);
	},

	/**
	* the Flush method flushes all pending Element writing operations.
	* This method is typically only required to be called when intermixing
	* direct content writing (i.e. WriteBuffer/WriteString) with Element writing.
	*/
		PDFNet.ElementWriter.prototype.flush = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'flush'. Expected "+0+" arguments. Function Signature: flush()")};
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.flush', {"w": this.id}, this.userPriority);
	},

		PDFNet.ElementWriter.prototype.writeBuffer = function(data, data_sz)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'writeBuffer'. Expected "+2+" arguments. Function Signature: writeBuffer(string, number)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'writeBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'writeBuffer' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: writeBuffer(string, number).");}
		if(data_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'writeBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data_sz != "number") {throw new TypeError("2nd input argument '"+data_sz+"' in function 'writeBuffer' is of type '"+(typeof data_sz)+"'. Expected type 'number'. Function Signature: writeBuffer(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.writeBuffer', {"w": this.id, "data": data, "data_sz": data_sz}, this.userPriority);
	},

	/**
	* Writes an arbitrary string to the content stream.
	* Serves the same purpose as WriteBuffer().
	*/
		PDFNet.ElementWriter.prototype.writeString = function(str)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'writeString'. Expected "+1+" argument. Function Signature: writeString(string)")};
		if(str instanceof Promise) {throw new TypeError("1st input argument in function 'writeString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof str != "string") {throw new TypeError("1st input argument '"+str+"' in function 'writeString' is of type '"+(typeof str)+"'. Expected type 'string'. Function Signature: writeString(string).");}
		return PDFNet.messageHandler.sendWithPromise('ElementWriter.writeString', {"w": this.id, "str": str}, this.userPriority);
	},

	/**
	* Creates a file specification for the given file. By default, the specified
	* file is embedded in PDF.
	*
	* @param doc - A document to which the FileSpec should be added. To obtain
	* SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
	*
	* @param path - The path to convert into a file specification.
	*
	* @param embed - A flag indicating whether to embed specified in the PDF.
	* By default, all files are embedded.
	*
	* @return A promise that resolves to newly created FileSpec object.
	*/
		PDFNet.FileSpec.create = function(doc, path, embed)
	{
		if(typeof embed === "undefined") {embed = true;};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" to "+3+" arguments. Function Signature: create(SDFDoc, string, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, string, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, string, boolean).");}
		}
		if(path instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("2nd input argument '"+path+"' in function 'create' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: create(SDFDoc, string, boolean).");}
		if(embed instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof embed != "boolean") {throw new TypeError("3rd input argument '"+embed+"' in function 'create' is of type '"+(typeof embed)+"'. Expected type 'boolean'. Function Signature: create(SDFDoc, string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('fileSpecCreate', {"doc": doc.id, "path": path, "embed": embed}, this.userPriority).then(function(id){
			//there is a return type FileSpec
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileSpec(id);
		});
	},

	/**
	* Creates a URL file specification.
	*
	* @param doc - A document to which the FileSpec should be added. To obtain
	* SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
	*
	* @param url - A uniform resource locator (URL) of the form defined in
	* Internet RFC 1738, Uniform Resource Locators Specification.
	*
	* @return A promise that resolves to newly created FileSpec object.
	*/
		PDFNet.FileSpec.createURL = function(doc, url)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createURL'. Expected "+2+" arguments. Function Signature: createURL(SDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createURL' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createURL' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createURL(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createURL' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createURL(SDFDoc, string).");}
		}
		if(url instanceof Promise) {throw new TypeError("2nd input argument in function 'createURL' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("2nd input argument '"+url+"' in function 'createURL' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: createURL(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('fileSpecCreateURL', {"doc": doc.id, "url": url}, this.userPriority).then(function(id){
			//there is a return type FileSpec
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileSpec(id);
		});
	},

	/**
	* Create a FileSpec and initialize it using given Cos/SDF object.
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.FileSpec.createFromObj = function(f)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(f instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(f instanceof PDFNet.Obj)) {
			if(typeof f == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+f.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+f+"' in function 'createFromObj' is of type '"+(typeof f)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fileSpecCreateFromObj', {"f": f.id}, this.userPriority).then(function(id){
			//there is a return type FileSpec
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileSpec(id);
		});
	},

		PDFNet.FileSpec.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('FileSpec.copy', {"d": this.id}, this.userPriority).then(function(id){
			//there is a return type FileSpec
			if(id == "0"){
				return null;
			}
			return new PDFNet.FileSpec(id);
		});
	},

		PDFNet.FileSpec.prototype.compare = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(FileSpec)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.FileSpec)) {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+d.name+"'. Expected type 'FileSpec'. Function Signature: compare(FileSpec).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'compare' is of type '"+(typeof d)+"'. Expected type 'FileSpec'. Function Signature: compare(FileSpec).");}
		}
		return PDFNet.messageHandler.sendWithPromise('FileSpec.compare', {"fs": this.id, "d": d.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to whether this is a valid (non-null) FileSpec. If the
	* function returns false the underlying SDF/Cos object is null or is not valid
	* and the FileSpec object should be treated as null as well.
	*/
		PDFNet.FileSpec.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('FileSpec.isValid', {"fs": this.id}, this.userPriority);
	},

	/**
	* The function saves the data referenced by this FileSpec to an external file.
	*
	* @param save_as An optional parameter indicating the filepath and filename
	* where the data should be saved. If this parameter is not specified, the function
	* will attempt to save the file using FileSpec.GetFilePath().
	*
	* If the file is embedded, the function saves the embedded file.
	* If the file is not embedded, the function will copy the external file.
	* If the file is not embedded and the external file can't be found, the function
	* returns false.
	*
	* @return A promise that resolves to true is the file was saved successfully, false otherwise.
	*/
		PDFNet.FileSpec.prototype.export = function(save_as)
	{
		if(typeof save_as === "undefined") {save_as = "";};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'export'. Expected at most "+1+" arguments. Function Signature: export(string)")};
		if(save_as instanceof Promise) {throw new TypeError("1st input argument in function 'export' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof save_as != "string") {throw new TypeError("1st input argument '"+save_as+"' in function 'export' is of type '"+(typeof save_as)+"'. Expected type 'string'. Function Signature: export(string).");}
		return PDFNet.messageHandler.sendWithPromise('FileSpec.export', {"fs": this.id, "save_as": save_as}, this.userPriority);
	},

	/**
	* The function returns data referenced by this FileSpec.
	*
	* @return A promise that resolves to a stream (filter) containing file data.
	* If the file is embedded, the function returns a stream to the embedded file.
	* If the file is not embedded, the function will return a stream to the external file.
	* If the file is not embedded and the external file can't be found, the function
	* returns NULL.
	*/
		PDFNet.FileSpec.prototype.getFileData = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFileData'. Expected "+0+" arguments. Function Signature: getFileData()")};
		return PDFNet.messageHandler.sendWithPromise('FileSpec.getFileData', {"fs": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to the file path for this file specification.
	*
	* If the FileSpec is a dictionary, a corresponding platform specific path
	* is returned (DOS, Mac, or Unix). Otherwise the function returns the path represented
	* in the form described in Section 3.10.1, 'File Specification Strings,' or , if the
	* file system is URL, as a uniform resource locator (URL). If the FileSpec is not
	* valid, an empty string is returned.
	*/
		PDFNet.FileSpec.prototype.getFilePath = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFilePath'. Expected "+0+" arguments. Function Signature: getFilePath()")};
		return PDFNet.messageHandler.sendWithPromise('FileSpec.getFilePath', {"fs": this.id}, this.userPriority);
	},

	/**
	* the functions sets the descriptive text associated with the file specification.
	* This test is typically used in the EmbeddedFiles name tree.
	*/
		PDFNet.FileSpec.prototype.setDesc = function(desc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDesc'. Expected "+1+" argument. Function Signature: setDesc(string)")};
		if(desc instanceof Promise) {throw new TypeError("1st input argument in function 'setDesc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof desc != "string") {throw new TypeError("1st input argument '"+desc+"' in function 'setDesc' is of type '"+(typeof desc)+"'. Expected type 'string'. Function Signature: setDesc(string).");}
		return PDFNet.messageHandler.sendWithPromise('FileSpec.setDesc', {"fs": this.id, "desc": desc}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object.
	*/
		PDFNet.FileSpec.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('FileSpec.getSDFObj', {"fs": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Flattener constructor
	*/
		PDFNet.Flattener.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('flattenerCreate', {}, this.userPriority).then(function(id){
			//there is a return type Flattener
			if(id == "0"){
				return null;
			}
			return new PDFNet.Flattener(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Flattener.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Flattener.destroy', {"flattener": this.id}, this.userPriority);
	},

	/**
	* The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to
	* render elements which cannot be directly converted.
	* the default value is 150 Dots Per Inch
	* @param dpi the resolution in Dots Per Inch
	*/
		PDFNet.Flattener.prototype.setDPI = function(dpi)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDPI'. Expected "+1+" argument. Function Signature: setDPI(number)")};
		if(dpi instanceof Promise) {throw new TypeError("1st input argument in function 'setDPI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dpi != "number") {throw new TypeError("1st input argument '"+dpi+"' in function 'setDPI' is of type '"+(typeof dpi)+"'. Expected type 'number'. Function Signature: setDPI(number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setDPI', {"flattener": this.id, "dpi": dpi}, this.userPriority);
	},

	/** Render (flatten) any text that is clipped or occluded. *//** Render text that are marginally clipped or occluded. *//** Render text that are somewhat clipped or occluded. *//** Only render text that are seriously clipped or occluded. *//** Only render text that are completely occluded, or used as a clipping path. *//** Render (flatten) any text that is clipped or occluded. *//** Render text that are marginally clipped or occluded. *//** Render text that are somewhat clipped or occluded. *//** Only render text that are seriously clipped or occluded. *//** Only render text that are completely occluded, or used as a clipping path. *//**
	* Used to control how precise or relaxed text flattening is. When some text is
	* preserved (not flattened to image) the visual appearance of the document may be altered.
	* @param threshold the threshold setting to use.
	*/
		PDFNet.Flattener.prototype.setThreshold = function(threshold)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setThreshold'. Expected "+1+" argument. Function Signature: setThreshold(number)")};
		if(threshold instanceof Promise) {throw new TypeError("1st input argument in function 'setThreshold' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof threshold != "number") {throw new TypeError("1st input argument '"+threshold+"' in function 'setThreshold' is of type '"+(typeof threshold)+"'. Expected type 'number'. Function Signature: setThreshold(number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setThreshold', {"flattener": this.id, "threshold": threshold}, this.userPriority);
	},

	/**
	* Specifies the maximum image size in pixels.
	* @param max_pixels the maximum number of pixels an image can have.
	*/
		PDFNet.Flattener.prototype.setMaximumImagePixels = function(max_pixels)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMaximumImagePixels'. Expected "+1+" argument. Function Signature: setMaximumImagePixels(number)")};
		if(max_pixels instanceof Promise) {throw new TypeError("1st input argument in function 'setMaximumImagePixels' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof max_pixels != "number") {throw new TypeError("1st input argument '"+max_pixels+"' in function 'setMaximumImagePixels' is of type '"+(typeof max_pixels)+"'. Expected type 'number'. Function Signature: setMaximumImagePixels(number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setMaximumImagePixels', {"flattener": this.id, "max_pixels": max_pixels}, this.userPriority);
	},

	/**
	* Specifies whether to leave images in existing compression, or as JPEG.
	* @param jpg if true PDF will contain all JPEG images.
	*/
		PDFNet.Flattener.prototype.setPreferJPG = function(jpg)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPreferJPG'. Expected "+1+" argument. Function Signature: setPreferJPG(boolean)")};
		if(jpg instanceof Promise) {throw new TypeError("1st input argument in function 'setPreferJPG' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof jpg != "boolean") {throw new TypeError("1st input argument '"+jpg+"' in function 'setPreferJPG' is of type '"+(typeof jpg)+"'. Expected type 'boolean'. Function Signature: setPreferJPG(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setPreferJPG', {"flattener": this.id, "jpg": jpg}, this.userPriority);
	},

	/**
	* Specifies the compression quality to use when generating JPEG images.
	* @param quality the JPEG compression quality, from 0(highest compression) to 100(best quality).
	*/
		PDFNet.Flattener.prototype.setJPGQuality = function(quality)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setJPGQuality'. Expected "+1+" argument. Function Signature: setJPGQuality(number)")};
		if(quality instanceof Promise) {throw new TypeError("1st input argument in function 'setJPGQuality' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quality != "number") {throw new TypeError("1st input argument '"+quality+"' in function 'setJPGQuality' is of type '"+(typeof quality)+"'. Expected type 'number'. Function Signature: setJPGQuality(number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setJPGQuality', {"flattener": this.id, "quality": quality}, this.userPriority);
	},

	/**
	* Enable or disable path hinting.
	*
	* @param path_hinting if true path hinting is enabled. Path hinting is used to slightly
	* adjust paths in order to avoid or alleviate artifacts of hair line cracks between
	* certain graphical elements. This option is turned on by default.
	*
	*/
		PDFNet.Flattener.prototype.setPathHinting = function(hinting)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathHinting'. Expected "+1+" argument. Function Signature: setPathHinting(boolean)")};
		if(hinting instanceof Promise) {throw new TypeError("1st input argument in function 'setPathHinting' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hinting != "boolean") {throw new TypeError("1st input argument '"+hinting+"' in function 'setPathHinting' is of type '"+(typeof hinting)+"'. Expected type 'boolean'. Function Signature: setPathHinting(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.setPathHinting', {"flattener": this.id, "hinting": hinting}, this.userPriority);
	},

	/**
	* Process each page in the PDF, flattening content that matches the mode criteria.
	* @param doc the document to flatten.
	* @param mode indicates the criteria for which elements are flattened.
	*/
		PDFNet.Flattener.prototype.process = function(doc, mode)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'process'. Expected "+2+" arguments. Function Signature: process(PDFDoc, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'process' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'process' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: process(PDFDoc, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'process' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: process(PDFDoc, number).");}
		}
		if(mode instanceof Promise) {throw new TypeError("2nd input argument in function 'process' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("2nd input argument '"+mode+"' in function 'process' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: process(PDFDoc, number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.process', {"flattener": this.id, "doc": doc.id, "mode": mode}, this.userPriority);
	},

	/**
	* Process the given page, flattening content that matches the mode criteria.
	* @param page the page to flatten.
	* @param mode indicates the criteria for which elements are flattened.
	*/
		PDFNet.Flattener.prototype.processPage = function(page, mode)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'processPage'. Expected "+2+" arguments. Function Signature: processPage(Page, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'processPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'processPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: processPage(Page, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'processPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: processPage(Page, number).");}
		}
		if(mode instanceof Promise) {throw new TypeError("2nd input argument in function 'processPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("2nd input argument '"+mode+"' in function 'processPage' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: processPage(Page, number).");}
		return PDFNet.messageHandler.sendWithPromise('Flattener.processPage', {"flattener": this.id, "page": page.id, "mode": mode}, this.userPriority);
	},

	/**
	* create a PDF::Font object from an existing SDF font object that is embedded
	* in the document. If font_dict is null, a non valid font is created.
	*/
		PDFNet.Font.createFromObj = function(font_dict)
	{
		if(typeof font_dict === "undefined") {font_dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(font_dict instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font_dict instanceof PDFNet.Obj)) {
			if(typeof font_dict == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+font_dict.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+font_dict+"' in function 'createFromObj' is of type '"+(typeof font_dict)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fontCreateFromObj', {"font_dict": font_dict.id}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

		PDFNet.Font.create = function(doc, type)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number).");}
		}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'create' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: create(SDFDoc, number).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreate', {"doc": doc.id, "type": type}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* Create a new Unicode font based on the description of an existing PDF font.
	* @note This method is experimental. For now it is only used in FieldRefresh.cpp.
	*/
		PDFNet.Font.createFromFontDescriptor = function(doc, from, char_set)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFontDescriptor'. Expected "+3+" arguments. Function Signature: createFromFontDescriptor(SDFDoc, Font, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFontDescriptor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromFontDescriptor' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromFontDescriptor(SDFDoc, Font, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromFontDescriptor' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromFontDescriptor(SDFDoc, Font, string).");}
		}
		if(from instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromFontDescriptor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(from instanceof PDFNet.Font)) {
			if(typeof from == "object") {throw new TypeError("2nd input argument in function 'createFromFontDescriptor' is of type '"+from.name+"'. Expected type 'Font'. Function Signature: createFromFontDescriptor(SDFDoc, Font, string).");}
			else {throw new TypeError("2nd input argument '"+from+"' in function 'createFromFontDescriptor' is of type '"+(typeof from)+"'. Expected type 'Font'. Function Signature: createFromFontDescriptor(SDFDoc, Font, string).");}
		}
		if(char_set instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromFontDescriptor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_set != "string") {throw new TypeError("3rd input argument '"+char_set+"' in function 'createFromFontDescriptor' is of type '"+(typeof char_set)+"'. Expected type 'string'. Function Signature: createFromFontDescriptor(SDFDoc, Font, string).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateFromFontDescriptor', {"doc": doc.id, "from": from.id, "char_set": char_set}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

		PDFNet.Font.createFromName = function(doc, name, char_set)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createFromName'. Expected "+3+" arguments. Function Signature: createFromName(SDFDoc, string, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromName' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromName(SDFDoc, string, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromName' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromName(SDFDoc, string, string).");}
		}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'createFromName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: createFromName(SDFDoc, string, string).");}
		if(char_set instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_set != "string") {throw new TypeError("3rd input argument '"+char_set+"' in function 'createFromName' is of type '"+(typeof char_set)+"'. Expected type 'string'. Function Signature: createFromName(SDFDoc, string, string).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateFromName', {"doc": doc.id, "name": name, "char_set": char_set}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

		PDFNet.Font.createAndEmbed = function(doc, type)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createAndEmbed'. Expected "+2+" arguments. Function Signature: createAndEmbed(SDFDoc, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createAndEmbed' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createAndEmbed' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createAndEmbed(SDFDoc, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createAndEmbed' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createAndEmbed(SDFDoc, number).");}
		}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'createAndEmbed' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'createAndEmbed' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: createAndEmbed(SDFDoc, number).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateAndEmbed', {"doc": doc.id, "type": type}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* Embed an external TrueType font in the document as a Simple font.
	*
	* @note glyphs in the Simple font are selected by single-byte character codes.
	* If you want to work with multi-byte character codes (e.g. UTF16) you need to
	* create a CID font.
	*
	* @param doc Document in which the external font should be embedded.
	* @param font_path Path to the external font file.
	* @param embed A boolean indicating whether the font should be embedded or
	* not. For accurate font reproduction set the embed flag to 'true'.
	* @param subset A boolean indicating whether the embedded font should
	* be subsetted.
	*/
		PDFNet.Font.createTrueTypeFont = function(doc, font_path, embed, subset)
	{
		if(typeof embed === "undefined") {embed = true;};
		if(typeof subset === "undefined") {subset = true;};
		if((arguments.length < 2) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'createTrueTypeFont'. Expected "+2+" to "+4+" arguments. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createTrueTypeFont' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createTrueTypeFont' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean).");}
		}
		if(font_path instanceof Promise) {throw new TypeError("2nd input argument in function 'createTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof font_path != "string") {throw new TypeError("2nd input argument '"+font_path+"' in function 'createTrueTypeFont' is of type '"+(typeof font_path)+"'. Expected type 'string'. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean).");}
		if(embed instanceof Promise) {throw new TypeError("3rd input argument in function 'createTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof embed != "boolean") {throw new TypeError("3rd input argument '"+embed+"' in function 'createTrueTypeFont' is of type '"+(typeof embed)+"'. Expected type 'boolean'. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean).");}
		if(subset instanceof Promise) {throw new TypeError("4th input argument in function 'createTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof subset != "boolean") {throw new TypeError("4th input argument '"+subset+"' in function 'createTrueTypeFont' is of type '"+(typeof subset)+"'. Expected type 'boolean'. Function Signature: createTrueTypeFont(SDFDoc, string, boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateTrueTypeFont', {"doc": doc.id, "font_path": font_path, "embed": embed, "subset": subset}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* Embed an external TrueType font in the document as a CID font.
	* By default the function selects "Identity-H" encoding that maps 2-byte
	* character codes ranging from 0 to 65,535 to the same Unicode value.
	* Other predefined encodings are listed in Table 5.15 'Predefined CMap names'
	* in PDF Reference Manual.
	*
	* @param doc - document in which the external font should be embedded.
	* @param font_path - path to the external font file.
	* @param embed - a boolean indicating whether the font should be embedded or
	* not. For accurate font reproduction set the embed flag to 'true'.
	* @param subset - a boolean indicating whether the embedded font should
	* be subsetted
	* @param encoding - the encoding type either e_IdentityH (default)
	* or e_Indices (to write glyph indices rather than unicode)
	* @param ttc_font_index - if a TrueTypeCollection (TTC) font is loaded this
	* parameter controls which font is actually picked
	*/
		PDFNet.Font.createCIDTrueTypeFont = function(doc, type, embed, subset, encoding, ttc_font_index)
	{
		if(typeof embed === "undefined") {embed = true;};
		if(typeof subset === "undefined") {subset = true;};
		if(typeof encoding === "undefined") {encoding = exports.PDFNet.Font.Encoding.e_IdentityH};
		if(typeof ttc_font_index === "undefined") {ttc_font_index = 0;};
		if((arguments.length < 2) || (arguments.length > 6)) {throw new RangeError(arguments.length+" arguments passed into function 'createCIDTrueTypeFont'. Expected "+2+" to "+6+" arguments. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createCIDTrueTypeFont' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "string") {throw new TypeError("2nd input argument '"+type+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof type)+"'. Expected type 'string'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		if(embed instanceof Promise) {throw new TypeError("3rd input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof embed != "boolean") {throw new TypeError("3rd input argument '"+embed+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof embed)+"'. Expected type 'boolean'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		if(subset instanceof Promise) {throw new TypeError("4th input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof subset != "boolean") {throw new TypeError("4th input argument '"+subset+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof subset)+"'. Expected type 'boolean'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		if(encoding instanceof Promise) {throw new TypeError("5th input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof encoding != "number") {throw new TypeError("5th input argument '"+encoding+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof encoding)+"'. Expected type 'number'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		if(ttc_font_index instanceof Promise) {throw new TypeError("6th input argument in function 'createCIDTrueTypeFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ttc_font_index != "number") {throw new TypeError("6th input argument '"+ttc_font_index+"' in function 'createCIDTrueTypeFont' is of type '"+(typeof ttc_font_index)+"'. Expected type 'number'. Function Signature: createCIDTrueTypeFont(SDFDoc, string, boolean, boolean, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateCIDTrueTypeFont', {"doc": doc.id, "type": type, "embed": embed, "subset": subset, "encoding": encoding, "ttc_font_index": ttc_font_index}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* Embed an external Type1 font in the document.
	*
	* @param doc - document in which the external font should be embedded.
	* @param font_path - path to the external font file.
	* @param embed - a boolean indicating whether the font should be embedded or
	* not. For accurate font reproduction set the embed flag to 'true'.
	*/
		PDFNet.Font.createType1Font = function(doc, type, embed)
	{
		if(typeof embed === "undefined") {embed = true;};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createType1Font'. Expected "+2+" to "+3+" arguments. Function Signature: createType1Font(SDFDoc, string, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createType1Font' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createType1Font' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createType1Font(SDFDoc, string, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createType1Font' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createType1Font(SDFDoc, string, boolean).");}
		}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'createType1Font' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "string") {throw new TypeError("2nd input argument '"+type+"' in function 'createType1Font' is of type '"+(typeof type)+"'. Expected type 'string'. Function Signature: createType1Font(SDFDoc, string, boolean).");}
		if(embed instanceof Promise) {throw new TypeError("3rd input argument in function 'createType1Font' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof embed != "boolean") {throw new TypeError("3rd input argument '"+embed+"' in function 'createType1Font' is of type '"+(typeof embed)+"'. Expected type 'boolean'. Function Signature: createType1Font(SDFDoc, string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('fontCreateType1Font', {"doc": doc.id, "type": type, "embed": embed}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

		PDFNet.Font.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Font)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Font)) {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Font'. Function Signature: assign(Font).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Font'. Function Signature: assign(Font).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Font.assign', {"left": this.id, "right": right.id}, this.userPriority);
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Font.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Font.destroy', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to font Type
	*/
		PDFNet.Font.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getType', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true for non-CID based fonts such as Type1, TrueType, and Type3
	*
	* All simple fonts have the following properties:<BR><BR>
	*
	* - Glyphs in the font are selected by single-byte character codes
	*   obtained from a string that is shown by the text-showing operators.
	*   Logically, these codes index into a table of 256 glyphs; the mapping
	*   from codes to glyphs is called the font's encoding. Each font program
	*   has a built-in encoding. Under some circumstances, the encoding can
	*   be altered by means described in Section 5.5.5 "Character Encoding" in
	*   PDF Reference Manual.<BR><BR>
	*
	* - Each glyph has a single set of metrics. Therefore simple fonts support
	*   only horizontal writing mode.<BR><BR>
	*/
		PDFNet.Font.prototype.isSimple = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isSimple'. Expected "+0+" arguments. Function Signature: isSimple()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isSimple', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the type of a given SDF/Cos font dictionary
	*/
		PDFNet.Font.getTypeFromObj = function(font_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTypeFromObj'. Expected "+1+" argument. Function Signature: getTypeFromObj(Obj)")};
		if(font_dict instanceof Promise) {throw new TypeError("1st input argument in function 'getTypeFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font_dict instanceof PDFNet.Obj)) {
			if(typeof font_dict == "object") {throw new TypeError("1st input argument in function 'getTypeFromObj' is of type '"+font_dict.name+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+font_dict+"' in function 'getTypeFromObj' is of type '"+(typeof font_dict)+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('fontGetTypeFromObj', {"font_dict": font_dict.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a SDF/Cos object of this Font.
	*/
		PDFNet.Font.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getSDFObj', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to a SDF/Cos object representing FontDescriptor or NULL is FontDescriptor
	* is not present.
	*/
		PDFNet.Font.prototype.getDescriptor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDescriptor'. Expected "+0+" arguments. Function Signature: getDescriptor()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getDescriptor', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the name of a font. The behavior depends on the font type;
	* for a Type 3 font it gets the value of the Name key in a PDF Font resource.
	* For other types it gets the value of the BaseFont key in a PDF font resource.
	*/
		PDFNet.Font.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getName', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the face's family name. This is an ASCII string, usually in English,
	* which describes the typeface's family (like 'Times New Roman', 'Bodoni', 'Garamond',
	* etc). This is a least common denominator used to list fonts.
	*/
		PDFNet.Font.prototype.getFamilyName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFamilyName'. Expected "+0+" arguments. Function Signature: getFamilyName()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getFamilyName', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if all glyphs have the same width
	*/
		PDFNet.Font.prototype.isFixedWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isFixedWidth'. Expected "+0+" arguments. Function Signature: isFixedWidth()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isFixedWidth', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if glyphs have serifs
	*/
		PDFNet.Font.prototype.isSerif = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isSerif'. Expected "+0+" arguments. Function Signature: isSerif()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isSerif', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if font contains characters outside the Adobe standard Latin character set.
	*/
		PDFNet.Font.prototype.isSymbolic = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isSymbolic'. Expected "+0+" arguments. Function Signature: isSymbolic()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isSymbolic', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if glyphs have dominant vertical strokes that are slanted.
	*/
		PDFNet.Font.prototype.isItalic = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isItalic'. Expected "+0+" arguments. Function Signature: isItalic()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isItalic', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if font contains no lowercase letters
	*/
		PDFNet.Font.prototype.isAllCap = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isAllCap'. Expected "+0+" arguments. Function Signature: isAllCap()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isAllCap', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if bold glyphs should be painted with extra pixels at very small text sizes.
	*/
		PDFNet.Font.prototype.isForceBold = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isForceBold'. Expected "+0+" arguments. Function Signature: isForceBold()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isForceBold', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the font uses horizontal writing mode, false for vertical writing mode.
	*/
		PDFNet.Font.prototype.isHorizontalMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isHorizontalMode'. Expected "+0+" arguments. Function Signature: isHorizontalMode()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isHorizontalMode', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to advance width, measured in glyph space units for the glyph
	* matching given character code.
	*
	* @note 1000 glyph units = 1 text space unit
	* @note The width returned has NOT been scaled by the font size, text matrix,
	*		 nor the CTM.
	*
	* The function gets the advance width of the font glyph. The advance width
	* is the amount by which the current point advances when the glyph is drawn.
	* The advance width may not correspond to the visible width of the glyph
	* and for this reason, the advance width cannot be used to determine the glyphs'
	* bounding boxes.
	*/
		PDFNet.Font.prototype.getWidth = function(char_code)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getWidth'. Expected "+1+" argument. Function Signature: getWidth(number)")};
		if(char_code instanceof Promise) {throw new TypeError("1st input argument in function 'getWidth' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_code != "number") {throw new TypeError("1st input argument '"+char_code+"' in function 'getWidth' is of type '"+(typeof char_code)+"'. Expected type 'number'. Function Signature: getWidth(number).");}
		return PDFNet.messageHandler.sendWithPromise('Font.getWidth', {"font": this.id, "char_code": char_code}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the maximal advance width, in font units, for all glyphs in this face.
	*/
		PDFNet.Font.prototype.getMaxWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMaxWidth'. Expected "+0+" arguments. Function Signature: getMaxWidth()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getMaxWidth', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the default width to use for character codes whose widths are
	* not specified in a font dictionary's Widths array.
	*/
		PDFNet.Font.prototype.getMissingWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMissingWidth'. Expected "+0+" arguments. Function Signature: getMissingWidth()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getMissingWidth', {"font": this.id}, this.userPriority);
	},

	/**
	* GetCharCodeIterator represents an iterator interface used to traverse
	* a list of char codes for which there is a glyph outline in the embedded font.
	*/
		PDFNet.Font.prototype.getCharCodeIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCharCodeIterator'. Expected "+0+" arguments. Function Signature: getCharCodeIterator()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getCharCodeIterator', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* @return A promise that resolves to the font's encoding array (the mapping of character codes to glyphs).
	* The array contains 256 pointers. If a pointer is not NULL, it points to a
	* C string containing the name of the glyph for the code point corresponding
	* to the index. If it is NULL, then the name of the glyph is unchanged from
	* that specified by the font's built-in encoding.
	*
	* For a Type 3 font, all glyph names will be present in the encoding array,
	* and NULL entries correspond to un-encoded code points.
	*
	* @note The Font object is the owner of the array.
	* @note This function is not applicable to composite fonts (e_type0, e_CIDType0,
	* and e_CIDType2) and will throw an exception.
	*/
		PDFNet.Font.prototype.getEncoding = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEncoding'. Expected "+0+" arguments. Function Signature: getEncoding()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getEncoding', {"font": this.id}, this.userPriority);
	},

	/**
	* Tests whether or not the specified font is stored as a font file in a stream
	* embedded in the PDF file.
	*
	* @return A promise that resolves to true if the font is embedded in the file, false otherwise.
	*/
		PDFNet.Font.prototype.isEmbedded = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isEmbedded'. Expected "+0+" arguments. Function Signature: isEmbedded()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isEmbedded', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the PostScript font name for the embedded font. If the embedded font
	* name is not available the function returns the empty string .
	*/
		PDFNet.Font.prototype.getEmbeddedFontName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEmbeddedFontName'. Expected "+0+" arguments. Function Signature: getEmbeddedFontName()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getEmbeddedFontName', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the stream object of the embedded font or NULL if there if the
	* font is not embedded.
	* @note This function is not applicable to Type3 font and will throw exception.
	*/
		PDFNet.Font.prototype.getEmbeddedFont = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEmbeddedFont'. Expected "+0+" arguments. Function Signature: getEmbeddedFont()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getEmbeddedFont', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the size of decoded buffer containing embedded font data or 0
	* if this information is not known in advance.
	*
	* @note The size of decoded buffer may not be known in advance for all
	* fonts and may not be correct.
	* @note This function is not applicable to Type3 font and will throw exception.
	*/
		PDFNet.Font.prototype.getEmbeddedFontBufSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEmbeddedFontBufSize'. Expected "+0+" arguments. Function Signature: getEmbeddedFontBufSize()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getEmbeddedFontBufSize', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of font units per EM square for this face. This is
	* typically 2048 for TrueType fonts, 1000 for Type1 fonts
	*
	* @note Only relevant for scalable formats (such as TrueType and Type1).
	*
	* @note This function is not applicable to Type3 font and will throw an exception.
	* Use GetType3FontMatrix instead.
	*/
		PDFNet.Font.prototype.getUnitsPerEm = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getUnitsPerEm'. Expected "+0+" arguments. Function Signature: getUnitsPerEm()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getUnitsPerEm', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a rectangle expressed in the glyph coordinate system, specifying the
	* font bounding box. This is the smallest rectangle enclosing the shape that would
	* result if all of the glyphs of the font were placed with their origins coincident
	* and then filled.
	*/
		PDFNet.Font.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getBBox', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* The face's ascender is the vertical distance from the baseline to the topmost
	* point of any glyph in the face. This field's value is a positive number, expressed
	* in the glyph coordinate system. For all font types except Type 3, the units of
	* glyph space are one-thousandth of a unit of text space. Some font designs use
	* a value different from 'bbox.yMax'.
	*
	* @note Only relevant for scalable formats.
	*/
		PDFNet.Font.prototype.getAscent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAscent'. Expected "+0+" arguments. Function Signature: getAscent()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getAscent', {"font": this.id}, this.userPriority);
	},

	/**
	* The face's descender is the vertical distance from the baseline to the bottommost
	* point of any glyph in the face. This field's value is a negative number expressed
	* in the glyph coordinate system. For all font types except Type 3, the units of
	* glyph space are one-thousandth of a unit of text space. Some font designs use
	* a value different from 'bbox.yMin'.
	*
	* @note Only relevant for scalable formats.
	*/
		PDFNet.Font.prototype.getDescent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDescent'. Expected "+0+" arguments. Function Signature: getDescent()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getDescent', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to font::e_null if the font is not a standard Type1 font or some
	* other StandardType1Font value for a standard Type1 font.
	*/
		PDFNet.Font.prototype.getStandardType1FontType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStandardType1FontType'. Expected "+0+" arguments. Function Signature: getStandardType1FontType()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getStandardType1FontType', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the embedded font is represented as CFF (Compact Font Format).
	* @note Only Type1 and Type1C fonts can be represented in CFF format
	*/
		PDFNet.Font.prototype.isCFF = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isCFF'. Expected "+0+" arguments. Function Signature: isCFF()")};
		return PDFNet.messageHandler.sendWithPromise('Font.isCFF', {"font": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to type3 font matrix, mapping glyph space to text space
	* A common practice is to define glyphs in terms of a 1000-unit
	* glyph coordinate system, in which case the font matrix is [0.001 0 0 0.001 0 0].
	*
	* @note Relevant only for a Type3 font.
	*/
		PDFNet.Font.prototype.getType3FontMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType3FontMatrix'. Expected "+0+" arguments. Function Signature: getType3FontMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getType3FontMatrix', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to a SDF/Cos glyph stream for the given char_code.
	* If specified char_code is not found in the CharProcs dictionary the
	* function returns NULL.
	*
	* @note Relevant only for a Type3 font.
	*/
		PDFNet.Font.prototype.getType3GlyphStream = function(char_code)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getType3GlyphStream'. Expected "+1+" argument. Function Signature: getType3GlyphStream(number)")};
		if(char_code instanceof Promise) {throw new TypeError("1st input argument in function 'getType3GlyphStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_code != "number") {throw new TypeError("1st input argument '"+char_code+"' in function 'getType3GlyphStream' is of type '"+(typeof char_code)+"'. Expected type 'number'. Function Signature: getType3GlyphStream(number).");}
		return PDFNet.messageHandler.sendWithPromise('Font.getType3GlyphStream', {"font": this.id, "char_code": char_code}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.Font.prototype.getVerticalAdvance = function(char_code)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getVerticalAdvance'. Expected "+1+" argument. Function Signature: getVerticalAdvance(number)")};
		if(char_code instanceof Promise) {throw new TypeError("1st input argument in function 'getVerticalAdvance' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_code != "number") {throw new TypeError("1st input argument '"+char_code+"' in function 'getVerticalAdvance' is of type '"+(typeof char_code)+"'. Expected type 'number'. Function Signature: getVerticalAdvance(number).");}
		return PDFNet.messageHandler.sendWithPromise('Font.getVerticalAdvance', {"font": this.id, "char_code": char_code}, this.userPriority);
	},

	/**
	* @return A promise that resolves to descendant CIDFont.
	*
	* @note Relevant only for a Type0 font.
	*/
		PDFNet.Font.prototype.getDescendant = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDescendant'. Expected "+0+" arguments. Function Signature: getDescendant()")};
		return PDFNet.messageHandler.sendWithPromise('Font.getDescendant', {"font": this.id}, this.userPriority).then(function(id){
			//there is a return type Font
			if(id == "0"){
				return null;
			}
			return new PDFNet.Font(id);
		});
	},

	/**
	* @return A promise that resolves to a CID matching specified charcode.
	*
	* @note Relevant only for a Type0 font.
	*/
		PDFNet.Font.prototype.mapToCID = function(char_code)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'mapToCID'. Expected "+1+" argument. Function Signature: mapToCID(number)")};
		if(char_code instanceof Promise) {throw new TypeError("1st input argument in function 'mapToCID' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_code != "number") {throw new TypeError("1st input argument '"+char_code+"' in function 'mapToCID' is of type '"+(typeof char_code)+"'. Expected type 'number'. Function Signature: mapToCID(number).");}
		return PDFNet.messageHandler.sendWithPromise('Font.mapToCID', {"font": this.id, "char_code": char_code}, this.userPriority);
	},

	/**
	* The function maps charcode (out_charcode) from char_data buffer to a CID (out_cid) and
	* return the number of bytes representing the CID in the buffer.
	*
	* @param char_data the input data buffer containing one or more bytes of input charcode
	* @param char_data_avail the number of bytes in the char_data buffer
	* @param out_charcode the first charcode in char_data buffer.
	* @param out_cid CID corresponding to the out_charcode parsed from char_data buffer.
	*
	* @return A promise that resolves to the number of bytes consumed by out_cid. This number must be less than or equal to
	* char_data_avail
	*
	* @note Relevant only for a Type0 font.
	*/
		PDFNet.Font.prototype.mapToCID2 = function(char_data, char_data_avail)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'mapToCID2'. Expected "+2+" arguments. Function Signature: mapToCID2(number, number)")};
		if(char_data instanceof Promise) {throw new TypeError("1st input argument in function 'mapToCID2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_data != "number") {throw new TypeError("1st input argument '"+char_data+"' in function 'mapToCID2' is of type '"+(typeof char_data)+"'. Expected type 'number'. Function Signature: mapToCID2(number, number).");}
		if(char_data_avail instanceof Promise) {throw new TypeError("2nd input argument in function 'mapToCID2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_data_avail != "number") {throw new TypeError("2nd input argument '"+char_data_avail+"' in function 'mapToCID2' is of type '"+(typeof char_data_avail)+"'. Expected type 'number'. Function Signature: mapToCID2(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Font.mapToCID2', {"font": this.id, "char_data": char_data, "char_data_avail": char_data_avail}, this.userPriority);
	},

	/**
	* create a PDF::Function object from an existing SDF function dictionary. If funct_dict
	* is null, a non valid Function object is created.
	*/
		PDFNet.Function.create = function(funct_dict)
	{
		if(typeof funct_dict === "undefined") {funct_dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(funct_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(funct_dict instanceof PDFNet.Obj)) {
			if(typeof funct_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+funct_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+funct_dict+"' in function 'create' is of type '"+(typeof funct_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('functionCreate', {"funct_dict": funct_dict.id}, this.userPriority).then(function(id){
			//there is a return type Function
			if(id == "0"){
				return null;
			}
			return new PDFNet.Function(id);
		});
	},

		PDFNet.Function.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Function)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Function)) {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Function'. Function Signature: assign(Function).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Function'. Function Signature: assign(Function).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Function.assign', {"left": this.id, "right": right.id}, this.userPriority);
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Function.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Function.destroy', {"f": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the function type
	*/
		PDFNet.Function.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Function.getType', {"f": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of input components required by the function
	*/
		PDFNet.Function.prototype.getInputCardinality = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getInputCardinality'. Expected "+0+" arguments. Function Signature: getInputCardinality()")};
		return PDFNet.messageHandler.sendWithPromise('Function.getInputCardinality', {"f": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of output components returned by the function
	*/
		PDFNet.Function.prototype.getOutputCardinality = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOutputCardinality'. Expected "+0+" arguments. Function Signature: getOutputCardinality()")};
		return PDFNet.messageHandler.sendWithPromise('Function.getOutputCardinality', {"f": this.id}, this.userPriority);
	},

		PDFNet.Function.prototype.eval = function(inval, outval)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'eval'. Expected "+2+" arguments. Function Signature: eval(number, number)")};
		if(inval instanceof Promise) {throw new TypeError("1st input argument in function 'eval' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof inval != "number") {throw new TypeError("1st input argument '"+inval+"' in function 'eval' is of type '"+(typeof inval)+"'. Expected type 'number'. Function Signature: eval(number, number).");}
		if(outval instanceof Promise) {throw new TypeError("2nd input argument in function 'eval' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof outval != "number") {throw new TypeError("2nd input argument '"+outval+"' in function 'eval' is of type '"+(typeof outval)+"'. Expected type 'number'. Function Signature: eval(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Function.eval', {"f": this.id, "inval": inval, "outval": outval}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object
	*/
		PDFNet.Function.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Function.getSDFObj', {"f": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Constructor and destructor.
	*/
		PDFNet.Highlights.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('highlightsCreate', {}, this.userPriority).then(function(id){
			//there is a return type Highlights
			if(id == "0"){
				return null;
			}
			return new PDFNet.Highlights(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Highlights.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.destroy', {"hlts": this.id}, this.userPriority);
	},

		PDFNet.Highlights.prototype.copyCtor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copyCtor'. Expected "+0+" arguments. Function Signature: copyCtor()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.copyCtor', {"hlts": this.id}, this.userPriority).then(function(id){
			//there is a return type Highlights
			if(id == "0"){
				return null;
			}
			return new PDFNet.Highlights(id);
		});
	},

		PDFNet.Highlights.prototype.assign = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+0+" arguments. Function Signature: assign()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.assign', {"hlts": this.id}, this.userPriority).then(function(id){
			//there is a return type Highlights
			if(id == "0"){
				return null;
			}
			return new PDFNet.Highlights(id);
		});
	},

	/**
	* Add highlights.
	*
	* @param hlts the Highlights instance containing the highlights to be added.
	*/
		PDFNet.Highlights.prototype.add = function(hlt2)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'add'. Expected "+1+" argument. Function Signature: add(Highlights)")};
		if(hlt2 instanceof Promise) {throw new TypeError("1st input argument in function 'add' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(hlt2 instanceof PDFNet.Highlights)) {
			if(typeof hlt2 == "object") {throw new TypeError("1st input argument in function 'add' is of type '"+hlt2.name+"'. Expected type 'Highlights'. Function Signature: add(Highlights).");}
			else {throw new TypeError("1st input argument '"+hlt2+"' in function 'add' is of type '"+(typeof hlt2)+"'. Expected type 'Highlights'. Function Signature: add(Highlights).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Highlights.add', {"hlts": this.id, "hlt2": hlt2.id}, this.userPriority);
	},

	/**
	* Load the Highlight information from a file. Note that the
	* pre-existing Highlight information is discarded.
	*
	* @param file_name the name of the file to load from.
	*/
		PDFNet.Highlights.prototype.load = function(file_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'load'. Expected "+1+" argument. Function Signature: load(string)")};
		if(file_name instanceof Promise) {throw new TypeError("1st input argument in function 'load' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_name != "string") {throw new TypeError("1st input argument '"+file_name+"' in function 'load' is of type '"+(typeof file_name)+"'. Expected type 'string'. Function Signature: load(string).");}
		return PDFNet.messageHandler.sendWithPromise('Highlights.load', {"hlts": this.id, "file_name": file_name}, this.userPriority);
	},

	/**
	* Save the current Highlight information in the class to a file.
	*
	* @param file_name the name of the file to save to.
	*/
		PDFNet.Highlights.prototype.save = function(file_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'save'. Expected "+1+" argument. Function Signature: save(string)")};
		if(file_name instanceof Promise) {throw new TypeError("1st input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_name != "string") {throw new TypeError("1st input argument '"+file_name+"' in function 'save' is of type '"+(typeof file_name)+"'. Expected type 'string'. Function Signature: save(string).");}
		return PDFNet.messageHandler.sendWithPromise('Highlights.save', {"hlts": this.id, "file_name": file_name}, this.userPriority);
	},

	/**
	* Clear the current Highlight information in the class.
	*/
		PDFNet.Highlights.prototype.clear = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'clear'. Expected "+0+" arguments. Function Signature: clear()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.clear', {"hlts": this.id}, this.userPriority);
	},

	/**
	* Rewind the internal pointer to the first highlight.
	*
	* @param doc the PDF document to which the highlights correspond.
	*
	* @note the PDF document can be a dummy document unless GetCurrentQuads()
	* is to be called.
	*/
		PDFNet.Highlights.prototype.begin = function(doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+1+" argument. Function Signature: begin(PDFDoc)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'begin' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: begin(PDFDoc).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'begin' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: begin(PDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Highlights.begin', {"hlts": this.id, "doc": doc.id}, this.userPriority);
	},

	/**
	* Query if there is any subsequent highlight after the current highlight.
	*/
		PDFNet.Highlights.prototype.hasNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasNext'. Expected "+0+" arguments. Function Signature: hasNext()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.hasNext', {"hlts": this.id}, this.userPriority);
	},

	/**
	* Move the current highlight to the next highlight.
	*/
		PDFNet.Highlights.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.next', {"hlts": this.id}, this.userPriority);
	},

	/**
	* Get the page number of the current highlight.
	*/
		PDFNet.Highlights.prototype.getCurrentPageNumber = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentPageNumber'. Expected "+0+" arguments. Function Signature: getCurrentPageNumber()")};
		return PDFNet.messageHandler.sendWithPromise('Highlights.getCurrentPageNumber', {"hlts": this.id}, this.userPriority);
	},

		PDFNet.Highlights.prototype.getCurrentQuads = function(quads)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentQuads'. Expected "+1+" argument. Function Signature: getCurrentQuads(number)")};
		if(quads instanceof Promise) {throw new TypeError("1st input argument in function 'getCurrentQuads' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quads != "number") {throw new TypeError("1st input argument '"+quads+"' in function 'getCurrentQuads' is of type '"+(typeof quads)+"'. Expected type 'number'. Function Signature: getCurrentQuads(number).");}
		return PDFNet.messageHandler.sendWithPromise('Highlights.getCurrentQuads', {"hlts": this.id, "quads": quads}, this.userPriority);
	},

	/**
	* Default constructor.
	*/
		PDFNet.HTML2PDF_Proxy.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('htmL2PDF_ProxyCreate', {}, this.userPriority).then(function(id){
			//there is a return type HTML2PDF_Proxy
			if(id == "0"){
				return null;
			}
			return new PDFNet.HTML2PDF_Proxy(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.HTML2PDF_Proxy.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.destroy', {"proxy": this.id}, this.userPriority);
	},

		PDFNet.HTML2PDF_Proxy.prototype.setType = function(type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setType'. Expected "+1+" argument. Function Signature: setType(number)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'setType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'setType' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: setType(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.setType', {"proxy": this.id, "type": type}, this.userPriority);
	},

		PDFNet.HTML2PDF_Proxy.prototype.setPort = function(port)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPort'. Expected "+1+" argument. Function Signature: setPort(number)")};
		if(port instanceof Promise) {throw new TypeError("1st input argument in function 'setPort' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof port != "number") {throw new TypeError("1st input argument '"+port+"' in function 'setPort' is of type '"+(typeof port)+"'. Expected type 'number'. Function Signature: setPort(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.setPort', {"proxy": this.id, "port": port}, this.userPriority);
	},

		PDFNet.HTML2PDF_Proxy.prototype.setHost = function(host)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHost'. Expected "+1+" argument. Function Signature: setHost(string)")};
		if(host instanceof Promise) {throw new TypeError("1st input argument in function 'setHost' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof host != "string") {throw new TypeError("1st input argument '"+host+"' in function 'setHost' is of type '"+(typeof host)+"'. Expected type 'string'. Function Signature: setHost(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.setHost', {"proxy": this.id, "host": host}, this.userPriority);
	},

		PDFNet.HTML2PDF_Proxy.prototype.setUsername = function(username)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUsername'. Expected "+1+" argument. Function Signature: setUsername(string)")};
		if(username instanceof Promise) {throw new TypeError("1st input argument in function 'setUsername' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof username != "string") {throw new TypeError("1st input argument '"+username+"' in function 'setUsername' is of type '"+(typeof username)+"'. Expected type 'string'. Function Signature: setUsername(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.setUsername', {"proxy": this.id, "username": username}, this.userPriority);
	},

		PDFNet.HTML2PDF_Proxy.prototype.setPassword = function(password)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPassword'. Expected "+1+" argument. Function Signature: setPassword(string)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'setPassword' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'setPassword' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: setPassword(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_Proxy.setPassword', {"proxy": this.id, "password": password}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('htmL2PDF_WebPageSettingsCreate', {}, this.userPriority).then(function(id){
			//there is a return type HTML2PDF_WebPageSettings
			if(id == "0"){
				return null;
			}
			return new PDFNet.HTML2PDF_WebPageSettings(id);
		});
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.destroy', {"settings": this.id}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setPrintBackground = function(background)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintBackground'. Expected "+1+" argument. Function Signature: setPrintBackground(boolean)")};
		if(background instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintBackground' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof background != "boolean") {throw new TypeError("1st input argument '"+background+"' in function 'setPrintBackground' is of type '"+(typeof background)+"'. Expected type 'boolean'. Function Signature: setPrintBackground(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setPrintBackground', {"settings": this.id, "background": background}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setLoadImages = function(load)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLoadImages'. Expected "+1+" argument. Function Signature: setLoadImages(boolean)")};
		if(load instanceof Promise) {throw new TypeError("1st input argument in function 'setLoadImages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof load != "boolean") {throw new TypeError("1st input argument '"+load+"' in function 'setLoadImages' is of type '"+(typeof load)+"'. Expected type 'boolean'. Function Signature: setLoadImages(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setLoadImages', {"settings": this.id, "load": load}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setAllowJavaScript = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAllowJavaScript'. Expected "+1+" argument. Function Signature: setAllowJavaScript(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setAllowJavaScript' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setAllowJavaScript' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setAllowJavaScript(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setAllowJavaScript', {"settings": this.id, "enable": enable}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setSmartShrinking = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSmartShrinking'. Expected "+1+" argument. Function Signature: setSmartShrinking(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setSmartShrinking' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setSmartShrinking' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setSmartShrinking(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setSmartShrinking', {"settings": this.id, "enable": enable}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setMinimumFontSize = function(size)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMinimumFontSize'. Expected "+1+" argument. Function Signature: setMinimumFontSize(number)")};
		if(size instanceof Promise) {throw new TypeError("1st input argument in function 'setMinimumFontSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("1st input argument '"+size+"' in function 'setMinimumFontSize' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: setMinimumFontSize(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setMinimumFontSize', {"settings": this.id, "size": size}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setDefaultEncoding = function(encoding)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultEncoding'. Expected "+1+" argument. Function Signature: setDefaultEncoding(string)")};
		if(encoding instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultEncoding' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof encoding != "string") {throw new TypeError("1st input argument '"+encoding+"' in function 'setDefaultEncoding' is of type '"+(typeof encoding)+"'. Expected type 'string'. Function Signature: setDefaultEncoding(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setDefaultEncoding', {"settings": this.id, "encoding": encoding}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setUserStyleSheet = function(url)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUserStyleSheet'. Expected "+1+" argument. Function Signature: setUserStyleSheet(string)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'setUserStyleSheet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("1st input argument '"+url+"' in function 'setUserStyleSheet' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: setUserStyleSheet(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setUserStyleSheet', {"settings": this.id, "url": url}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setAllowPlugins = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAllowPlugins'. Expected "+1+" argument. Function Signature: setAllowPlugins(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setAllowPlugins' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setAllowPlugins' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setAllowPlugins(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setAllowPlugins', {"settings": this.id, "enable": enable}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setPrintMediaType = function(print)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintMediaType'. Expected "+1+" argument. Function Signature: setPrintMediaType(boolean)")};
		if(print instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintMediaType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof print != "boolean") {throw new TypeError("1st input argument '"+print+"' in function 'setPrintMediaType' is of type '"+(typeof print)+"'. Expected type 'boolean'. Function Signature: setPrintMediaType(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setPrintMediaType', {"settings": this.id, "print": print}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setIncludeInOutline = function(include)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setIncludeInOutline'. Expected "+1+" argument. Function Signature: setIncludeInOutline(boolean)")};
		if(include instanceof Promise) {throw new TypeError("1st input argument in function 'setIncludeInOutline' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof include != "boolean") {throw new TypeError("1st input argument '"+include+"' in function 'setIncludeInOutline' is of type '"+(typeof include)+"'. Expected type 'boolean'. Function Signature: setIncludeInOutline(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setIncludeInOutline', {"settings": this.id, "include": include}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setUsername = function(username)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUsername'. Expected "+1+" argument. Function Signature: setUsername(string)")};
		if(username instanceof Promise) {throw new TypeError("1st input argument in function 'setUsername' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof username != "string") {throw new TypeError("1st input argument '"+username+"' in function 'setUsername' is of type '"+(typeof username)+"'. Expected type 'string'. Function Signature: setUsername(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setUsername', {"settings": this.id, "username": username}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setPassword = function(password)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPassword'. Expected "+1+" argument. Function Signature: setPassword(string)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'setPassword' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'setPassword' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: setPassword(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setPassword', {"settings": this.id, "password": password}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setJavaScriptDelay = function(msec)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setJavaScriptDelay'. Expected "+1+" argument. Function Signature: setJavaScriptDelay(number)")};
		if(msec instanceof Promise) {throw new TypeError("1st input argument in function 'setJavaScriptDelay' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof msec != "number") {throw new TypeError("1st input argument '"+msec+"' in function 'setJavaScriptDelay' is of type '"+(typeof msec)+"'. Expected type 'number'. Function Signature: setJavaScriptDelay(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setJavaScriptDelay', {"settings": this.id, "msec": msec}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setZoom = function(zoom)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setZoom'. Expected "+1+" argument. Function Signature: setZoom(number)")};
		if(zoom instanceof Promise) {throw new TypeError("1st input argument in function 'setZoom' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof zoom != "number") {throw new TypeError("1st input argument '"+zoom+"' in function 'setZoom' is of type '"+(typeof zoom)+"'. Expected type 'number'. Function Signature: setZoom(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setZoom', {"settings": this.id, "zoom": zoom}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setBlockLocalFileAccess = function(block)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBlockLocalFileAccess'. Expected "+1+" argument. Function Signature: setBlockLocalFileAccess(boolean)")};
		if(block instanceof Promise) {throw new TypeError("1st input argument in function 'setBlockLocalFileAccess' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof block != "boolean") {throw new TypeError("1st input argument '"+block+"' in function 'setBlockLocalFileAccess' is of type '"+(typeof block)+"'. Expected type 'boolean'. Function Signature: setBlockLocalFileAccess(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setBlockLocalFileAccess', {"settings": this.id, "block": block}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setStopSlowScripts = function(stop)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStopSlowScripts'. Expected "+1+" argument. Function Signature: setStopSlowScripts(boolean)")};
		if(stop instanceof Promise) {throw new TypeError("1st input argument in function 'setStopSlowScripts' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof stop != "boolean") {throw new TypeError("1st input argument '"+stop+"' in function 'setStopSlowScripts' is of type '"+(typeof stop)+"'. Expected type 'boolean'. Function Signature: setStopSlowScripts(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setStopSlowScripts', {"settings": this.id, "stop": stop}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setDebugJavaScriptOutput = function(forward)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDebugJavaScriptOutput'. Expected "+1+" argument. Function Signature: setDebugJavaScriptOutput(boolean)")};
		if(forward instanceof Promise) {throw new TypeError("1st input argument in function 'setDebugJavaScriptOutput' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof forward != "boolean") {throw new TypeError("1st input argument '"+forward+"' in function 'setDebugJavaScriptOutput' is of type '"+(typeof forward)+"'. Expected type 'boolean'. Function Signature: setDebugJavaScriptOutput(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setDebugJavaScriptOutput', {"settings": this.id, "forward": forward}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setLoadErrorHandling = function(val)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLoadErrorHandling'. Expected "+1+" argument. Function Signature: setLoadErrorHandling(number)")};
		if(val instanceof Promise) {throw new TypeError("1st input argument in function 'setLoadErrorHandling' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof val != "number") {throw new TypeError("1st input argument '"+val+"' in function 'setLoadErrorHandling' is of type '"+(typeof val)+"'. Expected type 'number'. Function Signature: setLoadErrorHandling(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setLoadErrorHandling', {"settings": this.id, "val": val}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setExternalLinks = function(convert)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setExternalLinks'. Expected "+1+" argument. Function Signature: setExternalLinks(boolean)")};
		if(convert instanceof Promise) {throw new TypeError("1st input argument in function 'setExternalLinks' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof convert != "boolean") {throw new TypeError("1st input argument '"+convert+"' in function 'setExternalLinks' is of type '"+(typeof convert)+"'. Expected type 'boolean'. Function Signature: setExternalLinks(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setExternalLinks', {"settings": this.id, "convert": convert}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setInternalLinks = function(convert)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInternalLinks'. Expected "+1+" argument. Function Signature: setInternalLinks(boolean)")};
		if(convert instanceof Promise) {throw new TypeError("1st input argument in function 'setInternalLinks' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof convert != "boolean") {throw new TypeError("1st input argument '"+convert+"' in function 'setInternalLinks' is of type '"+(typeof convert)+"'. Expected type 'boolean'. Function Signature: setInternalLinks(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setInternalLinks', {"settings": this.id, "convert": convert}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.setProduceForms = function(forms)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setProduceForms'. Expected "+1+" argument. Function Signature: setProduceForms(boolean)")};
		if(forms instanceof Promise) {throw new TypeError("1st input argument in function 'setProduceForms' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof forms != "boolean") {throw new TypeError("1st input argument '"+forms+"' in function 'setProduceForms' is of type '"+(typeof forms)+"'. Expected type 'boolean'. Function Signature: setProduceForms(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.setProduceForms', {"settings": this.id, "forms": forms}, this.userPriority);
	},

		PDFNet.HTML2PDF_WebPageSettings.prototype.SetProxy = function(proxy)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'SetProxy'. Expected "+1+" argument. Function Signature: SetProxy(HTML2PDF_Proxy)")};
		if(proxy instanceof Promise) {throw new TypeError("1st input argument in function 'SetProxy' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(proxy instanceof PDFNet.HTML2PDF_Proxy)) {
			if(typeof proxy == "object") {throw new TypeError("1st input argument in function 'SetProxy' is of type '"+proxy.name+"'. Expected type 'HTML2PDF_Proxy'. Function Signature: SetProxy(HTML2PDF_Proxy).");}
			else {throw new TypeError("1st input argument '"+proxy+"' in function 'SetProxy' is of type '"+(typeof proxy)+"'. Expected type 'HTML2PDF_Proxy'. Function Signature: SetProxy(HTML2PDF_Proxy).");}
		}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_WebPageSettings.SetProxy', {"settings": this.id, "proxy": proxy.id}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('htmL2PDF_TOCSettingsCreate', {}, this.userPriority).then(function(id){
			//there is a return type HTML2PDF_TOCSettings
			if(id == "0"){
				return null;
			}
			return new PDFNet.HTML2PDF_TOCSettings(id);
		});
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.destroy', {"settings": this.id}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setDottedLines = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDottedLines'. Expected "+1+" argument. Function Signature: setDottedLines(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setDottedLines' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setDottedLines' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setDottedLines(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setDottedLines', {"settings": this.id, "enable": enable}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setLinks = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLinks'. Expected "+1+" argument. Function Signature: setLinks(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setLinks' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setLinks' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setLinks(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setLinks', {"settings": this.id, "enable": enable}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setCaptionText = function(caption)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCaptionText'. Expected "+1+" argument. Function Signature: setCaptionText(string)")};
		if(caption instanceof Promise) {throw new TypeError("1st input argument in function 'setCaptionText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof caption != "string") {throw new TypeError("1st input argument '"+caption+"' in function 'setCaptionText' is of type '"+(typeof caption)+"'. Expected type 'string'. Function Signature: setCaptionText(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setCaptionText', {"settings": this.id, "caption": caption}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setLevelIndentation = function(indentation)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLevelIndentation'. Expected "+1+" argument. Function Signature: setLevelIndentation(number)")};
		if(indentation instanceof Promise) {throw new TypeError("1st input argument in function 'setLevelIndentation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof indentation != "number") {throw new TypeError("1st input argument '"+indentation+"' in function 'setLevelIndentation' is of type '"+(typeof indentation)+"'. Expected type 'number'. Function Signature: setLevelIndentation(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setLevelIndentation', {"settings": this.id, "indentation": indentation}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setTextSizeShrink = function(shrink)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextSizeShrink'. Expected "+1+" argument. Function Signature: setTextSizeShrink(number)")};
		if(shrink instanceof Promise) {throw new TypeError("1st input argument in function 'setTextSizeShrink' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof shrink != "number") {throw new TypeError("1st input argument '"+shrink+"' in function 'setTextSizeShrink' is of type '"+(typeof shrink)+"'. Expected type 'number'. Function Signature: setTextSizeShrink(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setTextSizeShrink', {"settings": this.id, "shrink": shrink}, this.userPriority);
	},

		PDFNet.HTML2PDF_TOCSettings.prototype.setXsl = function(style_sheet)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setXsl'. Expected "+1+" argument. Function Signature: setXsl(string)")};
		if(style_sheet instanceof Promise) {throw new TypeError("1st input argument in function 'setXsl' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style_sheet != "string") {throw new TypeError("1st input argument '"+style_sheet+"' in function 'setXsl' is of type '"+(typeof style_sheet)+"'. Expected type 'string'. Function Signature: setXsl(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF_TOCSettings.setXsl', {"settings": this.id, "style_sheet": style_sheet}, this.userPriority);
	},

		PDFNet.HTML2PDF.staticConvert = function(doc, url)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'staticConvert'. Expected "+2+" arguments. Function Signature: staticConvert(PDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'staticConvert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'staticConvert' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: staticConvert(PDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'staticConvert' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: staticConvert(PDFDoc, string).");}
		}
		if(url instanceof Promise) {throw new TypeError("2nd input argument in function 'staticConvert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("2nd input argument '"+url+"' in function 'staticConvert' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: staticConvert(PDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('htmL2PDFStaticConvert', {"doc": doc.id, "url": url}, this.userPriority);
	},

		PDFNet.HTML2PDF.staticConvert2 = function(doc, url, settings)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'staticConvert2'. Expected "+3+" arguments. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'staticConvert2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'staticConvert2' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'staticConvert2' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings).");}
		}
		if(url instanceof Promise) {throw new TypeError("2nd input argument in function 'staticConvert2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("2nd input argument '"+url+"' in function 'staticConvert2' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings).");}
		if(settings instanceof Promise) {throw new TypeError("3rd input argument in function 'staticConvert2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(settings instanceof PDFNet.HTML2PDF_WebPageSettings)) {
			if(typeof settings == "object") {throw new TypeError("3rd input argument in function 'staticConvert2' is of type '"+settings.name+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings).");}
			else {throw new TypeError("3rd input argument '"+settings+"' in function 'staticConvert2' is of type '"+(typeof settings)+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: staticConvert2(PDFDoc, string, HTML2PDF_WebPageSettings).");}
		}
		return PDFNet.messageHandler.sendWithPromise('htmL2PDFStaticConvert2', {"doc": doc.id, "url": url, "settings": settings.id}, this.userPriority);
	},

		PDFNet.HTML2PDF.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('htmL2PDFCreate', {}, this.userPriority).then(function(id){
			//there is a return type HTML2PDF
			if(id == "0"){
				return null;
			}
			return new PDFNet.HTML2PDF(id);
		});
	},

		PDFNet.HTML2PDF.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.destroy', {"html2pdf": this.id}, this.userPriority);
	},

	/**
	* Add a web page to be converted. A single URL typically
	* results in many PDF pages.
	* @param url - HTML page, or relative path to local HTML page
	*/
		PDFNet.HTML2PDF.prototype.insertFromUrl = function(url)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertFromUrl'. Expected "+1+" argument. Function Signature: insertFromUrl(string)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'insertFromUrl' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("1st input argument '"+url+"' in function 'insertFromUrl' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: insertFromUrl(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertFromUrl', {"html2pdf": this.id, "url": url}, this.userPriority);
	},

	/**
	* Add a web page to be converted. A single URL typically
	* results in many PDF pages.
	*
	* @param url - HTML page, or relative path to local HTML page
	* @param settings - How the web page should be loaded and converted
	*/
		PDFNet.HTML2PDF.prototype.insertFromUrl2 = function(url, settings)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertFromUrl2'. Expected "+2+" arguments. Function Signature: insertFromUrl2(string, HTML2PDF_WebPageSettings)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'insertFromUrl2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("1st input argument '"+url+"' in function 'insertFromUrl2' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: insertFromUrl2(string, HTML2PDF_WebPageSettings).");}
		if(settings instanceof Promise) {throw new TypeError("2nd input argument in function 'insertFromUrl2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(settings instanceof PDFNet.HTML2PDF_WebPageSettings)) {
			if(typeof settings == "object") {throw new TypeError("2nd input argument in function 'insertFromUrl2' is of type '"+settings.name+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: insertFromUrl2(string, HTML2PDF_WebPageSettings).");}
			else {throw new TypeError("2nd input argument '"+settings+"' in function 'insertFromUrl2' is of type '"+(typeof settings)+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: insertFromUrl2(string, HTML2PDF_WebPageSettings).");}
		}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertFromUrl2', {"html2pdf": this.id, "url": url, "settings": settings.id}, this.userPriority);
	},

	/**
	* Convert HTML encoded in string.
	*
	* @param html - String containing HTML code.
	*/
		PDFNet.HTML2PDF.prototype.insertFromHtmlString = function(html)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertFromHtmlString'. Expected "+1+" argument. Function Signature: insertFromHtmlString(string)")};
		if(html instanceof Promise) {throw new TypeError("1st input argument in function 'insertFromHtmlString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof html != "string") {throw new TypeError("1st input argument '"+html+"' in function 'insertFromHtmlString' is of type '"+(typeof html)+"'. Expected type 'string'. Function Signature: insertFromHtmlString(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertFromHtmlString', {"html2pdf": this.id, "html": html}, this.userPriority);
	},

	/**
	* Convert HTML encoded in string.
	*
	* @param html - String containing HTML code.
	* @param settings - How the HTML content described in html is loaded.
	*/
		PDFNet.HTML2PDF.prototype.insertFromHtmlString2 = function(html, settings)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertFromHtmlString2'. Expected "+2+" arguments. Function Signature: insertFromHtmlString2(string, HTML2PDF_WebPageSettings)")};
		if(html instanceof Promise) {throw new TypeError("1st input argument in function 'insertFromHtmlString2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof html != "string") {throw new TypeError("1st input argument '"+html+"' in function 'insertFromHtmlString2' is of type '"+(typeof html)+"'. Expected type 'string'. Function Signature: insertFromHtmlString2(string, HTML2PDF_WebPageSettings).");}
		if(settings instanceof Promise) {throw new TypeError("2nd input argument in function 'insertFromHtmlString2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(settings instanceof PDFNet.HTML2PDF_WebPageSettings)) {
			if(typeof settings == "object") {throw new TypeError("2nd input argument in function 'insertFromHtmlString2' is of type '"+settings.name+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: insertFromHtmlString2(string, HTML2PDF_WebPageSettings).");}
			else {throw new TypeError("2nd input argument '"+settings+"' in function 'insertFromHtmlString2' is of type '"+(typeof settings)+"'. Expected type 'HTML2PDF_WebPageSettings'. Function Signature: insertFromHtmlString2(string, HTML2PDF_WebPageSettings).");}
		}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertFromHtmlString2', {"html2pdf": this.id, "html": html, "settings": settings.id}, this.userPriority);
	},

	/**
	* Add a table of contents to the produced PDF.
	*/
		PDFNet.HTML2PDF.prototype.insertTOC = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'insertTOC'. Expected "+0+" arguments. Function Signature: insertTOC()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertTOC', {"html2pdf": this.id}, this.userPriority);
	},

	/**
	* Add a table of contents to the produced PDF.
	*
	* @param settings - Settings for the table of contents.
	*/
		PDFNet.HTML2PDF.prototype.insertTOC2 = function(settings)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertTOC2'. Expected "+1+" argument. Function Signature: insertTOC2(HTML2PDF_TOCSettings)")};
		if(settings instanceof Promise) {throw new TypeError("1st input argument in function 'insertTOC2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(settings instanceof PDFNet.HTML2PDF_TOCSettings)) {
			if(typeof settings == "object") {throw new TypeError("1st input argument in function 'insertTOC2' is of type '"+settings.name+"'. Expected type 'HTML2PDF_TOCSettings'. Function Signature: insertTOC2(HTML2PDF_TOCSettings).");}
			else {throw new TypeError("1st input argument '"+settings+"' in function 'insertTOC2' is of type '"+(typeof settings)+"'. Expected type 'HTML2PDF_TOCSettings'. Function Signature: insertTOC2(HTML2PDF_TOCSettings).");}
		}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.insertTOC2', {"html2pdf": this.id, "settings": settings.id}, this.userPriority);
	},

	/**
	* Convert HTML documents and append the results
	* to doc.
	*
	* @pre html2pdf module must be located in the working directory, or
	* with the PDFNetC library.
	*
	* @return A promise that resolves to true if successful, otherwise false. Use
	* @ref GetHttpErrorCode for possible HTTP errors.
	*
	* @param doc - Target PDF to which converted HTML pages will
	* be appended to.
	*
	* @note Use @ref InsertFromURL and @ref InsertFromHtmlString to
	* add HTML documents to be converted.
	*/
		PDFNet.HTML2PDF.prototype.convert = function(doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'convert'. Expected "+1+" argument. Function Signature: convert(PDFDoc)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'convert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'convert' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: convert(PDFDoc).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'convert' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: convert(PDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.convert', {"html2pdf": this.id, "doc": doc.id}, this.userPriority);
	},

	/**
	* Return the largest HTTP error code encountered during conversion
	*
	* @return A promise that resolves to the largest HTTP code greater then or equal to 300 encountered during loading
	* of any of the supplied objects, if no such error code is found 0 is returned.
	*
	* @note This function will only return a useful result after @ref Convert has been called.
	*/
		PDFNet.HTML2PDF.prototype.getHttpErrorCode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHttpErrorCode'. Expected "+0+" arguments. Function Signature: getHttpErrorCode()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.getHttpErrorCode', {"html2pdf": this.id}, this.userPriority);
	},

	/**
	* Get results of conversion, including errors and warnings, in human readable form.
	*
	* @return A promise that resolves to string containing results of conversion.
	*/
		PDFNet.HTML2PDF.prototype.getLog = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLog'. Expected "+0+" arguments. Function Signature: getLog()")};
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.getLog', {"html2pdf": this.id}, this.userPriority);
	},

	/**
	* Manually set the paper dimensions of the produced PDF.
	*
	* @param width - Width of the page, e.g. "4cm".
	* @param height - Height of the page, eg. "12in".
	*
	* @note Supported units are mm, cm, m, in, pica(pc), pixel(px) and point(pt).
	*/
		PDFNet.HTML2PDF.prototype.setPaperSize2 = function(width, height)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPaperSize2'. Expected "+2+" arguments. Function Signature: setPaperSize2(string, string)")};
		if(width instanceof Promise) {throw new TypeError("1st input argument in function 'setPaperSize2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "string") {throw new TypeError("1st input argument '"+width+"' in function 'setPaperSize2' is of type '"+(typeof width)+"'. Expected type 'string'. Function Signature: setPaperSize2(string, string).");}
		if(height instanceof Promise) {throw new TypeError("2nd input argument in function 'setPaperSize2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "string") {throw new TypeError("2nd input argument '"+height+"' in function 'setPaperSize2' is of type '"+(typeof height)+"'. Expected type 'string'. Function Signature: setPaperSize2(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setPaperSize2', {"html2pdf": this.id, "width": width, "height": height}, this.userPriority);
	},

	/**
	* Set page orientation for output PDF.
	*
	* @param enable - If true generated PDF pages will be orientated to
	* landscape, otherwise orientation will be portrait.
	*/
		PDFNet.HTML2PDF.prototype.setLandscape = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLandscape'. Expected "+1+" argument. Function Signature: setLandscape(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setLandscape' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setLandscape' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setLandscape(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setLandscape', {"html2pdf": this.id, "enable": enable}, this.userPriority);
	},

	/**
	* Change the DPI explicitly for the output PDF.
	*
	* @param dpi - Dots per inch, e.g. 80.
	*
	* @attention This has no effect on X11 based systems.
	* @note Results also depend on @ref SetSmartShrinking.
	*/
		PDFNet.HTML2PDF.prototype.setDPI = function(dpi)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDPI'. Expected "+1+" argument. Function Signature: setDPI(number)")};
		if(dpi instanceof Promise) {throw new TypeError("1st input argument in function 'setDPI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dpi != "number") {throw new TypeError("1st input argument '"+dpi+"' in function 'setDPI' is of type '"+(typeof dpi)+"'. Expected type 'number'. Function Signature: setDPI(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setDPI', {"html2pdf": this.id, "dpi": dpi}, this.userPriority);
	},

	/**
	* Add bookmarks to the PDF?
	*
	* @param enable - If true bookmarks will be generated for the
	* produced PDF.
	* @param depth - Maximum depth of the outline (e.g. 4).
	*/
		PDFNet.HTML2PDF.prototype.setOutline = function(enable, depth)
	{
		if(typeof depth === "undefined") {depth = 4;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'setOutline'. Expected "+1+" to "+2+" arguments. Function Signature: setOutline(boolean, number)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setOutline' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setOutline' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setOutline(boolean, number).");}
		if(depth instanceof Promise) {throw new TypeError("2nd input argument in function 'setOutline' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof depth != "number") {throw new TypeError("2nd input argument '"+depth+"' in function 'setOutline' is of type '"+(typeof depth)+"'. Expected type 'number'. Function Signature: setOutline(boolean, number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setOutline', {"html2pdf": this.id, "enable": enable, "depth": depth}, this.userPriority);
	},

	/**
	* Save outline to a xml file?
	*
	* @param xml_file - Path of where xml data representing outline
	* of produced PDF should be saved to.
	*/
		PDFNet.HTML2PDF.prototype.dumpOutline = function(xml_file)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'dumpOutline'. Expected "+1+" argument. Function Signature: dumpOutline(string)")};
		if(xml_file instanceof Promise) {throw new TypeError("1st input argument in function 'dumpOutline' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof xml_file != "string") {throw new TypeError("1st input argument '"+xml_file+"' in function 'dumpOutline' is of type '"+(typeof xml_file)+"'. Expected type 'string'. Function Signature: dumpOutline(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.dumpOutline', {"html2pdf": this.id, "xml_file": xml_file}, this.userPriority);
	},

	/**
	* Use loss less compression to create PDF?
	*
	* @param enable - If true loss less compression will be used to
	* create PDF.
	*/
		PDFNet.HTML2PDF.prototype.setPDFCompression = function(enable)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPDFCompression'. Expected "+1+" argument. Function Signature: setPDFCompression(boolean)")};
		if(enable instanceof Promise) {throw new TypeError("1st input argument in function 'setPDFCompression' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable != "boolean") {throw new TypeError("1st input argument '"+enable+"' in function 'setPDFCompression' is of type '"+(typeof enable)+"'. Expected type 'boolean'. Function Signature: setPDFCompression(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setPDFCompression', {"html2pdf": this.id, "enable": enable}, this.userPriority);
	},

	/**
	* Set margins of generated PDF.
	*
	* param@ top - Size of the top margin, e.g. "2cm".
	* param@ bottom - Size of the bottom margin, e.g. "2cm".
	* param@ left - Size of the left margin, e.g. "2cm".
	* param@ right - Size of the right margin, e.g. "2cm".
	*
	* @note Supported units are mm, cm, m, in, pica(pc), pixel(px) and point(pt).
	*/
		PDFNet.HTML2PDF.prototype.setMargins = function(top, bottom, left, right)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'setMargins'. Expected "+4+" arguments. Function Signature: setMargins(string, string, string, string)")};
		if(top instanceof Promise) {throw new TypeError("1st input argument in function 'setMargins' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof top != "string") {throw new TypeError("1st input argument '"+top+"' in function 'setMargins' is of type '"+(typeof top)+"'. Expected type 'string'. Function Signature: setMargins(string, string, string, string).");}
		if(bottom instanceof Promise) {throw new TypeError("2nd input argument in function 'setMargins' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bottom != "string") {throw new TypeError("2nd input argument '"+bottom+"' in function 'setMargins' is of type '"+(typeof bottom)+"'. Expected type 'string'. Function Signature: setMargins(string, string, string, string).");}
		if(left instanceof Promise) {throw new TypeError("3rd input argument in function 'setMargins' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left != "string") {throw new TypeError("3rd input argument '"+left+"' in function 'setMargins' is of type '"+(typeof left)+"'. Expected type 'string'. Function Signature: setMargins(string, string, string, string).");}
		if(right instanceof Promise) {throw new TypeError("4th input argument in function 'setMargins' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof right != "string") {throw new TypeError("4th input argument '"+right+"' in function 'setMargins' is of type '"+(typeof right)+"'. Expected type 'string'. Function Signature: setMargins(string, string, string, string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setMargins', {"html2pdf": this.id, "top": top, "bottom": bottom, "left": left, "right": right}, this.userPriority);
	},

	/**
	* Maximum DPI to use for images in the generated PDF.
	*
	* @param dpi - Maximum dpi of images in produced PDF, e.g. 80.
	*/
		PDFNet.HTML2PDF.prototype.setImageDPI = function(dpi)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setImageDPI'. Expected "+1+" argument. Function Signature: setImageDPI(number)")};
		if(dpi instanceof Promise) {throw new TypeError("1st input argument in function 'setImageDPI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dpi != "number") {throw new TypeError("1st input argument '"+dpi+"' in function 'setImageDPI' is of type '"+(typeof dpi)+"'. Expected type 'number'. Function Signature: setImageDPI(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setImageDPI', {"html2pdf": this.id, "dpi": dpi}, this.userPriority);
	},

	/**
	* JpEG compression factor to use when generating PDF.
	*
	* @param quality - Compression factor, e.g. 92.
	*/
		PDFNet.HTML2PDF.prototype.setImageQuality = function(quality)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setImageQuality'. Expected "+1+" argument. Function Signature: setImageQuality(number)")};
		if(quality instanceof Promise) {throw new TypeError("1st input argument in function 'setImageQuality' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quality != "number") {throw new TypeError("1st input argument '"+quality+"' in function 'setImageQuality' is of type '"+(typeof quality)+"'. Expected type 'number'. Function Signature: setImageQuality(number).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setImageQuality', {"html2pdf": this.id, "quality": quality}, this.userPriority);
	},

	/**
	* Path of file used for loading and storing cookies.
	*
	* @param path - Path to file used for loading and storing cookies.
	*/
		PDFNet.HTML2PDF.prototype.setCookieJar = function(path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCookieJar'. Expected "+1+" argument. Function Signature: setCookieJar(string)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'setCookieJar' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'setCookieJar' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: setCookieJar(string).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setCookieJar', {"html2pdf": this.id, "path": path}, this.userPriority);
	},

	/**
	* Display HTML to PDF conversion progress, warnings, and errors, to stdout?
	*
	* @param quiet - If false, progress information is sent to stdout during conversion.
	*
	* @note You can get the final results using GetLog.
	*/
		PDFNet.HTML2PDF.prototype.setQuiet = function(quiet)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setQuiet'. Expected "+1+" argument. Function Signature: setQuiet(boolean)")};
		if(quiet instanceof Promise) {throw new TypeError("1st input argument in function 'setQuiet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quiet != "boolean") {throw new TypeError("1st input argument '"+quiet+"' in function 'setQuiet' is of type '"+(typeof quiet)+"'. Expected type 'boolean'. Function Signature: setQuiet(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('HTML2PDF.setQuiet', {"html2pdf": this.id, "quiet": quiet}, this.userPriority);
	},

	/**
	* Set the only location that PDFNet will look for the html2pdf module.
	*
	* @param path - A folder or file path. If non-empty, PDFNet will only
	* look in path for the html2pdf module, otherwise it will search in
	* the default locations for the module.
	*/
		PDFNet.HTML2PDF.setModulePath = function(path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setModulePath'. Expected "+1+" argument. Function Signature: setModulePath(string)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'setModulePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'setModulePath' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: setModulePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('htmL2PDFSetModulePath', {"path": path}, this.userPriority);
	},

	/**
	* Create and embed an Image. Embed the raw image data taking into account
	* specified compression hints.
	*
	* By default the function will compress all images using Flate compression.
	* It is possible to fine tune compression or to select a different compression
	* algorithm using 'encoder_hints' object.
	*
	* @return A promise that resolves to pDF::Image object representing the embedded image.
	*
	* @param doc - A document to which the image should be added. The 'Doc' object
	* can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
	* @param image_data - The stream or buffer containing image data. The image data must
	* not be compressed and must follow PDF format for sample representation (please refer
	* to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
	* @param width - The width of the image, in samples.
	* @param height - The height of the image, in samples.
	* @param bpc - The number of bits used to represent each color component.
	* @param color_space - The color space in which image samples are represented.
	* @param encoder_hints - An optional parameter that can be used to fine tune
	* compression or to select a different compression algorithm. See Image::Create()
	* for details.
	*/
		PDFNet.Image.createFromMemory = function(doc, buf, width, height, bpc, color_space, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 6) || (arguments.length > 7)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromMemory'. Expected "+6+" to "+7+" arguments. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromMemory' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromMemory' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createFromMemory' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createFromMemory' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("4th input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("4th input argument '"+width+"' in function 'createFromMemory' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		if(height instanceof Promise) {throw new TypeError("5th input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("5th input argument '"+height+"' in function 'createFromMemory' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		if(bpc instanceof Promise) {throw new TypeError("6th input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("6th input argument '"+bpc+"' in function 'createFromMemory' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		if(color_space instanceof Promise) {throw new TypeError("7th input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_space instanceof PDFNet.ColorSpace)) {
			if(typeof color_space == "object") {throw new TypeError("7th input argument in function 'createFromMemory' is of type '"+color_space.name+"'. Expected type 'ColorSpace'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("7th input argument '"+color_space+"' in function 'createFromMemory' is of type '"+(typeof color_space)+"'. Expected type 'ColorSpace'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		}
		if(encoder_hints instanceof Promise) {throw new TypeError("8th input argument in function 'createFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("8th input argument in function 'createFromMemory' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("8th input argument '"+encoder_hints+"' in function 'createFromMemory' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateFromMemory', {"doc": doc.id, "buf": buf.buffer, "width": width, "height": height, "bpc": bpc, "color_space": color_space.id, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed an Image. Embed the raw image data taking into account
	* specified compression hints.
	* @note see Image::Create for details.
	*/
		PDFNet.Image.createFromMemory2 = function(doc, buf, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromMemory2'. Expected "+2+" to "+3+" arguments. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromMemory2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromMemory2' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromMemory2' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromMemory2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createFromMemory2' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createFromMemory2' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
		}
		if(encoder_hints instanceof Promise) {throw new TypeError("4th input argument in function 'createFromMemory2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("4th input argument in function 'createFromMemory2' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
			else {throw new TypeError("4th input argument '"+encoder_hints+"' in function 'createFromMemory2' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createFromMemory2(SDFDoc, ArrayBuffer, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateFromMemory2', {"doc": doc.id, "buf": buf.buffer, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed an Image. Embed the raw image data taking into account
	* specified compression hints.
	* @note see Image::Create for details.
	*/
		PDFNet.Image.createFromStream = function(doc, image_data, width, height, bpc, color_space, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 6) || (arguments.length > 7)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromStream'. Expected "+6+" to "+7+" arguments. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromStream' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromStream' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		}
		if(image_data instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_data instanceof PDFNet.FilterReader)) {
			if(typeof image_data == "object") {throw new TypeError("2nd input argument in function 'createFromStream' is of type '"+image_data.name+"'. Expected type 'FilterReader'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("2nd input argument '"+image_data+"' in function 'createFromStream' is of type '"+(typeof image_data)+"'. Expected type 'FilterReader'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'createFromStream' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'createFromStream' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		if(bpc instanceof Promise) {throw new TypeError("5th input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("5th input argument '"+bpc+"' in function 'createFromStream' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		if(color_space instanceof Promise) {throw new TypeError("6th input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_space instanceof PDFNet.ColorSpace)) {
			if(typeof color_space == "object") {throw new TypeError("6th input argument in function 'createFromStream' is of type '"+color_space.name+"'. Expected type 'ColorSpace'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("6th input argument '"+color_space+"' in function 'createFromStream' is of type '"+(typeof color_space)+"'. Expected type 'ColorSpace'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		}
		if(encoder_hints instanceof Promise) {throw new TypeError("7th input argument in function 'createFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("7th input argument in function 'createFromStream' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
			else {throw new TypeError("7th input argument '"+encoder_hints+"' in function 'createFromStream' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateFromStream', {"doc": doc.id, "image_data": image_data.id, "width": width, "height": height, "bpc": bpc, "color_space": color_space.id, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed an Image. Embed the raw image data taking into account
	* specified compression hints.
	*
	* @note see Image::Create for details.
	* @note PDFNet takes ownership of the filter
	*/
		PDFNet.Image.createFromStream2 = function(doc, image_data, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromStream2'. Expected "+2+" to "+3+" arguments. Function Signature: createFromStream2(SDFDoc, Filter, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromStream2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromStream2' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromStream2' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
		}
		if(image_data instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromStream2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_data instanceof PDFNet.Filter)) {
			if(typeof image_data == "object") {throw new TypeError("2nd input argument in function 'createFromStream2' is of type '"+image_data.name+"'. Expected type 'Filter'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
			else {throw new TypeError("2nd input argument '"+image_data+"' in function 'createFromStream2' is of type '"+(typeof image_data)+"'. Expected type 'Filter'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
		}
		if(encoder_hints instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromStream2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("3rd input argument in function 'createFromStream2' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
			else {throw new TypeError("3rd input argument '"+encoder_hints+"' in function 'createFromStream2' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createFromStream2(SDFDoc, Filter, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateFromStream2', {"doc": doc.id, "image_data": image_data.id, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed an ImageMask. Embed the raw image data taking into account
	* specified compression hints. The ImageMask can be used as a stencil mask for
	* painting in the current color or as an explicit mask specifying which areas of
	* the image to paint and which to mask out. One of the most important uses of
	* stencil masking is for painting character glyphs represented as bitmaps.
	*
	* @return A promise that resolves to pDF::Image object representing the embedded ImageMask.
	*
	* @param doc - A document to which the image should be added. The 'Doc' object
	* can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
	* @param image_data - The stream or buffer containing image data stored in 1 bit per
	* sample format. The image data must not be compressed and must follow PDF format for
	* sample representation (please refer to section 4.8.2 'Sample Representation' in PDF
	* Reference Manual for details).
	* @param width - The width of the image, in samples.
	* @param height - The height of the image, in samples.
	* @param encoder_hints - An optional parameter that can be used to fine tune
	* compression or to select a different compression algorithm. See Image::Create()
	* for details.
	*/
		PDFNet.Image.createImageMask = function(doc, buf, width, height, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 4) || (arguments.length > 5)) {throw new RangeError(arguments.length+" arguments passed into function 'createImageMask'. Expected "+4+" to "+5+" arguments. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createImageMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createImageMask' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createImageMask' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createImageMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createImageMask' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createImageMask' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("4th input argument in function 'createImageMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("4th input argument '"+width+"' in function 'createImageMask' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
		if(height instanceof Promise) {throw new TypeError("5th input argument in function 'createImageMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("5th input argument '"+height+"' in function 'createImageMask' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
		if(encoder_hints instanceof Promise) {throw new TypeError("6th input argument in function 'createImageMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("6th input argument in function 'createImageMask' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
			else {throw new TypeError("6th input argument '"+encoder_hints+"' in function 'createImageMask' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createImageMask(SDFDoc, ArrayBuffer, number, number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateImageMask', {"doc": doc.id, "buf": buf.buffer, "width": width, "height": height, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed an ImageMask.
	* @note see Image::CreateImageMask for details.
	*/
		PDFNet.Image.createImageMaskFromStream = function(doc, image_data, width, height, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 4) || (arguments.length > 5)) {throw new RangeError(arguments.length+" arguments passed into function 'createImageMaskFromStream'. Expected "+4+" to "+5+" arguments. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createImageMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createImageMaskFromStream' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createImageMaskFromStream' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
		}
		if(image_data instanceof Promise) {throw new TypeError("2nd input argument in function 'createImageMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_data instanceof PDFNet.FilterReader)) {
			if(typeof image_data == "object") {throw new TypeError("2nd input argument in function 'createImageMaskFromStream' is of type '"+image_data.name+"'. Expected type 'FilterReader'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
			else {throw new TypeError("2nd input argument '"+image_data+"' in function 'createImageMaskFromStream' is of type '"+(typeof image_data)+"'. Expected type 'FilterReader'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'createImageMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'createImageMaskFromStream' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'createImageMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'createImageMaskFromStream' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
		if(encoder_hints instanceof Promise) {throw new TypeError("5th input argument in function 'createImageMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("5th input argument in function 'createImageMaskFromStream' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
			else {throw new TypeError("5th input argument '"+encoder_hints+"' in function 'createImageMaskFromStream' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createImageMaskFromStream(SDFDoc, FilterReader, number, number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateImageMaskFromStream', {"doc": doc.id, "image_data": image_data.id, "width": width, "height": height, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* create and embed a Soft Mask. Embed the raw image data taking into account
	* specified compression hints.
	*
	* @param A soft-mask image (see "Soft-Mask Images" in PDF Reference Manual) to
	* be used as a source of mask shape or mask opacity values in the transparent
	* imaging model.
	*
	* @param doc - A document to which the image should be added. The 'Doc' object
	* can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
	* @param image_data - The stream or buffer containing image data represented in
	* DeviceGray color space (i.e. one component per sample). The image data must not
	* be compressed and must follow PDF format for sample representation (please refer
	* to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
	* @param width - The width of the image, in samples.
	* @param height - The height of the image, in samples.
	* @param bpc - The number of bits used to represent each color component.
	* @param encoder_hints - An optional parameter that can be used to fine tune
	* compression or to select a different compression algorithm. See Image::Create()
	* for details.
	* @note this feature is available only in PDF 1.4 and higher.
	*/
		PDFNet.Image.createSoftMask = function(doc, buf, width, height, bpc, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 5) || (arguments.length > 6)) {throw new RangeError(arguments.length+" arguments passed into function 'createSoftMask'. Expected "+5+" to "+6+" arguments. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createSoftMask' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createSoftMask' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createSoftMask' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createSoftMask' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("4th input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("4th input argument '"+width+"' in function 'createSoftMask' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		if(height instanceof Promise) {throw new TypeError("5th input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("5th input argument '"+height+"' in function 'createSoftMask' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		if(bpc instanceof Promise) {throw new TypeError("6th input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("6th input argument '"+bpc+"' in function 'createSoftMask' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		if(encoder_hints instanceof Promise) {throw new TypeError("7th input argument in function 'createSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("7th input argument in function 'createSoftMask' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
			else {throw new TypeError("7th input argument '"+encoder_hints+"' in function 'createSoftMask' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createSoftMask(SDFDoc, ArrayBuffer, number, number, number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateSoftMask', {"doc": doc.id, "buf": buf.buffer, "width": width, "height": height, "bpc": bpc, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create and embed a Soft Mask. Embed the raw image data taking into account
	* specified compression hints.
	* @note see Image::CreateSoftMask for details.
	*/
		PDFNet.Image.createSoftMaskFromStream = function(doc, image_data, width, height, bpc, encoder_hints)
	{
		if(typeof encoder_hints === "undefined") {encoder_hints = new PDFNet.Obj("0");};
		if((arguments.length < 5) || (arguments.length > 6)) {throw new RangeError(arguments.length+" arguments passed into function 'createSoftMaskFromStream'. Expected "+5+" to "+6+" arguments. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createSoftMaskFromStream' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createSoftMaskFromStream' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		}
		if(image_data instanceof Promise) {throw new TypeError("2nd input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_data instanceof PDFNet.FilterReader)) {
			if(typeof image_data == "object") {throw new TypeError("2nd input argument in function 'createSoftMaskFromStream' is of type '"+image_data.name+"'. Expected type 'FilterReader'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
			else {throw new TypeError("2nd input argument '"+image_data+"' in function 'createSoftMaskFromStream' is of type '"+(typeof image_data)+"'. Expected type 'FilterReader'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'createSoftMaskFromStream' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'createSoftMaskFromStream' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		if(bpc instanceof Promise) {throw new TypeError("5th input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("5th input argument '"+bpc+"' in function 'createSoftMaskFromStream' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		if(encoder_hints instanceof Promise) {throw new TypeError("6th input argument in function 'createSoftMaskFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("6th input argument in function 'createSoftMaskFromStream' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
			else {throw new TypeError("6th input argument '"+encoder_hints+"' in function 'createSoftMaskFromStream' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createSoftMaskFromStream(SDFDoc, FilterReader, number, number, number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateSoftMaskFromStream', {"doc": doc.id, "image_data": image_data.id, "width": width, "height": height, "bpc": bpc, "encoder_hints": encoder_hints.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Directly embed the image that is already compressed using the Image::InputFilter
	* format. The function can be used to pass-through pre-compressed image data.
	*
	* @return A promise that resolves to pDF::Image object representing the embedded image.
	*
	* @param doc - A document to which the image should be added. The 'Doc' object
	* can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
	* @param image_data - The stream or buffer containing compressed image data.
	* The compression format must match the input_format parameter.
	* @param width - The width of the image, in samples.
	* @param height - The height of the image, in samples.
	* @param bpc - The number of bits used to represent each color component.
	* @param color_space - The color space in which image samples are specified.
	* @param input_format - Image::InputFilter describing the format of pre-compressed
	* image data.
	* @param encoder_hints - An optional parameter that can be used to fine tune
	* compression or to select a different compression algorithm. See Image::Create()
	* for details.
	*/
		PDFNet.Image.createDirectFromMemory = function(doc, buf, width, height, bpc, color_space, input_format)
	{
		if(arguments.length != 7) {throw new RangeError(arguments.length+" arguments passed into function 'createDirectFromMemory'. Expected "+7+" arguments. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createDirectFromMemory' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createDirectFromMemory' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		}
		if(buf instanceof Promise) {throw new TypeError("2nd input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("2nd input argument in function 'createDirectFromMemory' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("2nd input argument '"+buf+"' in function 'createDirectFromMemory' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		}
		if(width instanceof Promise) {throw new TypeError("4th input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("4th input argument '"+width+"' in function 'createDirectFromMemory' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		if(height instanceof Promise) {throw new TypeError("5th input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("5th input argument '"+height+"' in function 'createDirectFromMemory' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		if(bpc instanceof Promise) {throw new TypeError("6th input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("6th input argument '"+bpc+"' in function 'createDirectFromMemory' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		if(color_space instanceof Promise) {throw new TypeError("7th input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_space instanceof PDFNet.ColorSpace)) {
			if(typeof color_space == "object") {throw new TypeError("7th input argument in function 'createDirectFromMemory' is of type '"+color_space.name+"'. Expected type 'ColorSpace'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("7th input argument '"+color_space+"' in function 'createDirectFromMemory' is of type '"+(typeof color_space)+"'. Expected type 'ColorSpace'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		}
		if(input_format instanceof Promise) {throw new TypeError("8th input argument in function 'createDirectFromMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof input_format != "number") {throw new TypeError("8th input argument '"+input_format+"' in function 'createDirectFromMemory' is of type '"+(typeof input_format)+"'. Expected type 'number'. Function Signature: createDirectFromMemory(SDFDoc, ArrayBuffer, number, number, number, ColorSpace, number).");}
		return PDFNet.messageHandler.sendWithPromise('imageCreateDirectFromMemory', {"doc": doc.id, "buf": buf.buffer, "width": width, "height": height, "bpc": bpc, "color_space": color_space.id, "input_format": input_format}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Embed the raw image data taking into account specified compression hints.
	* @note see the above method for details.
	*/
		PDFNet.Image.createDirectFromStream = function(doc, image_data, width, height, bpc, color_space, input_format)
	{
		if(arguments.length != 7) {throw new RangeError(arguments.length+" arguments passed into function 'createDirectFromStream'. Expected "+7+" arguments. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createDirectFromStream' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createDirectFromStream' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		}
		if(image_data instanceof Promise) {throw new TypeError("2nd input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_data instanceof PDFNet.FilterReader)) {
			if(typeof image_data == "object") {throw new TypeError("2nd input argument in function 'createDirectFromStream' is of type '"+image_data.name+"'. Expected type 'FilterReader'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("2nd input argument '"+image_data+"' in function 'createDirectFromStream' is of type '"+(typeof image_data)+"'. Expected type 'FilterReader'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		}
		if(width instanceof Promise) {throw new TypeError("3rd input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("3rd input argument '"+width+"' in function 'createDirectFromStream' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		if(height instanceof Promise) {throw new TypeError("4th input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("4th input argument '"+height+"' in function 'createDirectFromStream' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		if(bpc instanceof Promise) {throw new TypeError("5th input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof bpc != "number") {throw new TypeError("5th input argument '"+bpc+"' in function 'createDirectFromStream' is of type '"+(typeof bpc)+"'. Expected type 'number'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		if(color_space instanceof Promise) {throw new TypeError("6th input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_space instanceof PDFNet.ColorSpace)) {
			if(typeof color_space == "object") {throw new TypeError("6th input argument in function 'createDirectFromStream' is of type '"+color_space.name+"'. Expected type 'ColorSpace'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
			else {throw new TypeError("6th input argument '"+color_space+"' in function 'createDirectFromStream' is of type '"+(typeof color_space)+"'. Expected type 'ColorSpace'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		}
		if(input_format instanceof Promise) {throw new TypeError("7th input argument in function 'createDirectFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof input_format != "number") {throw new TypeError("7th input argument '"+input_format+"' in function 'createDirectFromStream' is of type '"+(typeof input_format)+"'. Expected type 'number'. Function Signature: createDirectFromStream(SDFDoc, FilterReader, number, number, number, ColorSpace, number).");}
		return PDFNet.messageHandler.sendWithPromise('imageCreateDirectFromStream', {"doc": doc.id, "image_data": image_data.id, "width": width, "height": height, "bpc": bpc, "color_space": color_space.id, "input_format": input_format}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* Create an image from an existing image represented as a SDF/Cos object.
	*
	* @note To create the Image object from image PDF::Element, pass the Element's
	* SDF/Cos dictionary to Image constructor (i.e. Image image(element->GetXObject()))
	*/
		PDFNet.Image.createFromObj = function(image_xobject)
	{
		if(typeof image_xobject === "undefined") {image_xobject = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+1+" arguments. Function Signature: createFromObj(Obj)")};
		if(image_xobject instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_xobject instanceof PDFNet.Obj)) {
			if(typeof image_xobject == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+image_xobject.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+image_xobject+"' in function 'createFromObj' is of type '"+(typeof image_xobject)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('imageCreateFromObj', {"image_xobject": image_xobject.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

		PDFNet.Image.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('Image.copy', {"c": this.id}, this.userPriority).then(function(id){
			//there is a return type Image
			if(id == "0"){
				return null;
			}
			return new PDFNet.Image(id);
		});
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object
	*/
		PDFNet.Image.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getSDFObj', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to whether this is a valid raster image. If the function returns false the
	* underlying SDF/Cos object is not a valid raster image and this Image object should
	* be treated as null.
	*/
		PDFNet.Image.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('Image.isValid', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a stream (filter) containing decoded image data
	*/
		PDFNet.Image.prototype.getImageData = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageData'. Expected "+0+" arguments. Function Signature: getImageData()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageData', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to the size of image data in bytes
	*/
		PDFNet.Image.prototype.getImageDataSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageDataSize'. Expected "+0+" arguments. Function Signature: getImageDataSize()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageDataSize', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the SDF object representing the color space in which image
	* samples are specified or NULL if:
	*  - the image is an image mask
	*  - or is compressed using JPXDecode with missing ColorSpace entry in image dictionary.
	*
	* The returned color space may be any type of color space except Pattern.
	*/
		PDFNet.Image.prototype.getImageColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageColorSpace'. Expected "+0+" arguments. Function Signature: getImageColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageColorSpace', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to the width of the image, in samples.
	*/
		PDFNet.Image.prototype.getImageWidth = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageWidth'. Expected "+0+" arguments. Function Signature: getImageWidth()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageWidth', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the height of the image, in samples.
	*/
		PDFNet.Image.prototype.getImageHeight = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageHeight'. Expected "+0+" arguments. Function Signature: getImageHeight()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageHeight', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
	* array of numbers describing how to map image samples into the range of values
	* appropriate for the images color space . If ImageMask is true, the array must be
	* either [0 1] or [1 0]; otherwise, its length must be twice the number of color
	* components required by ColorSpace. Default value depends on the color space,
	* See Table 4.36 in PDF Ref. Manual.
	*/
		PDFNet.Image.prototype.getDecodeArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDecodeArray'. Expected "+0+" arguments. Function Signature: getDecodeArray()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getDecodeArray', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the number of bits used to represent each color component. Only a
	* single value may be specified; the number of bits is the same for all color
	* components. Valid values are 1, 2, 4, 8, and 16.
	*/
		PDFNet.Image.prototype.getBitsPerComponent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBitsPerComponent'. Expected "+0+" arguments. Function Signature: getBitsPerComponent()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getBitsPerComponent', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the number of color components per sample.
	*/
		PDFNet.Image.prototype.getComponentNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getComponentNum'. Expected "+0+" arguments. Function Signature: getComponentNum()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getComponentNum', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
	*/
		PDFNet.Image.prototype.isImageMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isImageMask'. Expected "+0+" arguments. Function Signature: isImageMask()")};
		return PDFNet.messageHandler.sendWithPromise('Image.isImageMask', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a boolean indicating whether image interpolation is to be performed.
	*/
		PDFNet.Image.prototype.isImageInterpolate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isImageInterpolate'. Expected "+0+" arguments. Function Signature: isImageInterpolate()")};
		return PDFNet.messageHandler.sendWithPromise('Image.isImageInterpolate', {"img": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an image XObject defining an image mask to be applied to this image (See
	* 'Explicit Masking', 4.8.5), or an array specifying a range of colors
	* to be applied to it as a color key mask (See 'Color Key Masking').
	*
	* If IsImageMask() return true, this method will return NULL.
	*/
		PDFNet.Image.prototype.getMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMask'. Expected "+0+" arguments. Function Signature: getMask()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getMask', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* set an Explicit Image Mask.
	*
	* @param An Image object which serves as an explicit mask for the
	* base (this) image. The base image and the image mask need not have the
	* same resolution (Width and Height values), but since all images are defined on
	* the unit square in user space, their boundaries on the page will coincide; that is,
	* they will overlay each other. The image mask indicates which places on the page
	* are to be painted and which are to be masked out (left unchanged). Unmasked areas
	* are painted with the corresponding portions of the base image; masked areas
	* are not.
	*
	* @note image_mask must be a valid image mask (i.e. image_mask.IsImageMask() must
	* return true.
	*/
		PDFNet.Image.prototype.setMask = function(image_mask)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMask'. Expected "+1+" argument. Function Signature: setMask(Image)")};
		if(image_mask instanceof Promise) {throw new TypeError("1st input argument in function 'setMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(image_mask instanceof PDFNet.Image)) {
			if(typeof image_mask == "object") {throw new TypeError("1st input argument in function 'setMask' is of type '"+image_mask.name+"'. Expected type 'Image'. Function Signature: setMask(Image).");}
			else {throw new TypeError("1st input argument '"+image_mask+"' in function 'setMask' is of type '"+(typeof image_mask)+"'. Expected type 'Image'. Function Signature: setMask(Image).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.setMask', {"img": this.id, "image_mask": image_mask.id}, this.userPriority);
	},

	/**
	* set a Color Key Mask.
	*
	* @param mask is an Cos/SDF array specifying a range of colors to be masked
	* out. Samples in the image that fall within this range are not painted, allowing
	* the existing background to show through. The effect is similar to that of the
	* video technique known as chroma-key. For details of the array format please
	* refer to section 4.8.5 'Color Key Masking' in PDF Reference Manual.
	*
	* @note the current document takes the ownership of the given SDF object.
	*/
		PDFNet.Image.prototype.setMaskWithObj = function(mask)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMaskWithObj'. Expected "+1+" argument. Function Signature: setMaskWithObj(Obj)")};
		if(mask instanceof Promise) {throw new TypeError("1st input argument in function 'setMaskWithObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mask instanceof PDFNet.Obj)) {
			if(typeof mask == "object") {throw new TypeError("1st input argument in function 'setMaskWithObj' is of type '"+mask.name+"'. Expected type 'Obj'. Function Signature: setMaskWithObj(Obj).");}
			else {throw new TypeError("1st input argument '"+mask+"' in function 'setMaskWithObj' is of type '"+(typeof mask)+"'. Expected type 'Obj'. Function Signature: setMaskWithObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.setMaskWithObj', {"img": this.id, "mask": mask.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an image XObject defining a Soft Mask to be applied to this image
	* (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual), or NULL
	* if the image does not have the soft mask.
	*/
		PDFNet.Image.prototype.getSoftMask = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSoftMask'. Expected "+0+" arguments. Function Signature: getSoftMask()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getSoftMask', {"img": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* set a Soft Mask.
	*
	* @param soft_mask is a subsidiary Image object defining a soft-mask image
	* (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual) to be used
	* as a source of mask shape or mask opacity values in the transparent imaging
	* model. The alpha source parameter in the graphics state determines whether
	* the mask values are interpreted as shape or opacity.
	*/
		PDFNet.Image.prototype.setSoftMask = function(soft_mask)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSoftMask'. Expected "+1+" argument. Function Signature: setSoftMask(Image)")};
		if(soft_mask instanceof Promise) {throw new TypeError("1st input argument in function 'setSoftMask' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(soft_mask instanceof PDFNet.Image)) {
			if(typeof soft_mask == "object") {throw new TypeError("1st input argument in function 'setSoftMask' is of type '"+soft_mask.name+"'. Expected type 'Image'. Function Signature: setSoftMask(Image).");}
			else {throw new TypeError("1st input argument '"+soft_mask+"' in function 'setSoftMask' is of type '"+(typeof soft_mask)+"'. Expected type 'Image'. Function Signature: setSoftMask(Image).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.setSoftMask', {"img": this.id, "soft_mask": soft_mask.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the color rendering intent to be used in rendering the image.
	*/
		PDFNet.Image.prototype.getImageRenderingIntent = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getImageRenderingIntent'. Expected "+0+" arguments. Function Signature: getImageRenderingIntent()")};
		return PDFNet.messageHandler.sendWithPromise('Image.getImageRenderingIntent', {"img": this.id}, this.userPriority);
	},

	/**
	* Saves this image to a file.
	*
	* The output image format (TIFF, JPEG, or PNG) will be
	* automatically selected based on the properties of the embedded
	* image. For example, if the embedded image is using CCITT Fax
	* compression, the output format will be TIFF. Similarly, if the
	* embedded image is using JPEG compression the output format will
	* be JPEG. If your application needs to explicitly control output
	* image format you may want to use ExportAsTiff() or ExportAsPng().
	*
	* @param filename string that specifies the path name for
	* the saved image. The filename should not include the extension
	* which will be appended to the filename string based on the output
	* format.
	*
	* @return A promise that resolves to the number indicating the selected image format:
	* (0 - PNG, 1 - TIF, 2 - JPEG).
	*/
		PDFNet.Image.prototype.export = function(filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'export'. Expected "+1+" argument. Function Signature: export(string)")};
		if(filename instanceof Promise) {throw new TypeError("1st input argument in function 'export' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filename != "string") {throw new TypeError("1st input argument '"+filename+"' in function 'export' is of type '"+(typeof filename)+"'. Expected type 'string'. Function Signature: export(string).");}
		return PDFNet.messageHandler.sendWithPromise('Image.export', {"img": this.id, "filename": filename}, this.userPriority);
	},

	/**
	* Saves this image to the output stream.
	*
	* @return A promise that resolves to the number indicating the selected image format:
	* (0 - PNG, 1 - TIF, 2 - JPEG).
	*
	* @param writer A pointer to FilterWriter used to write to the
	* output stream. If the parameter is null, nothing will be written
	* to the output stream, but the function returns the format identifier.
	*
	* @note see the overloaded Image::Export method for more information.
	*/
		PDFNet.Image.prototype.exportFromStream = function(writer)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'exportFromStream'. Expected "+1+" argument. Function Signature: exportFromStream(FilterWriter)")};
		if(writer instanceof Promise) {throw new TypeError("1st input argument in function 'exportFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(writer instanceof PDFNet.FilterWriter)) {
			if(typeof writer == "object") {throw new TypeError("1st input argument in function 'exportFromStream' is of type '"+writer.name+"'. Expected type 'FilterWriter'. Function Signature: exportFromStream(FilterWriter).");}
			else {throw new TypeError("1st input argument '"+writer+"' in function 'exportFromStream' is of type '"+(typeof writer)+"'. Expected type 'FilterWriter'. Function Signature: exportFromStream(FilterWriter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.exportFromStream', {"img": this.id, "writer": writer.id}, this.userPriority);
	},

	/**
	* Saves this image to a TIFF file.
	*
	* @param filename string that specifies the path name for
	* the saved image. The filename should include the file extension
	*/
		PDFNet.Image.prototype.exportAsTiff = function(filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'exportAsTiff'. Expected "+1+" argument. Function Signature: exportAsTiff(string)")};
		if(filename instanceof Promise) {throw new TypeError("1st input argument in function 'exportAsTiff' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filename != "string") {throw new TypeError("1st input argument '"+filename+"' in function 'exportAsTiff' is of type '"+(typeof filename)+"'. Expected type 'string'. Function Signature: exportAsTiff(string).");}
		return PDFNet.messageHandler.sendWithPromise('Image.exportAsTiff', {"img": this.id, "filename": filename}, this.userPriority);
	},

	/**
	* Saves this image to a TIFF output stream.
	*
	* @param writer FilterWriter used to write to the output stream.
	*/
		PDFNet.Image.prototype.exportAsTiffFromStream = function(writer)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'exportAsTiffFromStream'. Expected "+1+" argument. Function Signature: exportAsTiffFromStream(FilterWriter)")};
		if(writer instanceof Promise) {throw new TypeError("1st input argument in function 'exportAsTiffFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(writer instanceof PDFNet.FilterWriter)) {
			if(typeof writer == "object") {throw new TypeError("1st input argument in function 'exportAsTiffFromStream' is of type '"+writer.name+"'. Expected type 'FilterWriter'. Function Signature: exportAsTiffFromStream(FilterWriter).");}
			else {throw new TypeError("1st input argument '"+writer+"' in function 'exportAsTiffFromStream' is of type '"+(typeof writer)+"'. Expected type 'FilterWriter'. Function Signature: exportAsTiffFromStream(FilterWriter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.exportAsTiffFromStream', {"img": this.id, "writer": writer.id}, this.userPriority);
	},

	/**
	* Saves this image to a PNG file.
	*
	* @param filename string that specifies the path name for
	* the saved image. The filename should include the file extension
	*/
		PDFNet.Image.prototype.exportAsPng = function(filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'exportAsPng'. Expected "+1+" argument. Function Signature: exportAsPng(string)")};
		if(filename instanceof Promise) {throw new TypeError("1st input argument in function 'exportAsPng' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filename != "string") {throw new TypeError("1st input argument '"+filename+"' in function 'exportAsPng' is of type '"+(typeof filename)+"'. Expected type 'string'. Function Signature: exportAsPng(string).");}
		return PDFNet.messageHandler.sendWithPromise('Image.exportAsPng', {"img": this.id, "filename": filename}, this.userPriority);
	},

	/**
	* Saves this image to a PNG output stream.
	*
	* @param writer FilterWriter used to write to the output stream.
	*/
		PDFNet.Image.prototype.exportAsPngFromStream = function(writer)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'exportAsPngFromStream'. Expected "+1+" argument. Function Signature: exportAsPngFromStream(FilterWriter)")};
		if(writer instanceof Promise) {throw new TypeError("1st input argument in function 'exportAsPngFromStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(writer instanceof PDFNet.FilterWriter)) {
			if(typeof writer == "object") {throw new TypeError("1st input argument in function 'exportAsPngFromStream' is of type '"+writer.name+"'. Expected type 'FilterWriter'. Function Signature: exportAsPngFromStream(FilterWriter).");}
			else {throw new TypeError("1st input argument '"+writer+"' in function 'exportAsPngFromStream' is of type '"+(typeof writer)+"'. Expected type 'FilterWriter'. Function Signature: exportAsPngFromStream(FilterWriter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Image.exportAsPngFromStream', {"img": this.id, "writer": writer.id}, this.userPriority);
	},

		PDFNet.Optimizer.imageSettingsInit = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'imageSettingsInit'. Expected "+0+" arguments. Function Signature: imageSettingsInit()")};
		return PDFNet.messageHandler.sendWithPromise('optimizerImageSettingsInit', {}, this.userPriority);
	},

		PDFNet.Optimizer.monoImageSettingsInit = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'monoImageSettingsInit'. Expected "+0+" arguments. Function Signature: monoImageSettingsInit()")};
		return PDFNet.messageHandler.sendWithPromise('optimizerMonoImageSettingsInit', {}, this.userPriority);
	},

		PDFNet.Optimizer.textSettingsInit = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'textSettingsInit'. Expected "+0+" arguments. Function Signature: textSettingsInit()")};
		return PDFNet.messageHandler.sendWithPromise('optimizerTextSettingsInit', {}, this.userPriority);
	},

	/**
	* Optimize the given document using the optimizers settings
	* @param doc the document to optimize
	* @param color_image_settings the image processing settings
	* for color images
	* @param grayscale_image_settings the image processing settings
	* for grayscale images
	* @param mono_image_settings the image processing settings
	* for monochrome images
	*/
		PDFNet.Optimizer.optimize = function(doc, color_image_settings, grayscale_image_settings, mono_image_settings, text_settings, remove_custom)
	{
		if(typeof color_image_settings === "undefined") {color_image_settings = new PDFNet.OptimizerSettings("0");};
		if((arguments.length < 5) || (arguments.length > 6)) {throw new RangeError(arguments.length+" arguments passed into function 'optimize'. Expected "+5+" to "+6+" arguments. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'optimize' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'optimize' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		}
		if(color_image_settings instanceof Promise) {throw new TypeError("2nd input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(color_image_settings instanceof PDFNet.OptimizerImageSettings) && color_image_settings.name != "OptimizerImageSettings") {
			if(typeof color_image_settings == "object") {throw new TypeError("2nd input argument in function 'optimize' is of type '"+color_image_settings.name+"'. Expected type 'OptimizerImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
			else {throw new TypeError("2nd input argument '"+color_image_settings+"' in function 'optimize' is of type '"+(typeof color_image_settings)+"'. Expected type 'OptimizerImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		}
		if(grayscale_image_settings instanceof Promise) {throw new TypeError("3rd input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(grayscale_image_settings instanceof PDFNet.OptimizerImageSettings) && grayscale_image_settings.name != "OptimizerImageSettings") {
			if(typeof grayscale_image_settings == "object") {throw new TypeError("3rd input argument in function 'optimize' is of type '"+grayscale_image_settings.name+"'. Expected type 'OptimizerImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
			else {throw new TypeError("3rd input argument '"+grayscale_image_settings+"' in function 'optimize' is of type '"+(typeof grayscale_image_settings)+"'. Expected type 'OptimizerImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		}
		if(mono_image_settings instanceof Promise) {throw new TypeError("4th input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mono_image_settings instanceof PDFNet.OptimizerMonoImageSettings) && mono_image_settings.name != "OptimizerMonoImageSettings") {
			if(typeof mono_image_settings == "object") {throw new TypeError("4th input argument in function 'optimize' is of type '"+mono_image_settings.name+"'. Expected type 'OptimizerMonoImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
			else {throw new TypeError("4th input argument '"+mono_image_settings+"' in function 'optimize' is of type '"+(typeof mono_image_settings)+"'. Expected type 'OptimizerMonoImageSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		}
		if(text_settings instanceof Promise) {throw new TypeError("5th input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(text_settings instanceof PDFNet.OptimizerTextSettings) && text_settings.name != "OptimizerTextSettings") {
			if(typeof text_settings == "object") {throw new TypeError("5th input argument in function 'optimize' is of type '"+text_settings.name+"'. Expected type 'OptimizerTextSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
			else {throw new TypeError("5th input argument '"+text_settings+"' in function 'optimize' is of type '"+(typeof text_settings)+"'. Expected type 'OptimizerTextSettings'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		}
		if(remove_custom instanceof Promise) {throw new TypeError("6th input argument in function 'optimize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof remove_custom != "boolean") {throw new TypeError("6th input argument '"+remove_custom+"' in function 'optimize' is of type '"+(typeof remove_custom)+"'. Expected type 'boolean'. Function Signature: optimize(PDFDoc, OptimizerImageSettings, OptimizerImageSettings, OptimizerMonoImageSettings, OptimizerTextSettings, boolean).");}
		if(typeof color_image_settings.yieldFunction != "undefined") {throw new Error("Function '"+color_image_settings.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'optimize'. Perhaps a yield statement is required for '"+color_image_settings.yieldFunction+"'?");}
		if(typeof grayscale_image_settings.yieldFunction != "undefined") {throw new Error("Function '"+grayscale_image_settings.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 3rd input argument in function 'optimize'. Perhaps a yield statement is required for '"+grayscale_image_settings.yieldFunction+"'?");}
		if(typeof mono_image_settings.yieldFunction != "undefined") {throw new Error("Function '"+mono_image_settings.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 4th input argument in function 'optimize'. Perhaps a yield statement is required for '"+mono_image_settings.yieldFunction+"'?");}
		if(typeof text_settings.yieldFunction != "undefined") {throw new Error("Function '"+text_settings.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 5th input argument in function 'optimize'. Perhaps a yield statement is required for '"+text_settings.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('optimizerOptimize', {"doc": doc.id, "color_image_settings": color_image_settings, "grayscale_image_settings": grayscale_image_settings, "mono_image_settings": mono_image_settings, "text_settings": text_settings, "remove_custom": remove_custom}, this.userPriority);
	},

	/**
	* Creates a new PageLabel.
	*
	* @param doc A document to which the page label is added.
	* @param style The numbering style for the label.
	* @param prefix The string used to prefix the numeric portion of the
	* page label.
	* @param start_at the value to use when generating the numeric portion of the first
	* label in this range; must be greater than or equal to 1.
	*
	* @return A promise that resolves to newly created PageLabel object.
	*/
		PDFNet.PageLabel.create = function(doc, style, prefix, start_at)
	{
		if(typeof prefix === "undefined") {prefix = "";};
		if(typeof start_at === "undefined") {start_at = 1;};
		if((arguments.length < 2) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" to "+4+" arguments. Function Signature: create(SDFDoc, number, string, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number, string, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, number, string, number).");}
		}
		if(style instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("2nd input argument '"+style+"' in function 'create' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: create(SDFDoc, number, string, number).");}
		if(prefix instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof prefix != "string") {throw new TypeError("3rd input argument '"+prefix+"' in function 'create' is of type '"+(typeof prefix)+"'. Expected type 'string'. Function Signature: create(SDFDoc, number, string, number).");}
		if(start_at instanceof Promise) {throw new TypeError("4th input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_at != "number") {throw new TypeError("4th input argument '"+start_at+"' in function 'create' is of type '"+(typeof start_at)+"'. Expected type 'number'. Function Signature: create(SDFDoc, number, string, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageLabelCreate', {"doc": doc.id, "style": style, "prefix": prefix, "start_at": start_at}, this.userPriority).then(function(id){
			//there is a return type PageLabel
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageLabel(id);
		});
	},

	/**
	* Create a PageLabel and initialize it using given Cos/SDF object.
	* @note The constructor does not copy any data, but is instead the logical
	* equivalent of a type cast.
	*/
		PDFNet.PageLabel.createFromObj = function(l, first_page, last_page)
	{
		if(typeof l === "undefined") {l = new PDFNet.Obj("0");};
		if(typeof first_page === "undefined") {first_page = -1;};
		if(typeof last_page === "undefined") {last_page = -1;};
		if(arguments.length > 3) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected at most "+3+" arguments. Function Signature: createFromObj(Obj, number, number)")};
		if(l instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(l instanceof PDFNet.Obj)) {
			if(typeof l == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+l.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj, number, number).");}
			else {throw new TypeError("1st input argument '"+l+"' in function 'createFromObj' is of type '"+(typeof l)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj, number, number).");}
		}
		if(first_page instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof first_page != "number") {throw new TypeError("2nd input argument '"+first_page+"' in function 'createFromObj' is of type '"+(typeof first_page)+"'. Expected type 'number'. Function Signature: createFromObj(Obj, number, number).");}
		if(last_page instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof last_page != "number") {throw new TypeError("3rd input argument '"+last_page+"' in function 'createFromObj' is of type '"+(typeof last_page)+"'. Expected type 'number'. Function Signature: createFromObj(Obj, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageLabelCreateFromObj', {"l": l.id, "first_page": first_page, "last_page": last_page}, this.userPriority).then(function(id){
			//there is a return type PageLabel
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageLabel(id);
		});
	},

		PDFNet.PageLabel.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(PageLabel)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.PageLabel) && right.name != "PageLabel") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'PageLabel'. Function Signature: assign(PageLabel).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'PageLabel'. Function Signature: assign(PageLabel).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "PageLabel.assign"; // TRN_PageLabel* left
		return PDFNet.messageHandler.sendWithPromise('PageLabel.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.PageLabel.prototype.compare = function(d)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(PageLabel)")};
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(d instanceof PDFNet.PageLabel) && d.name != "PageLabel") {
			if(typeof d == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+d.name+"'. Expected type 'PageLabel'. Function Signature: compare(PageLabel).");}
			else {throw new TypeError("1st input argument '"+d+"' in function 'compare' is of type '"+(typeof d)+"'. Expected type 'PageLabel'. Function Signature: compare(PageLabel).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'compare'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof d.yieldFunction != "undefined") {throw new Error("Function '"+d.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'compare'. Perhaps a yield statement is required for '"+d.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "PageLabel.compare"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.compare', {"l": this, "d": d}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.PageLabel.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('PageLabel.isValid', {"l": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the full label title that is in effect for the given page.
	* If there is no label object in effect, this method returns an
	* empty string.
	*/
		PDFNet.PageLabel.prototype.getLabelTitle = function(page_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getLabelTitle'. Expected "+1+" argument. Function Signature: getLabelTitle(number)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'getLabelTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'getLabelTitle' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: getLabelTitle(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getLabelTitle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.getLabelTitle"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getLabelTitle', {"l": this, "page_num": page_num}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* Sets the numbering style for the label.
	*
	* @param style the numbering style for the label.
	*
	* You may use label style to customize the page numbering schemes
	* used throughout a document. There are three numbering formats:
	*  - decimal (often used for normal page ranges)
	*  - roman (often used for front matter such as a preface)
	*  - alphabetic (often used for back matter such as appendices)
	*
	* @note
	* There is no default numbering style; if no 'S' (Style) entry is present,
	* page labels consist solely of a label prefix with no numeric portion.
	*/
		PDFNet.PageLabel.prototype.setStyle = function(style)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStyle'. Expected "+1+" argument. Function Signature: setStyle(number)")};
		if(style instanceof Promise) {throw new TypeError("1st input argument in function 'setStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof style != "number") {throw new TypeError("1st input argument '"+style+"' in function 'setStyle' is of type '"+(typeof style)+"'. Expected type 'number'. Function Signature: setStyle(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setStyle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.setStyle"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.setStyle', {"l": this, "style": style}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to page numbering style.
	*/
		PDFNet.PageLabel.prototype.getStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStyle'. Expected "+0+" arguments. Function Signature: getStyle()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStyle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getStyle', {"l": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the string used to prefix the numeric portion of
	* the page label
	*/
		PDFNet.PageLabel.prototype.getPrefix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPrefix'. Expected "+0+" arguments. Function Signature: getPrefix()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getPrefix'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getPrefix', {"l": this}, this.userPriority);
	},

	/**
	* @param prefix the string used to prefix the numeric portion of
	* the page label.
	*/
		PDFNet.PageLabel.prototype.setPrefix = function(prefix)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrefix'. Expected "+1+" argument. Function Signature: setPrefix(string)")};
		if(prefix instanceof Promise) {throw new TypeError("1st input argument in function 'setPrefix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof prefix != "string") {throw new TypeError("1st input argument '"+prefix+"' in function 'setPrefix' is of type '"+(typeof prefix)+"'. Expected type 'string'. Function Signature: setPrefix(string).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setPrefix'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.setPrefix"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.setPrefix', {"l": this, "prefix": prefix}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the value to use when generating the numeric portion of
	* the first label in this range; must be greater than or equal to 1.
	*/
		PDFNet.PageLabel.prototype.getStart = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStart'. Expected "+0+" arguments. Function Signature: getStart()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStart'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getStart', {"l": this}, this.userPriority);
	},

	/**
	* @param start_at the value to use when generating the numeric
	* portion of the first label in this range; must be greater than
	* or equal to 1.
	*/
		PDFNet.PageLabel.prototype.setStart = function(start_at)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setStart'. Expected "+1+" argument. Function Signature: setStart(number)")};
		if(start_at instanceof Promise) {throw new TypeError("1st input argument in function 'setStart' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_at != "number") {throw new TypeError("1st input argument '"+start_at+"' in function 'setStart' is of type '"+(typeof start_at)+"'. Expected type 'number'. Function Signature: setStart(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'setStart'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.setStart"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.setStart', {"l": this, "start_at": start_at}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the first page in the range associated with this label
	* or -1 if the label is not associated with any page.
	*/
		PDFNet.PageLabel.prototype.getFirstPageNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFirstPageNum'. Expected "+0+" arguments. Function Signature: getFirstPageNum()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFirstPageNum'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.getFirstPageNum"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getFirstPageNum', {"l": this}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* @return A promise that resolves to the last page in the range associated with this label
	* or -1 if the label is not associated with any page.
	*/
		PDFNet.PageLabel.prototype.getLastPageNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLastPageNum'. Expected "+0+" arguments. Function Signature: getLastPageNum()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getLastPageNum'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "PageLabel.getLastPageNum"; // TRN_PageLabel* l
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getLastPageNum', {"l": this}, this.userPriority).then(function(id){
			copyFunc(id.l, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.PageLabel.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getSDFObj'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('PageLabel.getSDFObj', {"l": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Default constructor. Constructs 'PageSet' with no pages
	*/
		PDFNet.PageSet.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('pageSetCreate', {}, this.userPriority).then(function(id){
			//there is a return type PageSet
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageSet(id);
		});
	},

	/**
	* Construct a set of pages with just one number
	*
	* @see AddPage
	*/
		PDFNet.PageSet.createSinglePage = function(one_page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createSinglePage'. Expected "+1+" argument. Function Signature: createSinglePage(number)")};
		if(one_page instanceof Promise) {throw new TypeError("1st input argument in function 'createSinglePage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof one_page != "number") {throw new TypeError("1st input argument '"+one_page+"' in function 'createSinglePage' is of type '"+(typeof one_page)+"'. Expected type 'number'. Function Signature: createSinglePage(number).");}
		return PDFNet.messageHandler.sendWithPromise('pageSetCreateSinglePage', {"one_page": one_page}, this.userPriority).then(function(id){
			//there is a return type PageSet
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageSet(id);
		});
	},

		PDFNet.PageSet.createRange = function(range_start, range_end)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'createRange'. Expected "+2+" arguments. Function Signature: createRange(number, number)")};
		if(range_start instanceof Promise) {throw new TypeError("1st input argument in function 'createRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_start != "number") {throw new TypeError("1st input argument '"+range_start+"' in function 'createRange' is of type '"+(typeof range_start)+"'. Expected type 'number'. Function Signature: createRange(number, number).");}
		if(range_end instanceof Promise) {throw new TypeError("2nd input argument in function 'createRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_end != "number") {throw new TypeError("2nd input argument '"+range_end+"' in function 'createRange' is of type '"+(typeof range_end)+"'. Expected type 'number'. Function Signature: createRange(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageSetCreateRange', {"range_start": range_start, "range_end": range_end}, this.userPriority).then(function(id){
			//there is a return type PageSet
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageSet(id);
		});
	},

	/**
	* Construct a range of pages
	*
	* @see AddRange
	*/
		PDFNet.PageSet.createFilteredRange = function(range_start, range_end, filter)
	{
		if(typeof filter === "undefined") {filter = exports.PDFNet.PageSet.Filter.e_all};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createFilteredRange'. Expected "+2+" to "+3+" arguments. Function Signature: createFilteredRange(number, number, number)")};
		if(range_start instanceof Promise) {throw new TypeError("1st input argument in function 'createFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_start != "number") {throw new TypeError("1st input argument '"+range_start+"' in function 'createFilteredRange' is of type '"+(typeof range_start)+"'. Expected type 'number'. Function Signature: createFilteredRange(number, number, number).");}
		if(range_end instanceof Promise) {throw new TypeError("2nd input argument in function 'createFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_end != "number") {throw new TypeError("2nd input argument '"+range_end+"' in function 'createFilteredRange' is of type '"+(typeof range_end)+"'. Expected type 'number'. Function Signature: createFilteredRange(number, number, number).");}
		if(filter instanceof Promise) {throw new TypeError("3rd input argument in function 'createFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filter != "number") {throw new TypeError("3rd input argument '"+filter+"' in function 'createFilteredRange' is of type '"+(typeof filter)+"'. Expected type 'number'. Function Signature: createFilteredRange(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('pageSetCreateFilteredRange', {"range_start": range_start, "range_end": range_end, "filter": filter}, this.userPriority).then(function(id){
			//there is a return type PageSet
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageSet(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.PageSet.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PageSet.destroy', {"page_set": this.id}, this.userPriority);
	},

	/**
	* Add a value to the sequence.
	*
	* @param one_page The page number being added
	*/
		PDFNet.PageSet.prototype.addPage = function(one_page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addPage'. Expected "+1+" argument. Function Signature: addPage(number)")};
		if(one_page instanceof Promise) {throw new TypeError("1st input argument in function 'addPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof one_page != "number") {throw new TypeError("1st input argument '"+one_page+"' in function 'addPage' is of type '"+(typeof one_page)+"'. Expected type 'number'. Function Signature: addPage(number).");}
		return PDFNet.messageHandler.sendWithPromise('PageSet.addPage', {"page_set": this.id, "one_page": one_page}, this.userPriority);
	},

		PDFNet.PageSet.prototype.addRange = function(range_start, range_end)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addRange'. Expected "+2+" arguments. Function Signature: addRange(number, number)")};
		if(range_start instanceof Promise) {throw new TypeError("1st input argument in function 'addRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_start != "number") {throw new TypeError("1st input argument '"+range_start+"' in function 'addRange' is of type '"+(typeof range_start)+"'. Expected type 'number'. Function Signature: addRange(number, number).");}
		if(range_end instanceof Promise) {throw new TypeError("2nd input argument in function 'addRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_end != "number") {throw new TypeError("2nd input argument '"+range_end+"' in function 'addRange' is of type '"+(typeof range_end)+"'. Expected type 'number'. Function Signature: addRange(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PageSet.addRange', {"page_set": this.id, "range_start": range_start, "range_end": range_end}, this.userPriority);
	},

		PDFNet.PageSet.prototype.addFilteredRange = function(range_start, range_end, filter)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'addFilteredRange'. Expected "+3+" arguments. Function Signature: addFilteredRange(number, number, number)")};
		if(range_start instanceof Promise) {throw new TypeError("1st input argument in function 'addFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_start != "number") {throw new TypeError("1st input argument '"+range_start+"' in function 'addFilteredRange' is of type '"+(typeof range_start)+"'. Expected type 'number'. Function Signature: addFilteredRange(number, number, number).");}
		if(range_end instanceof Promise) {throw new TypeError("2nd input argument in function 'addFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof range_end != "number") {throw new TypeError("2nd input argument '"+range_end+"' in function 'addFilteredRange' is of type '"+(typeof range_end)+"'. Expected type 'number'. Function Signature: addFilteredRange(number, number, number).");}
		if(filter instanceof Promise) {throw new TypeError("3rd input argument in function 'addFilteredRange' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filter != "number") {throw new TypeError("3rd input argument '"+filter+"' in function 'addFilteredRange' is of type '"+(typeof filter)+"'. Expected type 'number'. Function Signature: addFilteredRange(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PageSet.addFilteredRange', {"page_set": this.id, "range_start": range_start, "range_end": range_end, "filter": filter}, this.userPriority);
	},

	/**
	* Create a PatternColor from the given SDF/Cos object listed under Pattern entry
	* in page Resource dictionary
	*/
		PDFNet.PatternColor.create = function(pattern)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.Obj)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+pattern.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'create' is of type '"+(typeof pattern)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('patternColorCreate', {"pattern": pattern.id}, this.userPriority).then(function(id){
			//there is a return type PatternColor
			if(id == "0"){
				return null;
			}
			return new PDFNet.PatternColor(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.PatternColor.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.destroy', {"pattern": this.id}, this.userPriority);
	},

		PDFNet.PatternColor.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(PatternColor)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.PatternColor)) {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'PatternColor'. Function Signature: assign(PatternColor).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'PatternColor'. Function Signature: assign(PatternColor).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PatternColor.assign', {"left": this.id, "right": right.id}, this.userPriority);
	},

		PDFNet.PatternColor.getTypeFromObj = function(pattern)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTypeFromObj'. Expected "+1+" argument. Function Signature: getTypeFromObj(Obj)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'getTypeFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pattern instanceof PDFNet.Obj)) {
			if(typeof pattern == "object") {throw new TypeError("1st input argument in function 'getTypeFromObj' is of type '"+pattern.name+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+pattern+"' in function 'getTypeFromObj' is of type '"+(typeof pattern)+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('patternColorGetTypeFromObj', {"pattern": pattern.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the pattern type
	*/
		PDFNet.PatternColor.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getType', {"pc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object
	*/
		PDFNet.PatternColor.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getSDFObj', {"pc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to pattern matrix, a transformation matrix that maps the pattern's
	* internal coordinate system to the default coordinate system of the pattern's
	* parent content stream (the content stream in which the pattern is defined as
	* a resource). The concatenation of the pattern matrix with that of the parent content
	* stream establishes the pattern coordinate space, within which all graphics objects
	* in the pattern are interpreted.
	*/
		PDFNet.PatternColor.prototype.getMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMatrix'. Expected "+0+" arguments. Function Signature: getMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getMatrix', {"pc": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

	/**
	* @return A promise that resolves to the shading object defining the shading pattern's gradient fill.
	*
	* @note for patterns other than Shading this method throws an exception.
	*/
		PDFNet.PatternColor.prototype.getShading = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getShading'. Expected "+0+" arguments. Function Signature: getShading()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getShading', {"pc": this.id}, this.userPriority).then(function(id){
			//there is a return type Shading
			if(id == "0"){
				return null;
			}
			return new PDFNet.Shading(id);
		});
	},

	/**
	* @return A promise that resolves to the tiling type identifier that controls adjustments to the spacing
	* of tiles relative to the device pixel grid:
	*
	* @note for patterns other than Tiling this method throws an exception.
	*/
		PDFNet.PatternColor.prototype.getTilingType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTilingType'. Expected "+0+" arguments. Function Signature: getTilingType()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getTilingType', {"pc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a rectangle in the pattern coordinate system giving the
	* coordinates of the left, bottom, right, and top edges, respectively,
	* of the pattern cell's bounding box. These boundaries are used to clip
	* the pattern cell.
	*
	* @note for patterns other than Tiling this method throws an exception.
	*/
		PDFNet.PatternColor.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getBBox', {"pc": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* @return A promise that resolves to the desired horizontal spacing between pattern cells, measured
	* in the pattern coordinate system.
	*
	* @note that XStep and YStep may differ from the dimensions of the pattern
	* cell implied by the BBox entry. This allows tiling with irregularly shaped
	* figures. XStep and YStep may be either positive or negative, but not zero.
	*
	* @note for patterns other than Tiling this method throws an exception.
	*/
		PDFNet.PatternColor.prototype.getXStep = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getXStep'. Expected "+0+" arguments. Function Signature: getXStep()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getXStep', {"pc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the desired vertical spacing between pattern cells, measured in
	* the pattern coordinate system.
	*
	* @note for patterns other than Tiling this method throws an exception.
	*/
		PDFNet.PatternColor.prototype.getYStep = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getYStep'. Expected "+0+" arguments. Function Signature: getYStep()")};
		return PDFNet.messageHandler.sendWithPromise('PatternColor.getYStep', {"pc": this.id}, this.userPriority);
	},

		PDFNet.downloadComplete = function(data, start_byte, size, cont)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'downloadComplete'. Expected "+4+" arguments. Function Signature: downloadComplete(string, number, number, DownloadContainer)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'downloadComplete' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'downloadComplete' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: downloadComplete(string, number, number, DownloadContainer).");}
		if(start_byte instanceof Promise) {throw new TypeError("2nd input argument in function 'downloadComplete' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_byte != "number") {throw new TypeError("2nd input argument '"+start_byte+"' in function 'downloadComplete' is of type '"+(typeof start_byte)+"'. Expected type 'number'. Function Signature: downloadComplete(string, number, number, DownloadContainer).");}
		if(size instanceof Promise) {throw new TypeError("3rd input argument in function 'downloadComplete' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("3rd input argument '"+size+"' in function 'downloadComplete' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: downloadComplete(string, number, number, DownloadContainer).");}
		if(cont instanceof Promise) {throw new TypeError("4th input argument in function 'downloadComplete' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(cont instanceof PDFNet.DownloadContainer)) {
			if(typeof cont == "object") {throw new TypeError("4th input argument in function 'downloadComplete' is of type '"+cont.name+"'. Expected type 'DownloadContainer'. Function Signature: downloadComplete(string, number, number, DownloadContainer).");}
			else {throw new TypeError("4th input argument '"+cont+"' in function 'downloadComplete' is of type '"+(typeof cont)+"'. Expected type 'DownloadContainer'. Function Signature: downloadComplete(string, number, number, DownloadContainer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('downloadComplete', {"data": data, "start_byte": start_byte, "size": size, "cont": cont.id}, this.userPriority);
	},

		PDFNet.PDFDoc.createWithDownloader = function(callbacks, file_size)
	{
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'createWithDownloader'. Expected "+1+" to "+2+" arguments. Function Signature: createWithDownloader(void*, number)")};
		// [UNKNOWNTYPE] Cannot match type TRN_DownloadCallbacks(TRN_DownloadCallbacks*) from callbacks
		if(file_size instanceof Promise) {throw new TypeError("2nd input argument in function 'createWithDownloader' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_size != "number") {throw new TypeError("2nd input argument '"+file_size+"' in function 'createWithDownloader' is of type '"+(typeof file_size)+"'. Expected type 'number'. Function Signature: createWithDownloader(void*, number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateWithDownloader', {"callbacks": callbacks, "file_size": file_size}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

		PDFNet.PDFDoc.prototype.hasDownloader = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasDownloader'. Expected "+0+" arguments. Function Signature: hasDownloader()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.hasDownloader', {"doc": this.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.downloadPages = function(pages_arr, pages_arr_size, cancel_others, download_thumbs)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'downloadPages'. Expected "+4+" arguments. Function Signature: downloadPages(number, number, boolean, boolean)")};
		if(pages_arr instanceof Promise) {throw new TypeError("1st input argument in function 'downloadPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pages_arr != "number") {throw new TypeError("1st input argument '"+pages_arr+"' in function 'downloadPages' is of type '"+(typeof pages_arr)+"'. Expected type 'number'. Function Signature: downloadPages(number, number, boolean, boolean).");}
		if(pages_arr_size instanceof Promise) {throw new TypeError("2nd input argument in function 'downloadPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pages_arr_size != "number") {throw new TypeError("2nd input argument '"+pages_arr_size+"' in function 'downloadPages' is of type '"+(typeof pages_arr_size)+"'. Expected type 'number'. Function Signature: downloadPages(number, number, boolean, boolean).");}
		if(cancel_others instanceof Promise) {throw new TypeError("3rd input argument in function 'downloadPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof cancel_others != "boolean") {throw new TypeError("3rd input argument '"+cancel_others+"' in function 'downloadPages' is of type '"+(typeof cancel_others)+"'. Expected type 'boolean'. Function Signature: downloadPages(number, number, boolean, boolean).");}
		if(download_thumbs instanceof Promise) {throw new TypeError("4th input argument in function 'downloadPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof download_thumbs != "boolean") {throw new TypeError("4th input argument '"+download_thumbs+"' in function 'downloadPages' is of type '"+(typeof download_thumbs)+"'. Expected type 'boolean'. Function Signature: downloadPages(number, number, boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.downloadPages', {"doc": this.id, "pages_arr": pages_arr, "pages_arr_size": pages_arr_size, "cancel_others": cancel_others, "download_thumbs": download_thumbs}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.downloadThumb = function(page_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'downloadThumb'. Expected "+1+" argument. Function Signature: downloadThumb(number)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'downloadThumb' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'downloadThumb' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: downloadThumb(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.downloadThumb', {"doc": this.id, "page_num": page_num}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Default constructor. Creates an empty new document.
	*/
		PDFNet.PDFDoc.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreate', {}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

	/**
	* Create a PDF document from an existing SDF/Cos document.
	*
	* @param sdfdoc a pointer to the SDF document. Created PDFDoc will
	* take the ownership of the low-level document.
	*
	* @note the SDFDoc will become invalid.  If you would
	* like to access the low level document use GetSDFDoc
	*/
		PDFNet.PDFDoc.createFromSDFDoc = function(sdfdoc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromSDFDoc'. Expected "+1+" argument. Function Signature: createFromSDFDoc(SDFDoc)")};
		if(sdfdoc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromSDFDoc' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(sdfdoc instanceof PDFNet.PDFDoc || sdfdoc instanceof PDFNet.SDFDoc)) {
			if(typeof sdfdoc == "object") {throw new TypeError("1st input argument in function 'createFromSDFDoc' is of type '"+sdfdoc.name+"'. Expected type 'SDFDoc'. Function Signature: createFromSDFDoc(SDFDoc).");}
			else {throw new TypeError("1st input argument '"+sdfdoc+"' in function 'createFromSDFDoc' is of type '"+(typeof sdfdoc)+"'. Expected type 'SDFDoc'. Function Signature: createFromSDFDoc(SDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromSDFDoc', {"sdfdoc": sdfdoc.id}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

	/**
	* Open an existing PDF document
	*
	* @param filepath - pathname to the file.
	*
	* @note Make sure to call InitSecurityHandler() after PDFDoc(...) in case
	* a document is encrypted
	*/
		PDFNet.PDFDoc.createFromUFilePath = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromUFilePath'. Expected "+1+" argument. Function Signature: createFromUFilePath(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromUFilePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromUFilePath' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromUFilePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromUFilePath', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

		PDFNet.PDFDoc.createFromFilePath = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFilePath'. Expected "+1+" argument. Function Signature: createFromFilePath(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFilePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromFilePath' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromFilePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromFilePath', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

	/**
	* Open an existing PDF document
	*
	* @param stream - input stream containing a serialized document. The input stream may be a
	* random-access file, memory buffer, slow HTTP connection etc.
	*
	* @note if the input stream doesn't support Seek() operation the document will load whole
	* data stream in memory before parsing. In case of linearized PDF, the document may be parsed
	* on-the-fly while it is being loaded in memory. Note that since MappedFile implements Seek()
	* interface, the document does not have to be fully in memory before it is used.
	*
	* @note Make sure to call InitSecurityHandler() after PDFDoc(...) for encrypted documents.
	* @note PDFDoc takes the ownership of the stream.
	*/
		PDFNet.PDFDoc.createFromFilter = function(stream)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFilter'. Expected "+1+" argument. Function Signature: createFromFilter(Filter)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Filter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'createFromFilter' is of type '"+stream.name+"'. Expected type 'Filter'. Function Signature: createFromFilter(Filter).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'createFromFilter' is of type '"+(typeof stream)+"'. Expected type 'Filter'. Function Signature: createFromFilter(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromFilter', {"stream": stream.id}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

		PDFNet.PDFDoc.createFromBuffer = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromBuffer'. Expected "+1+" argument. Function Signature: createFromBuffer(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'createFromBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'createFromBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromBuffer', {"buf": buf.buffer}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	},

		PDFNet.PDFDoc.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.destroy', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the document is/was originally encrypted false otherwise.
	*/
		PDFNet.PDFDoc.prototype.isEncrypted = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isEncrypted'. Expected "+0+" arguments. Function Signature: isEncrypted()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.isEncrypted', {"doc": this.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.initSecurityHandler = function(custom_data)
	{
		if(typeof custom_data === "undefined") {custom_data = 0;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'initSecurityHandler'. Expected at most "+1+" arguments. Function Signature: initSecurityHandler(void*)")};
		// [UNKNOWNTYPE] Cannot match type void(void*) from custom_data
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.initSecurityHandler', {"doc": this.id, "custom_data": custom_data}, this.userPriority);
	},

	/**
	* Initializes document's SecurityHandler using the supplied
	* password. This version of InitSecurityHandler() assumes that
	* document uses Standard security and that a password is specified
	* directly.
	*
	* This function should be called immediately after an encrypted
	* document is opened. The function does not have any side effects on
	* documents that are not encrypted.
	*
	* If the security handler was successfully initialized, it can be later
	* obtained using GetSecurityHandler() method.
	*
	* @return A promise that resolves to true if the given password successfully unlocked the document,
	* false otherwise.
	*
	* @exception An exception is thrown if the document's security Filter is
	* not 'Standard'. In this case, you need to register additional custom
	* security handlers with the global SecurityManager (SecurityManagerSingleton).
	*
	* @param password Specifies the password used to open the document without
	* any user feedback. If you would like to dynamically obtain the password,
	* you need to derive a custom class from StdSecurityHandler() and use
	* InitSecurityHandler() without any parameters. See EncTest sample
	* for example code.
	*
	* @param password_len An optional parameter used to specify the size of
	* the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter
	* is not specified, the function assumes that the string is null terminated.
	*/
		PDFNet.PDFDoc.prototype.initStdSecurityHandler = function(password, password_sz)
	{
		if(typeof password_sz === "undefined") {password_sz = 0;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'initStdSecurityHandler'. Expected "+1+" to "+2+" arguments. Function Signature: initStdSecurityHandler(string, number)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'initStdSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'initStdSecurityHandler' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: initStdSecurityHandler(string, number).");}
		if(password_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'initStdSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password_sz != "number") {throw new TypeError("2nd input argument '"+password_sz+"' in function 'initStdSecurityHandler' is of type '"+(typeof password_sz)+"'. Expected type 'number'. Function Signature: initStdSecurityHandler(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.initStdSecurityHandler', {"doc": this.id, "password": password, "password_sz": password_sz}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected SecurityHandler.
	*
	* @note InitSecurityHandler() should be called before GetSecurityHandler()
	* in order to initialize the handler.
	*
	* @note Returned security handler can be modified in order to change the
	* security settings of the existing document. Changes to the current handler
	* will not invalidate the access to the original file and will take effect
	* during document Save().
	*
	* @note If the security handler is modified, document will perform a full save
	* even if e_incremental was given as a flag in Save() method.
	*/
		PDFNet.PDFDoc.prototype.getSecurityHandler = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSecurityHandler'. Expected "+0+" arguments. Function Signature: getSecurityHandler()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getSecurityHandler', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

	/**
	* The function sets a new SecurityHandler as the current security handler.
	*
	* @param - new SecurityHandler
	*
	* @note Setting a new security handler will not invalidate the access to
	* the original file and will take effect during document Save().
	*
	* @note If the security handler is modified, document will perform a full save
	* even if e_incremental was given as a flag in Save() method.
	*/
		PDFNet.PDFDoc.prototype.setSecurityHandler = function(handler)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSecurityHandler'. Expected "+1+" argument. Function Signature: setSecurityHandler(SecurityHandler)")};
		if(handler instanceof Promise) {throw new TypeError("1st input argument in function 'setSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(handler instanceof PDFNet.SecurityHandler)) {
			if(typeof handler == "object") {throw new TypeError("1st input argument in function 'setSecurityHandler' is of type '"+handler.name+"'. Expected type 'SecurityHandler'. Function Signature: setSecurityHandler(SecurityHandler).");}
			else {throw new TypeError("1st input argument '"+handler+"' in function 'setSecurityHandler' is of type '"+(typeof handler)+"'. Expected type 'SecurityHandler'. Function Signature: setSecurityHandler(SecurityHandler).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.setSecurityHandler', {"doc": this.id, "handler": handler.id}, this.userPriority);
	},

	/**
	* This function removes document security.
	*/
		PDFNet.PDFDoc.prototype.removeSecurity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'removeSecurity'. Expected "+0+" arguments. Function Signature: removeSecurity()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.removeSecurity', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the class representing document information metadata.
	* (i.e. entries in the document information dictionary).
	*/
		PDFNet.PDFDoc.prototype.getDocInfo = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDocInfo'. Expected "+0+" arguments. Function Signature: getDocInfo()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getDocInfo', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocInfo
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocInfo(id);
		});
	},

	/**
	* @return A promise that resolves to viewer preferences for this document.
	*
	* PDFDocViewPrefs is a high-level utility class that can be
	* used to control the way the document is to be presented on
	* the screen or in print.
	*/
		PDFNet.PDFDoc.prototype.getViewPrefs = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getViewPrefs'. Expected "+0+" arguments. Function Signature: getViewPrefs()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getViewPrefs', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocViewPrefs
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocViewPrefs(id);
		});
	},

	/**
	* Call this function to determine whether the document has been modified since
	* it was last saved.
	*
	* @return A promise that resolves to - true if document was modified, false otherwise
	*/
		PDFNet.PDFDoc.prototype.isModified = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isModified'. Expected "+0+" arguments. Function Signature: isModified()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.isModified', {"doc": this.id}, this.userPriority);
	},

	/**
	* Call this function to determine whether the document is represented in
	* linearized (fast web view) format.
	*
	* @return A promise that resolves to - true if document is stored in fast web view format, false otherwise.
	*
	* @note any changes to the document can invalidate linearization. The function will
	* return 'true' only if the original document is linearized and if it is not
	* modified.
	*
	* In order to provide good performance over relatively slow communication links,
	* PDFNet can generate PDF documents with linearized objects and hint tables that
	* can allow a PDF viewer application to download and view one page of a PDF file
	* at a time, rather than requiring the entire file (including fonts and images) to
	* be downloaded before any of it can be viewed.
	*
	* To save a document in linearized (fast web view) format you only need to pass
	* 'Doc.SaveOptions.e_linearized' flag in the Save method.
	*/
		PDFNet.PDFDoc.prototype.isLinearized = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isLinearized'. Expected "+0+" arguments. Function Signature: isLinearized()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.isLinearized', {"doc": this.id}, this.userPriority);
	},

	/**
	* Saves the document to a file.
	*
	* If a full save is requested to the original path, the file is saved to a file
	* system-determined temporary file, the old file is deleted, and the temporary file
	* is renamed to path.
	*
	* A full save with remove unused or linearization option may re-arrange object in
	* the cross reference table. Therefore all pointers and references to document objects
	* and resources should be re acquired in order to continue document editing.
	*
	* In order to use incremental save the specified path must match original path and
	* e_incremental flag bit should be set.
	*
	* @param path - The full path name to which the file is saved.
	* @param flags - A bit field composed of an OR of SDFDoc::SaveOptions values.
	* @param progress - A pointer to the progress interface. NULL if progress tracking is not required.
	*
	* @exception - if the file can't be opened for saving or if there is a problem during Save
	*	an Exception object will be thrown.
	*
	* @note - Save will modify the PDFDoc object's internal representation.  As such,
	*			  the user should acquire a write lock before calling save.
	*/
		PDFNet.PDFDoc.prototype.save = function(path, flags)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'save'. Expected "+2+" arguments. Function Signature: save(string, number)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'save' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: save(string, number).");}
		if(flags instanceof Promise) {throw new TypeError("2nd input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("2nd input argument '"+flags+"' in function 'save' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: save(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.save', {"doc": this.id, "path": path, "flags": flags}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.saveMemoryBuffer = function(flags)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'saveMemoryBuffer'. Expected "+1+" argument. Function Signature: saveMemoryBuffer(number)")};
		if(flags instanceof Promise) {throw new TypeError("1st input argument in function 'saveMemoryBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("1st input argument '"+flags+"' in function 'saveMemoryBuffer' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: saveMemoryBuffer(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.saveMemoryBuffer', {"doc": this.id, "flags": flags}, this.userPriority).then(function(id){
			return new Uint8Array(id);
		});
	},

	/**
	* Saves the document to a stream.
	*
	* @param stream The output stream where to write data.
	* @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
	* @param progress - A pointer to the progress interface. NULL if progress tracking is not required.
	* @param header - File header. A new file header is set only during full save. See also GetHeader()
	*
	* @exception - if there is a problem during Save an Exception object will be thrown.
	*
	* @note - Save will modify the PDFDoc object's internal representation.  As such,
	*			  the user should acquire a write lock before calling save.
	*/
		PDFNet.PDFDoc.prototype.saveStream = function(stream, flags)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'saveStream'. Expected "+2+" arguments. Function Signature: saveStream(Filter, number)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'saveStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Filter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'saveStream' is of type '"+stream.name+"'. Expected type 'Filter'. Function Signature: saveStream(Filter, number).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'saveStream' is of type '"+(typeof stream)+"'. Expected type 'Filter'. Function Signature: saveStream(Filter, number).");}
		}
		if(flags instanceof Promise) {throw new TypeError("2nd input argument in function 'saveStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("2nd input argument '"+flags+"' in function 'saveStream' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: saveStream(Filter, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.saveStream', {"doc": this.id, "stream": stream.id, "flags": flags}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an iterator to the first page in the document.
	* Use the Next() method on the returned iterator to traverse all pages in the document.
	* For example:
	* @code
	*   PageIterator itr = pdfdoc.GetPageIterator();
	*   while (itr.HasNext()) { //  Read every page
	*      Page page = itr.Current();
	*      // ...
	*      itr.Next()
	*   }
	* @endcode
	*
	* For full sample code, please take a look at ElementReader, PDFPageTest and PDFDraw sample projects.
	*/
		PDFNet.PDFDoc.prototype.getPageIterator = function(page_number)
	{
		if(typeof page_number === "undefined") {page_number = 1;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPageIterator'. Expected at most "+1+" arguments. Function Signature: getPageIterator(number)")};
		if(page_number instanceof Promise) {throw new TypeError("1st input argument in function 'getPageIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_number != "number") {throw new TypeError("1st input argument '"+page_number+"' in function 'getPageIterator' is of type '"+(typeof page_number)+"'. Expected type 'number'. Function Signature: getPageIterator(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPageIterator', {"doc": this.id, "page_number": page_number}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* @param page_number - the page number in document's page sequence. Page numbers
	* in document's page sequence are indexed from 1.
	*
	* @return A promise that resolves to a Page corresponding to a given page number, or null (invalid page)
	* if the document does not contain the given page number.
	*
	* For example:
	* @code
	*   Page page = pdfdoc.GetPage(page_num);
	*   if (page == null) return; //  Page not found
	* @endcode
	*/
		PDFNet.PDFDoc.prototype.getPage = function(page_number)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPage'. Expected "+1+" argument. Function Signature: getPage(number)")};
		if(page_number instanceof Promise) {throw new TypeError("1st input argument in function 'getPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_number != "number") {throw new TypeError("1st input argument '"+page_number+"' in function 'getPage' is of type '"+(typeof page_number)+"'. Expected type 'number'. Function Signature: getPage(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPage', {"doc": this.id, "page_number": page_number}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

	/**
	* @param page_itr - the PageIterator to the page that should be removed
	* A PageIterator for the given page can be obtained using PDFDoc::Find(page_num)
	* or using direct iteration through document's page sequence.
	*/
		PDFNet.PDFDoc.prototype.pageRemove = function(page_itr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pageRemove'. Expected "+1+" argument. Function Signature: pageRemove(Iterator)")};
		if(page_itr instanceof Promise) {throw new TypeError("1st input argument in function 'pageRemove' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_itr instanceof PDFNet.Iterator)) {
			if(typeof page_itr == "object") {throw new TypeError("1st input argument in function 'pageRemove' is of type '"+page_itr.name+"'. Expected type 'Iterator'. Function Signature: pageRemove(Iterator).");}
			else {throw new TypeError("1st input argument '"+page_itr+"' in function 'pageRemove' is of type '"+(typeof page_itr)+"'. Expected type 'Iterator'. Function Signature: pageRemove(Iterator).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.pageRemove', {"doc": this.id, "page_itr": page_itr.id}, this.userPriority);
	},

	/**
	* Insert/Import a single page at a specific location in the page sequence.
	*
	* @param where - The location in the page sequence indicating where to insert
	* the page. The page is inserted before the specified location.
	*
	* @param page - A page to insert.
	* @note Invalidates all PageIterators pointing to the document.
	*/
		PDFNet.PDFDoc.prototype.pageInsert = function(where, page)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'pageInsert'. Expected "+2+" arguments. Function Signature: pageInsert(Iterator, Page)")};
		if(where instanceof Promise) {throw new TypeError("1st input argument in function 'pageInsert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(where instanceof PDFNet.Iterator)) {
			if(typeof where == "object") {throw new TypeError("1st input argument in function 'pageInsert' is of type '"+where.name+"'. Expected type 'Iterator'. Function Signature: pageInsert(Iterator, Page).");}
			else {throw new TypeError("1st input argument '"+where+"' in function 'pageInsert' is of type '"+(typeof where)+"'. Expected type 'Iterator'. Function Signature: pageInsert(Iterator, Page).");}
		}
		if(page instanceof Promise) {throw new TypeError("2nd input argument in function 'pageInsert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("2nd input argument in function 'pageInsert' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: pageInsert(Iterator, Page).");}
			else {throw new TypeError("2nd input argument '"+page+"' in function 'pageInsert' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: pageInsert(Iterator, Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.pageInsert', {"doc": this.id, "where": where.id, "page": page.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.insertPages = function(insert_before_page_number, src_doc, start_page, end_page, flag)
	{
		if(typeof flag === "undefined") {flag = 0;};
		if((arguments.length < 4) || (arguments.length > 5)) {throw new RangeError(arguments.length+" arguments passed into function 'insertPages'. Expected "+4+" to "+5+" arguments. Function Signature: insertPages(number, PDFDoc, number, number, number)")};
		if(insert_before_page_number instanceof Promise) {throw new TypeError("1st input argument in function 'insertPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof insert_before_page_number != "number") {throw new TypeError("1st input argument '"+insert_before_page_number+"' in function 'insertPages' is of type '"+(typeof insert_before_page_number)+"'. Expected type 'number'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
		if(src_doc instanceof Promise) {throw new TypeError("2nd input argument in function 'insertPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(src_doc instanceof PDFNet.PDFDoc || src_doc instanceof PDFNet.SDFDoc)) {
			if(typeof src_doc == "object") {throw new TypeError("2nd input argument in function 'insertPages' is of type '"+src_doc.name+"'. Expected type 'PDFDoc'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
			else {throw new TypeError("2nd input argument '"+src_doc+"' in function 'insertPages' is of type '"+(typeof src_doc)+"'. Expected type 'PDFDoc'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
		}
		if(start_page instanceof Promise) {throw new TypeError("3rd input argument in function 'insertPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_page != "number") {throw new TypeError("3rd input argument '"+start_page+"' in function 'insertPages' is of type '"+(typeof start_page)+"'. Expected type 'number'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
		if(end_page instanceof Promise) {throw new TypeError("4th input argument in function 'insertPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof end_page != "number") {throw new TypeError("4th input argument '"+end_page+"' in function 'insertPages' is of type '"+(typeof end_page)+"'. Expected type 'number'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
		if(flag instanceof Promise) {throw new TypeError("5th input argument in function 'insertPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("5th input argument '"+flag+"' in function 'insertPages' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: insertPages(number, PDFDoc, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.insertPages', {"dest_doc": this.id, "insert_before_page_number": insert_before_page_number, "src_doc": src_doc.id, "start_page": start_page, "end_page": end_page, "flag": flag}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.insertPageSet = function(insert_before_page_number, src_doc, source_page_set, flag)
	{
		if(typeof flag === "undefined") {flag = 0;};
		if((arguments.length < 3) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'insertPageSet'. Expected "+3+" to "+4+" arguments. Function Signature: insertPageSet(number, PDFDoc, PageSet, number)")};
		if(insert_before_page_number instanceof Promise) {throw new TypeError("1st input argument in function 'insertPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof insert_before_page_number != "number") {throw new TypeError("1st input argument '"+insert_before_page_number+"' in function 'insertPageSet' is of type '"+(typeof insert_before_page_number)+"'. Expected type 'number'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
		if(src_doc instanceof Promise) {throw new TypeError("2nd input argument in function 'insertPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(src_doc instanceof PDFNet.PDFDoc || src_doc instanceof PDFNet.SDFDoc)) {
			if(typeof src_doc == "object") {throw new TypeError("2nd input argument in function 'insertPageSet' is of type '"+src_doc.name+"'. Expected type 'PDFDoc'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
			else {throw new TypeError("2nd input argument '"+src_doc+"' in function 'insertPageSet' is of type '"+(typeof src_doc)+"'. Expected type 'PDFDoc'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
		}
		if(source_page_set instanceof Promise) {throw new TypeError("3rd input argument in function 'insertPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(source_page_set instanceof PDFNet.PageSet)) {
			if(typeof source_page_set == "object") {throw new TypeError("3rd input argument in function 'insertPageSet' is of type '"+source_page_set.name+"'. Expected type 'PageSet'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
			else {throw new TypeError("3rd input argument '"+source_page_set+"' in function 'insertPageSet' is of type '"+(typeof source_page_set)+"'. Expected type 'PageSet'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
		}
		if(flag instanceof Promise) {throw new TypeError("4th input argument in function 'insertPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("4th input argument '"+flag+"' in function 'insertPageSet' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: insertPageSet(number, PDFDoc, PageSet, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.insertPageSet', {"dest_doc": this.id, "insert_before_page_number": insert_before_page_number, "src_doc": src_doc.id, "source_page_set": source_page_set.id, "flag": flag}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.movePages = function(move_before_page_number, src_doc, start_page, end_page, flag)
	{
		if(typeof flag === "undefined") {flag = 0;};
		if((arguments.length < 4) || (arguments.length > 5)) {throw new RangeError(arguments.length+" arguments passed into function 'movePages'. Expected "+4+" to "+5+" arguments. Function Signature: movePages(number, PDFDoc, number, number, number)")};
		if(move_before_page_number instanceof Promise) {throw new TypeError("1st input argument in function 'movePages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof move_before_page_number != "number") {throw new TypeError("1st input argument '"+move_before_page_number+"' in function 'movePages' is of type '"+(typeof move_before_page_number)+"'. Expected type 'number'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
		if(src_doc instanceof Promise) {throw new TypeError("2nd input argument in function 'movePages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(src_doc instanceof PDFNet.PDFDoc || src_doc instanceof PDFNet.SDFDoc)) {
			if(typeof src_doc == "object") {throw new TypeError("2nd input argument in function 'movePages' is of type '"+src_doc.name+"'. Expected type 'PDFDoc'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
			else {throw new TypeError("2nd input argument '"+src_doc+"' in function 'movePages' is of type '"+(typeof src_doc)+"'. Expected type 'PDFDoc'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
		}
		if(start_page instanceof Promise) {throw new TypeError("3rd input argument in function 'movePages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_page != "number") {throw new TypeError("3rd input argument '"+start_page+"' in function 'movePages' is of type '"+(typeof start_page)+"'. Expected type 'number'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
		if(end_page instanceof Promise) {throw new TypeError("4th input argument in function 'movePages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof end_page != "number") {throw new TypeError("4th input argument '"+end_page+"' in function 'movePages' is of type '"+(typeof end_page)+"'. Expected type 'number'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
		if(flag instanceof Promise) {throw new TypeError("5th input argument in function 'movePages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("5th input argument '"+flag+"' in function 'movePages' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: movePages(number, PDFDoc, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.movePages', {"dest_doc": this.id, "move_before_page_number": move_before_page_number, "src_doc": src_doc.id, "start_page": start_page, "end_page": end_page, "flag": flag}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.movePageSet = function(move_before_page_number, src_doc, source_page_set, flag)
	{
		if(typeof flag === "undefined") {flag = 0;};
		if((arguments.length < 3) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'movePageSet'. Expected "+3+" to "+4+" arguments. Function Signature: movePageSet(number, PDFDoc, PageSet, number)")};
		if(move_before_page_number instanceof Promise) {throw new TypeError("1st input argument in function 'movePageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof move_before_page_number != "number") {throw new TypeError("1st input argument '"+move_before_page_number+"' in function 'movePageSet' is of type '"+(typeof move_before_page_number)+"'. Expected type 'number'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
		if(src_doc instanceof Promise) {throw new TypeError("2nd input argument in function 'movePageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(src_doc instanceof PDFNet.PDFDoc || src_doc instanceof PDFNet.SDFDoc)) {
			if(typeof src_doc == "object") {throw new TypeError("2nd input argument in function 'movePageSet' is of type '"+src_doc.name+"'. Expected type 'PDFDoc'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
			else {throw new TypeError("2nd input argument '"+src_doc+"' in function 'movePageSet' is of type '"+(typeof src_doc)+"'. Expected type 'PDFDoc'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
		}
		if(source_page_set instanceof Promise) {throw new TypeError("3rd input argument in function 'movePageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(source_page_set instanceof PDFNet.PageSet)) {
			if(typeof source_page_set == "object") {throw new TypeError("3rd input argument in function 'movePageSet' is of type '"+source_page_set.name+"'. Expected type 'PageSet'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
			else {throw new TypeError("3rd input argument '"+source_page_set+"' in function 'movePageSet' is of type '"+(typeof source_page_set)+"'. Expected type 'PageSet'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
		}
		if(flag instanceof Promise) {throw new TypeError("4th input argument in function 'movePageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("4th input argument '"+flag+"' in function 'movePageSet' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: movePageSet(number, PDFDoc, PageSet, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.movePageSet', {"dest_doc": this.id, "move_before_page_number": move_before_page_number, "src_doc": src_doc.id, "source_page_set": source_page_set.id, "flag": flag}, this.userPriority);
	},

	/**
	* Adds a page to the beginning of a document's page sequence.
	* @param page - a page to prepend to the document
	* Invalidates all PageIterators pointing to the document.
	*/
		PDFNet.PDFDoc.prototype.pagePushFront = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pagePushFront'. Expected "+1+" argument. Function Signature: pagePushFront(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'pagePushFront' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'pagePushFront' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: pagePushFront(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'pagePushFront' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: pagePushFront(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.pagePushFront', {"doc": this.id, "page": page.id}, this.userPriority);
	},

	/**
	* Adds a page to the end of a document's page sequence.
	* @param page - a page to append to the document
	* @note Invalidates all PageIterators pointing to the document.
	*/
		PDFNet.PDFDoc.prototype.pagePushBack = function(page)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pagePushBack'. Expected "+1+" argument. Function Signature: pagePushBack(Page)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'pagePushBack' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'pagePushBack' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: pagePushBack(Page).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'pagePushBack' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: pagePushBack(Page).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.pagePushBack', {"doc": this.id, "page": page.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.importPages = function(page_buf, import_bookmarks, buf_result)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'importPages'. Expected "+3+" arguments. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer)")};
		if(page_buf instanceof Promise) {throw new TypeError("1st input argument in function 'importPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_buf.buffer instanceof ArrayBuffer)) {
			if(typeof page_buf == "object") {throw new TypeError("1st input argument in function 'importPages' is of type '"+page_buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+page_buf+"' in function 'importPages' is of type '"+(typeof page_buf)+"'. Expected type 'ArrayBuffer'. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer).");}
		}
		if(import_bookmarks instanceof Promise) {throw new TypeError("3rd input argument in function 'importPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof import_bookmarks != "boolean") {throw new TypeError("3rd input argument '"+import_bookmarks+"' in function 'importPages' is of type '"+(typeof import_bookmarks)+"'. Expected type 'boolean'. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer).");}
		if(buf_result instanceof Promise) {throw new TypeError("4th input argument in function 'importPages' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_result.buffer instanceof ArrayBuffer)) {
			if(typeof buf_result == "object") {throw new TypeError("4th input argument in function 'importPages' is of type '"+buf_result.name+"'. Expected type 'ArrayBuffer'. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer).");}
			else {throw new TypeError("4th input argument '"+buf_result+"' in function 'importPages' is of type '"+(typeof buf_result)+"'. Expected type 'ArrayBuffer'. Function Signature: importPages(ArrayBuffer, boolean, ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.importPages', {"doc": this.id, "page_buf": page_buf.buffer, "import_bookmarks": import_bookmarks, "buf_result": buf_result.buffer}, this.userPriority);
	},

	/**
	* Create a new, empty page in the document. You can use PageWriter to fill the
	* page with new content. Finally the page should be inserted at specific
	* place within document page sequence using PageInsert/PagePushFront/PagePushBack
	* methods.
	*
	* @return A promise that resolves to a new, empty page.
	*
	* @note the new page still does not belong to document page sequence and should be
	* subsequently placed at a specific location within the sequence.
	*
	* @param media_box A rectangle, expressed in default user space units, defining
	* the boundaries of the physical medium on which the page is intended to be
	* displayed or printed. A user space units is 1/72 of an inch. If media_box is
	* not specified the default dimensions of the page are 8.5 x 11 inches (or
	* 8.5*72, 11*72 units).
	*
	* <p>The following is a listing of some standard U.S. page sizes:</p>
	*  <ul>
	*    <li>Letter    = Rect(0, 0, 612, 792)
	*    <li>Legal	    = Rect(0, 0, 612, 1008)
	*    <li>Ledger	= Rect(0, 0, 1224, 792)
	*    <li>Tabloid   = Rect(0, 0, 792, 1224)
	*    <li>Executive	= Rect(0, 0, 522, 756)
	* </ul>
	*
	* <p>The following is a listing of ISO standard page sizes:</p>
	*  <ul>
	*    <li> 4A0 = Rect(0, 0, 4768, 6741)
	*    <li> 2A0 = Rect(0, 0, 3370, 4768)
	*    <li> A0 =  Rect(0, 0, 2384, 3370)
	*    <li> A1 =  Rect(0, 0, 1684, 2384)
	*    <li> A2 =  Rect(0, 0, 1191, 1684)
	*    <li> A3 =  Rect(0, 0, 842,  1191)
	*    <li> A4 =  Rect(0, 0, 595,  842)
	*    <li> A5 =  Rect(0, 0, 420,  595)
	*    <li> A6 =  Rect(0, 0, 298,  420)
	*    <li> A7 =  Rect(0, 0, 210,  298)
	*    <li> A8 =  Rect(0, 0, 147,  210)
	*    <li> A9 =  Rect(0, 0, 105,  147)
	*    <li> A10 = Rect(0, 0, 74,   105)
	*    <li> B0 =  Rect(0, 0, 2835, 4008)
	*    <li> B1 =  Rect(0, 0, 2004, 2835)
	*    <li> B2 =  Rect(0, 0, 1417, 2004)
	*    <li> B3 =  Rect(0, 0, 1001, 1417)
	*    <LI> B4 =  Rect(0, 0, 709,  1001)
	*    <LI> B5 =  Rect(0, 0, 499,  709)
	*    <LI> B6 =  Rect(0, 0, 354,  499)
	*    <LI> B7 =  Rect(0, 0, 249,  354)
	*    <LI> B8 =  Rect(0, 0, 176,  249)
	*    <LI> B9 =  Rect(0, 0, 125,  176)
	*    <li> B10 = Rect(0, 0, 88,   125)
	*    <li> C0 =  Rect(0, 0, 2599, 3677)
	*    <li> C1 =  Rect(0, 0, 1837, 2599)
	*    <li> C2 =  Rect(0, 0, 1298, 1837)
	*    <li> C3 =  Rect(0, 0, 918,  1298)
	*    <li> C4 =  Rect(0, 0, 649,  918)
	*    <li> C5 =  Rect(0, 0, 459,  649)
	*    <li> C6 =  Rect(0, 0, 323,  459)
	*    <li> C7 =  Rect(0, 0, 230,  323)
	*    <li> C8 =  Rect(0, 0, 162,  230)
	*    <li> C9 =  Rect(0, 0, 113,  162)
	*    <li>C10 =  Rect(0, 0, 79,   113)
	* </ul>
	*/
		PDFNet.PDFDoc.prototype.pageCreate = function(media_box)
	{
		if(typeof media_box === "undefined") {media_box = new PDFNet.Rect(0, 0, 612, 792);};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'pageCreate'. Expected at most "+1+" arguments. Function Signature: pageCreate(Rect)")};
		if(media_box instanceof Promise) {throw new TypeError("1st input argument in function 'pageCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(media_box instanceof PDFNet.Rect) && media_box.name != "Rect") {
			if(typeof media_box == "object") {throw new TypeError("1st input argument in function 'pageCreate' is of type '"+media_box.name+"'. Expected type 'Rect'. Function Signature: pageCreate(Rect).");}
			else {throw new TypeError("1st input argument '"+media_box+"' in function 'pageCreate' is of type '"+(typeof media_box)+"'. Expected type 'Rect'. Function Signature: pageCreate(Rect).");}
		}
		if(typeof media_box.yieldFunction != "undefined") {throw new Error("Function '"+media_box.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'pageCreate'. Perhaps a yield statement is required for '"+media_box.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.pageCreate', {"doc": this.id, "media_box": media_box}, this.userPriority).then(function(id){
			//there is a return type Page
			if(id == "0"){
				return null;
			}
			return new PDFNet.Page(id);
		});
	},

	/**
	* @return A promise that resolves to - the first Bookmark from the document's outline tree. If the
	* Bookmark tree is empty the underlying SDF/Cos Object is null and returned
	* Bookmark is not valid (i.e. Bookmark::IsValid() returns false).
	*/
		PDFNet.PDFDoc.prototype.getFirstBookmark = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFirstBookmark'. Expected "+0+" arguments. Function Signature: getFirstBookmark()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getFirstBookmark', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Bookmark
			if(id == "0"){
				return null;
			}
			return new PDFNet.Bookmark(id);
		});
	},

	/**
	* Adds/links the specified Bookmark to the root level of document's outline tree.
	* @note parameter 'root_bookmark' must not be linked (must not be belong) to
	* a bookmark tree.
	*/
		PDFNet.PDFDoc.prototype.addRootBookmark = function(root_bookmark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addRootBookmark'. Expected "+1+" argument. Function Signature: addRootBookmark(Bookmark)")};
		if(root_bookmark instanceof Promise) {throw new TypeError("1st input argument in function 'addRootBookmark' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(root_bookmark instanceof PDFNet.Bookmark)) {
			if(typeof root_bookmark == "object") {throw new TypeError("1st input argument in function 'addRootBookmark' is of type '"+root_bookmark.name+"'. Expected type 'Bookmark'. Function Signature: addRootBookmark(Bookmark).");}
			else {throw new TypeError("1st input argument '"+root_bookmark+"' in function 'addRootBookmark' is of type '"+(typeof root_bookmark)+"'. Expected type 'Bookmark'. Function Signature: addRootBookmark(Bookmark).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.addRootBookmark', {"doc": this.id, "root_bookmark": root_bookmark.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - A dictionary representing the Cos root of the document (document's trailer)
	*/
		PDFNet.PDFDoc.prototype.getTrailer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTrailer'. Expected "+0+" arguments. Function Signature: getTrailer()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getTrailer', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to - A dictionary representing the Cos root of the document (/Root entry
	* within the trailer dictionary)
	*/
		PDFNet.PDFDoc.prototype.getRoot = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRoot'. Expected "+0+" arguments. Function Signature: getRoot()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getRoot', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to - A dictionary representing the root of the low level page-tree
	*/
		PDFNet.PDFDoc.prototype.getPages = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPages'. Expected "+0+" arguments. Function Signature: getPages()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPages', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the number of pages in the document.
	*/
		PDFNet.PDFDoc.prototype.getPageCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPageCount'. Expected "+0+" arguments. Function Signature: getPageCount()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPageCount', {"doc": this.id}, this.userPriority);
	},

	/**
	* An interactive form (sometimes referred to as an AcroForm) is a
	* collection of fields for gathering information interactively from
	* the user. A PDF document may contain any number of fields appearing
	* on any combination of pages, all of which make up a single, global
	* interactive form spanning the entire document.
	*
	* The following methods are used to access and manipulate Interactive form
	* fields (sometimes referred to as AcroForms).
	*
	* @return A promise that resolves to an iterator to the first Field in the document.
	*
	* The list of all Fields present in the document can be traversed as follows:
	* @code
	* FieldIterator itr = pdfdoc.GetFieldIterator();
	* for(; itr.HasNext(); itr.Next()) {
	*   Field field = itr.Current();
	*   Console.WriteLine("Field name: {0}", field.GetName());
	*  }
	* @endcode
	*
	* For a full sample, please refer to 'InteractiveForms' sample project.
	*/
		PDFNet.PDFDoc.prototype.getFieldIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIteratorBegin'. Expected "+0+" arguments. Function Signature: getFieldIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getFieldIteratorBegin', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

	/**
	* field_name - a string representing the fully qualified name of
	* the field (e.g. "employee.name.first").
	*
	* @return A promise that resolves to a FieldIterator referring to an interactive Field
	* or to invalid field if the field name was not found. If a given field name was
	* not found itr.HasNext() will return false. For example:
	*
	* @code
	* FieldIterator itr = pdfdoc.FieldFind("name");
	* if (itr.HasNext()) {
	*   Console.WriteLine("Field name: {0}", itr.Current().GetName());
	* }
	* else { ...field was not found... }
	* @endcode
	*/
		PDFNet.PDFDoc.prototype.getFieldIterator = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIterator'. Expected "+1+" argument. Function Signature: getFieldIterator(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getFieldIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'getFieldIterator' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: getFieldIterator(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getFieldIterator', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

		PDFNet.PDFDoc.prototype.getField = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getField'. Expected "+1+" argument. Function Signature: getField(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getField' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'getField' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: getField(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getField', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			//there is a return type Field
			if(id == "0"){
				return null;
			}
			return new PDFNet.Field(id);
		});
	},

	/**
	* Create a new interactive form Field.
	* @return A promise that resolves to the new form Field.
	*
	* @param field_name a string representing the fully qualified name of the
	* field (e.g. "employee.name.first"). field_name must be either a unique name or
	* equal to an existing terminal field name.
	* @param type field type (e.g. Field::e_text, Field::e_button, etc.)
	* @param field_value
	* @param def_field_value
	*
	* @exception if 'field_name' is equal to an existing non-terminal field name an
	* exception is thrown.
	*/
		PDFNet.PDFDoc.prototype.fieldCreate = function(field_name, type, field_value, def_field_value)
	{
		if(typeof field_value === "undefined") {field_value = new PDFNet.Obj("0");};
		if(typeof def_field_value === "undefined") {def_field_value = new PDFNet.Obj("0");};
		if((arguments.length < 2) || (arguments.length > 4)) {throw new RangeError(arguments.length+" arguments passed into function 'fieldCreate'. Expected "+2+" to "+4+" arguments. Function Signature: fieldCreate(string, number, Obj, Obj)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'fieldCreate' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'fieldCreate' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
		if(field_value instanceof Promise) {throw new TypeError("3rd input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(field_value instanceof PDFNet.Obj)) {
			if(typeof field_value == "object") {throw new TypeError("3rd input argument in function 'fieldCreate' is of type '"+field_value.name+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
			else {throw new TypeError("3rd input argument '"+field_value+"' in function 'fieldCreate' is of type '"+(typeof field_value)+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
		}
		if(def_field_value instanceof Promise) {throw new TypeError("4th input argument in function 'fieldCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(def_field_value instanceof PDFNet.Obj)) {
			if(typeof def_field_value == "object") {throw new TypeError("4th input argument in function 'fieldCreate' is of type '"+def_field_value.name+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
			else {throw new TypeError("4th input argument '"+def_field_value+"' in function 'fieldCreate' is of type '"+(typeof def_field_value)+"'. Expected type 'Obj'. Function Signature: fieldCreate(string, number, Obj, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.fieldCreate', {"doc": this.id, "field_name": field_name, "type": type, "field_value": field_value.id, "def_field_value": def_field_value.id}, this.userPriority).then(function(id){
			//there is a return type Field
			if(id == "0"){
				return null;
			}
			return new PDFNet.Field(id);
		});
	},

		PDFNet.PDFDoc.prototype.fieldCreateFromStrings = function(field_name, type, field_value, def_field_value)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'fieldCreateFromStrings'. Expected "+4+" arguments. Function Signature: fieldCreateFromStrings(string, number, string, string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'fieldCreateFromStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+field_name+"' in function 'fieldCreateFromStrings' is of type '"+(typeof field_name)+"'. Expected type 'string'. Function Signature: fieldCreateFromStrings(string, number, string, string).");}
		if(type instanceof Promise) {throw new TypeError("2nd input argument in function 'fieldCreateFromStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("2nd input argument '"+type+"' in function 'fieldCreateFromStrings' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: fieldCreateFromStrings(string, number, string, string).");}
		if(field_value instanceof Promise) {throw new TypeError("3rd input argument in function 'fieldCreateFromStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_value != "string") {throw new TypeError("3rd input argument '"+field_value+"' in function 'fieldCreateFromStrings' is of type '"+(typeof field_value)+"'. Expected type 'string'. Function Signature: fieldCreateFromStrings(string, number, string, string).");}
		if(def_field_value instanceof Promise) {throw new TypeError("4th input argument in function 'fieldCreateFromStrings' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof def_field_value != "string") {throw new TypeError("4th input argument '"+def_field_value+"' in function 'fieldCreateFromStrings' is of type '"+(typeof def_field_value)+"'. Expected type 'string'. Function Signature: fieldCreateFromStrings(string, number, string, string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.fieldCreateFromStrings', {"doc": this.id, "field_name": field_name, "type": type, "field_value": field_value, "def_field_value": def_field_value}, this.userPriority).then(function(id){
			//there is a return type Field
			if(id == "0"){
				return null;
			}
			return new PDFNet.Field(id);
		});
	},

	/**
	* Regenerates the appearance stream for every widget annotation in the document
	* Call this method if you modified field's value and would like to update
	* field's appearances.
	*/
		PDFNet.PDFDoc.prototype.refreshFieldAppearances = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'refreshFieldAppearances'. Expected "+0+" arguments. Function Signature: refreshFieldAppearances()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.refreshFieldAppearances', {"doc": this.id}, this.userPriority);
	},

	/**
	* Flatten all annotations in the document.
	* @param forms_only if false flatten all annotations, otherwise flatten
	* only form fields.
	*/
		PDFNet.PDFDoc.prototype.flattenAnnotations = function(forms_only)
	{
		if(typeof forms_only === "undefined") {forms_only = false;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'flattenAnnotations'. Expected at most "+1+" arguments. Function Signature: flattenAnnotations(boolean)")};
		if(forms_only instanceof Promise) {throw new TypeError("1st input argument in function 'flattenAnnotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof forms_only != "boolean") {throw new TypeError("1st input argument '"+forms_only+"' in function 'flattenAnnotations' is of type '"+(typeof forms_only)+"'. Expected type 'boolean'. Function Signature: flattenAnnotations(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.flattenAnnotations', {"doc": this.id, "forms_only": forms_only}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.flattenAnnotationsAdvanced = function(flags)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'flattenAnnotationsAdvanced'. Expected "+1+" argument. Function Signature: flattenAnnotationsAdvanced(number)")};
		if(flags instanceof Promise) {throw new TypeError("1st input argument in function 'flattenAnnotationsAdvanced' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("1st input argument '"+flags+"' in function 'flattenAnnotationsAdvanced' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: flattenAnnotationsAdvanced(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.flattenAnnotationsAdvanced', {"doc": this.id, "flags": flags}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the AcroForm dictionary located in "/Root" or NULL if dictionary is not present.
	*/
		PDFNet.PDFDoc.prototype.getAcroForm = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAcroForm'. Expected "+0+" arguments. Function Signature: getAcroForm()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getAcroForm', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Extract form data and/or annotations to FDF
	* @param flag - specifies extract options
	* @return A promise that resolves to a pointer to the newly created FDF file with an interactive data.
	*/
		PDFNet.PDFDoc.prototype.fdfExtract = function(flag)
	{
		if(typeof flag === "undefined") {flag = exports.PDFNet.PDFDoc.ExtractFlag.e_forms_only};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'fdfExtract'. Expected at most "+1+" arguments. Function Signature: fdfExtract(number)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'fdfExtract' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("1st input argument '"+flag+"' in function 'fdfExtract' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: fdfExtract(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.fdfExtract', {"doc": this.id, "flag": flag}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Extract form data and/or annotations to FDF
	* @param pages_to_extract The set of pages for which to extract interactive data.
	* @param flag - specifies extract options
	* @return A promise that resolves to a pointer to the newly created FDF file with an interactive data.
	*/
		PDFNet.PDFDoc.prototype.fdfExtractPageSet = function(pages_to_extract, flag)
	{
		if(typeof flag === "undefined") {flag = exports.PDFNet.PDFDoc.ExtractFlag.e_forms_only};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'fdfExtractPageSet'. Expected "+1+" to "+2+" arguments. Function Signature: fdfExtractPageSet(PageSet, number)")};
		if(pages_to_extract instanceof Promise) {throw new TypeError("1st input argument in function 'fdfExtractPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pages_to_extract instanceof PDFNet.PageSet)) {
			if(typeof pages_to_extract == "object") {throw new TypeError("1st input argument in function 'fdfExtractPageSet' is of type '"+pages_to_extract.name+"'. Expected type 'PageSet'. Function Signature: fdfExtractPageSet(PageSet, number).");}
			else {throw new TypeError("1st input argument '"+pages_to_extract+"' in function 'fdfExtractPageSet' is of type '"+(typeof pages_to_extract)+"'. Expected type 'PageSet'. Function Signature: fdfExtractPageSet(PageSet, number).");}
		}
		if(flag instanceof Promise) {throw new TypeError("2nd input argument in function 'fdfExtractPageSet' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "number") {throw new TypeError("2nd input argument '"+flag+"' in function 'fdfExtractPageSet' is of type '"+(typeof flag)+"'. Expected type 'number'. Function Signature: fdfExtractPageSet(PageSet, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.fdfExtractPageSet', {"doc": this.id, "pages_to_extract": pages_to_extract.id, "flag": flag}, this.userPriority).then(function(id){
			//there is a return type FDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.FDFDoc(id);
		});
	},

	/**
	* Import form data from FDF file to PDF interactive form.
	* @param fdf_doc - a pointer to the FDF file
	*/
		PDFNet.PDFDoc.prototype.fdfMerge = function(fdf_doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'fdfMerge'. Expected "+1+" argument. Function Signature: fdfMerge(FDFDoc)")};
		if(fdf_doc instanceof Promise) {throw new TypeError("1st input argument in function 'fdfMerge' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(fdf_doc instanceof PDFNet.FDFDoc)) {
			if(typeof fdf_doc == "object") {throw new TypeError("1st input argument in function 'fdfMerge' is of type '"+fdf_doc.name+"'. Expected type 'FDFDoc'. Function Signature: fdfMerge(FDFDoc).");}
			else {throw new TypeError("1st input argument '"+fdf_doc+"' in function 'fdfMerge' is of type '"+(typeof fdf_doc)+"'. Expected type 'FDFDoc'. Function Signature: fdfMerge(FDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.fdfMerge', {"doc": this.id, "fdf_doc": fdf_doc.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to action that is triggered when the document is opened.
	* The returned action can be either a destination or some other kind
	* of Action (see Section 8.5, 'Actions' in PDF Reference Manual).
	*
	* @note if the document does not nave associated action the returned Action
	* will be null (i.e. Action.IsValid() returns false)
	*/
		PDFNet.PDFDoc.prototype.getOpenAction = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOpenAction'. Expected "+0+" arguments. Function Signature: getOpenAction()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getOpenAction', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Action
			if(id == "0"){
				return null;
			}
			return new PDFNet.Action(id);
		});
	},

	/**
	* Sets the Action that will be triggered when the document is opened.
	*
	* @param action A new Action that will be triggered when the document is opened.
	* An example of such action is a GoTo Action that takes the user to a given
	* location in the document.
	*/
		PDFNet.PDFDoc.prototype.setOpenAction = function(action)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpenAction'. Expected "+1+" argument. Function Signature: setOpenAction(Action)")};
		if(action instanceof Promise) {throw new TypeError("1st input argument in function 'setOpenAction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(action instanceof PDFNet.Action)) {
			if(typeof action == "object") {throw new TypeError("1st input argument in function 'setOpenAction' is of type '"+action.name+"'. Expected type 'Action'. Function Signature: setOpenAction(Action).");}
			else {throw new TypeError("1st input argument '"+action+"' in function 'setOpenAction' is of type '"+(typeof action)+"'. Expected type 'Action'. Function Signature: setOpenAction(Action).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.setOpenAction', {"doc": this.id, "action": action.id}, this.userPriority);
	},

	/**
	* Associates a file attachment with the document.
	*
	* The file attachment will be displayed in the user interface of a viewer application
	* (in Acrobat this is File Attachment tab). The function differs from
	* Annot.CreateFileAttachment() because it associates the attachment with the
	* whole document instead of an annotation on a specific page.
	*
	* @param file_key A key/name under which the attachment will be stored.
	* @param embedded_file Embedded file stream
	*
	* @note Another way to associate a file attachment with the document is using SDF::NameTree:
	* @code
	*   SDF::NameTree names = SDF::NameTree::Create(doc, "EmbeddedFiles");
	*   names.Put(file_key, file_keysz, embedded_file.GetSDFObj());
	* @endcode
	*/
		PDFNet.PDFDoc.prototype.addFileAttachment = function(file_key, embeded_file)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addFileAttachment'. Expected "+2+" arguments. Function Signature: addFileAttachment(string, FileSpec)")};
		if(file_key instanceof Promise) {throw new TypeError("1st input argument in function 'addFileAttachment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof file_key != "string") {throw new TypeError("1st input argument '"+file_key+"' in function 'addFileAttachment' is of type '"+(typeof file_key)+"'. Expected type 'string'. Function Signature: addFileAttachment(string, FileSpec).");}
		if(embeded_file instanceof Promise) {throw new TypeError("2nd input argument in function 'addFileAttachment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(embeded_file instanceof PDFNet.FileSpec)) {
			if(typeof embeded_file == "object") {throw new TypeError("2nd input argument in function 'addFileAttachment' is of type '"+embeded_file.name+"'. Expected type 'FileSpec'. Function Signature: addFileAttachment(string, FileSpec).");}
			else {throw new TypeError("2nd input argument '"+embeded_file+"' in function 'addFileAttachment' is of type '"+(typeof embeded_file)+"'. Expected type 'FileSpec'. Function Signature: addFileAttachment(string, FileSpec).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.addFileAttachment', {"doc": this.id, "file_key": file_key, "embeded_file": embeded_file.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the PageLabel that is in effect for the given page.
	* If there is no label object in effect, this method returns an
	* invalid page label object.
	*
	* @param page_num The page number. Because PDFNet indexes pages
	* starting from 1, page_num must be larger than 0.
	*/
		PDFNet.PDFDoc.prototype.getPageLabel = function(page_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPageLabel'. Expected "+1+" argument. Function Signature: getPageLabel(number)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'getPageLabel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'getPageLabel' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: getPageLabel(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPageLabel', {"doc": this.id, "page_num": page_num}, this.userPriority).then(function(id){
			//there is a return type PageLabel
			if(id == "0"){
				return null;
			}
			return new PDFNet.PageLabel(id);
		});
	},

	/**
	* attaches a label to a page. This establishes the numbering scheme
	* for that page and all following it, until another page label is
	* encountered. This label allows PDF producers to define a page
	* numbering system other than the default.
	*
	* @param page_num The number of the page to label. If page_num is
	* less than 1 or greater than the number of pages in the document,
	* the method does nothing.
	*/
		PDFNet.PDFDoc.prototype.setPageLabel = function(page_num, label)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPageLabel'. Expected "+2+" arguments. Function Signature: setPageLabel(number, PageLabel)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'setPageLabel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'setPageLabel' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: setPageLabel(number, PageLabel).");}
		if(label instanceof Promise) {throw new TypeError("2nd input argument in function 'setPageLabel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(label instanceof PDFNet.PageLabel) && label.name != "PageLabel") {
			if(typeof label == "object") {throw new TypeError("2nd input argument in function 'setPageLabel' is of type '"+label.name+"'. Expected type 'PageLabel'. Function Signature: setPageLabel(number, PageLabel).");}
			else {throw new TypeError("2nd input argument '"+label+"' in function 'setPageLabel' is of type '"+(typeof label)+"'. Expected type 'PageLabel'. Function Signature: setPageLabel(number, PageLabel).");}
		}
		if(typeof label.yieldFunction != "undefined") {throw new Error("Function '"+label.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'setPageLabel'. Perhaps a yield statement is required for '"+label.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "PDFDoc.setPageLabel"; // TRN_PageLabel* label
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.setPageLabel', {"doc": this.id, "page_num": page_num, "label": label}, this.userPriority).then(function(id){
			copyFunc(id.label, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* removes the page label that is attached to the specified page,
	* effectively merging the specified range with the previous page
	* label sequence.
	*
	* @param page_num The page from which the page label is removed.
	* Because PDFNet indexes pages starting from 1, page_num must be
	* larger than 0.
	*/
		PDFNet.PDFDoc.prototype.removePageLabel = function(page_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'removePageLabel'. Expected "+1+" argument. Function Signature: removePageLabel(number)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'removePageLabel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'removePageLabel' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: removePageLabel(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.removePageLabel', {"doc": this.id, "page_num": page_num}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the document's logical structure tree root.
	*/
		PDFNet.PDFDoc.prototype.getStructTree = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStructTree'. Expected "+0+" arguments. Function Signature: getStructTree()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getStructTree', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type STree
			if(id == "0"){
				return null;
			}
			return new PDFNet.STree(id);
		});
	},

	/**
	* @return A promise that resolves to true if the optional content (OC) feature is associated with
	* the document. The document is considered to have optional content if
	* there is an OCProperties dictionary in the document's catalog, and
	* that dictionary has one or more entries in the OCGs array.
	*/
		PDFNet.PDFDoc.prototype.hasOC = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasOC'. Expected "+0+" arguments. Function Signature: hasOC()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.hasOC', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Obj array that contains optional-content groups (OCGs) for
	* the document, or NULL if the document does not contain any OCGs. The
	* order of the groups is not guaranteed to be the creation order, and is
	* not the same as the display order.
	*/
		PDFNet.PDFDoc.prototype.getOCGs = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOCGs'. Expected "+0+" arguments. Function Signature: getOCGs()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getOCGs', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the default optional-content configuration for the document
	* from the OCProperties D entry.
	*/
		PDFNet.PDFDoc.prototype.getOCGConfig = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOCGConfig'. Expected "+0+" arguments. Function Signature: getOCGConfig()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getOCGConfig', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type OCGConfig
			if(id == "0"){
				return null;
			}
			return new PDFNet.OCGConfig(id);
		});
	},

	/**
	* The following list of methods is used to create SDF/Cos indirect objects.
	*
	* Unlike direct objects, indirect objects can be referenced by more than one
	* object (i.e. indirect objects they can be shared).
	*
	*/
		PDFNet.PDFDoc.prototype.createIndirectName = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectName'. Expected "+1+" argument. Function Signature: createIndirectName(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'createIndirectName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: createIndirectName(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectName', {"doc": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectArray'. Expected "+0+" arguments. Function Signature: createIndirectArray()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectArray', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectBool = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectBool'. Expected "+1+" argument. Function Signature: createIndirectBool(boolean)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("1st input argument '"+value+"' in function 'createIndirectBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: createIndirectBool(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectBool', {"doc": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectDict'. Expected "+0+" arguments. Function Signature: createIndirectDict()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectDict', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectNull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectNull'. Expected "+0+" arguments. Function Signature: createIndirectNull()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectNull', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectNumber = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectNumber'. Expected "+1+" argument. Function Signature: createIndirectNumber(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'createIndirectNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: createIndirectNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectNumber', {"doc": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectString = function(buf_value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectString'. Expected "+1+" argument. Function Signature: createIndirectString(ArrayBuffer)")};
		if(buf_value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_value.buffer instanceof ArrayBuffer)) {
			if(typeof buf_value == "object") {throw new TypeError("1st input argument in function 'createIndirectString' is of type '"+buf_value.name+"'. Expected type 'ArrayBuffer'. Function Signature: createIndirectString(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf_value+"' in function 'createIndirectString' is of type '"+(typeof buf_value)+"'. Expected type 'ArrayBuffer'. Function Signature: createIndirectString(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectString', {"doc": this.id, "buf_value": buf_value.buffer}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectStringFromUString = function(str)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStringFromUString'. Expected "+1+" argument. Function Signature: createIndirectStringFromUString(string)")};
		if(str instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStringFromUString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof str != "string") {throw new TypeError("1st input argument '"+str+"' in function 'createIndirectStringFromUString' is of type '"+(typeof str)+"'. Expected type 'string'. Function Signature: createIndirectStringFromUString(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectStringFromUString', {"doc": this.id, "str": str}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectStreamFromFilter = function(data, filter_chain)
	{
		if(typeof filter_chain === "undefined") {filter_chain = new PDFNet.Filter("0");};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStreamFromFilter'. Expected "+1+" to "+2+" arguments. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStreamFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(data instanceof PDFNet.FilterReader)) {
			if(typeof data == "object") {throw new TypeError("1st input argument in function 'createIndirectStreamFromFilter' is of type '"+data.name+"'. Expected type 'FilterReader'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
			else {throw new TypeError("1st input argument '"+data+"' in function 'createIndirectStreamFromFilter' is of type '"+(typeof data)+"'. Expected type 'FilterReader'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
		}
		if(filter_chain instanceof Promise) {throw new TypeError("2nd input argument in function 'createIndirectStreamFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter_chain instanceof PDFNet.Filter)) {
			if(typeof filter_chain == "object") {throw new TypeError("2nd input argument in function 'createIndirectStreamFromFilter' is of type '"+filter_chain.name+"'. Expected type 'Filter'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
			else {throw new TypeError("2nd input argument '"+filter_chain+"' in function 'createIndirectStreamFromFilter' is of type '"+(typeof filter_chain)+"'. Expected type 'Filter'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectStreamFromFilter', {"doc": this.id, "data": data.id, "filter_chain": filter_chain.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.PDFDoc.prototype.createIndirectStream = function(data, data_size, filter_chain)
	{
		if(typeof filter_chain === "undefined") {filter_chain = new PDFNet.Filter("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStream'. Expected "+2+" to "+3+" arguments. Function Signature: createIndirectStream(string, number, Filter)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'createIndirectStream' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: createIndirectStream(string, number, Filter).");}
		if(data_size instanceof Promise) {throw new TypeError("2nd input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data_size != "number") {throw new TypeError("2nd input argument '"+data_size+"' in function 'createIndirectStream' is of type '"+(typeof data_size)+"'. Expected type 'number'. Function Signature: createIndirectStream(string, number, Filter).");}
		if(filter_chain instanceof Promise) {throw new TypeError("3rd input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter_chain instanceof PDFNet.Filter)) {
			if(typeof filter_chain == "object") {throw new TypeError("3rd input argument in function 'createIndirectStream' is of type '"+filter_chain.name+"'. Expected type 'Filter'. Function Signature: createIndirectStream(string, number, Filter).");}
			else {throw new TypeError("3rd input argument '"+filter_chain+"' in function 'createIndirectStream' is of type '"+(typeof filter_chain)+"'. Expected type 'Filter'. Function Signature: createIndirectStream(string, number, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.createIndirectStream', {"doc": this.id, "data": data, "data_size": data_size, "filter_chain": filter_chain.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to document's SDF/Cos document
	*/
		PDFNet.PDFDoc.prototype.getSDFDoc = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFDoc'. Expected "+0+" arguments. Function Signature: getSDFDoc()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getSDFDoc', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

	/**
	* Locks the document to prevent competing threads from accessing the document
	* at the same time. Threads attempting to access the document will wait in
	* suspended state until the thread that owns the lock calls doc.Unlock().
	*/
		PDFNet.PDFDoc.prototype.lock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'lock'. Expected "+0+" arguments. Function Signature: lock()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.lock', {"doc": this.id}, this.userPriority);
	},

	/**
	* Removes the lock from the document.
	*/
		PDFNet.PDFDoc.prototype.unlock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'unlock'. Expected "+0+" arguments. Function Signature: unlock()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.unlock', {"doc": this.id}, this.userPriority);
	},

	/**
	* Locks the document to prevent competing write threads (using Lock()) from accessing the document
	* at the same time. Other reader threads however, will be allowed to access the document.
	* Threads attempting to obtain write access to the document will wait in
	* suspended state until the thread that owns the lock calls doc.UnlockRead().
	* Note: To avoid deadlocks obtaining a write lock while holding
	* a read lock is not permitted and will throw an exception. If this situation is encountered
	* please either unlock the read lock before the write lock is obtained
	* or acquire a write lock (rather than read lock) in the first place.
	*/
		PDFNet.PDFDoc.prototype.lockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'lockRead'. Expected "+0+" arguments. Function Signature: lockRead()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.lockRead', {"doc": this.id}, this.userPriority);
	},

	/**
	* Removes the read lock from the document.
	*/
		PDFNet.PDFDoc.prototype.unlockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'unlockRead'. Expected "+0+" arguments. Function Signature: unlockRead()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.unlockRead', {"doc": this.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.tryLock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tryLock'. Expected "+0+" arguments. Function Signature: tryLock()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.tryLock', {"doc": this.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.timedLock = function(milliseconds)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'timedLock'. Expected "+1+" argument. Function Signature: timedLock(number)")};
		if(milliseconds instanceof Promise) {throw new TypeError("1st input argument in function 'timedLock' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof milliseconds != "number") {throw new TypeError("1st input argument '"+milliseconds+"' in function 'timedLock' is of type '"+(typeof milliseconds)+"'. Expected type 'number'. Function Signature: timedLock(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.timedLock', {"doc": this.id, "milliseconds": milliseconds}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.tryLockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tryLockRead'. Expected "+0+" arguments. Function Signature: tryLockRead()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.tryLockRead', {"doc": this.id}, this.userPriority);
	},

		PDFNet.PDFDoc.prototype.timedLockRead = function(milliseconds)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'timedLockRead'. Expected "+1+" argument. Function Signature: timedLockRead(number)")};
		if(milliseconds instanceof Promise) {throw new TypeError("1st input argument in function 'timedLockRead' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof milliseconds != "number") {throw new TypeError("1st input argument '"+milliseconds+"' in function 'timedLockRead' is of type '"+(typeof milliseconds)+"'. Expected type 'number'. Function Signature: timedLockRead(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.timedLockRead', {"doc": this.id, "milliseconds": milliseconds}, this.userPriority);
	},

	/**
	* addHighlights is used to highlight text in a document using 'Adobe's Highlight
	* File Format' (Technical Note #5172 ). The method will parse the character offset data
	* and modify the current document by adding new highlight annotations.
	*
	* @param hilite a string representing the filename for the highlight file or
	* or a data buffer containing XML data.
	*
	* @exception An exception will be thrown if the XML file is malformed or os out
	* of sync with the document.
	*/
		PDFNet.PDFDoc.prototype.addHighlights = function(hilite)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addHighlights'. Expected "+1+" argument. Function Signature: addHighlights(string)")};
		if(hilite instanceof Promise) {throw new TypeError("1st input argument in function 'addHighlights' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hilite != "string") {throw new TypeError("1st input argument '"+hilite+"' in function 'addHighlights' is of type '"+(typeof hilite)+"'. Expected type 'string'. Function Signature: addHighlights(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.addHighlights', {"doc": this.id, "hilite": hilite}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this document is marked as Tagged PDF, false otherwise.
	*/
		PDFNet.PDFDoc.prototype.isTagged = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isTagged'. Expected "+0+" arguments. Function Signature: isTagged()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.isTagged', {"doc": this.id}, this.userPriority);
	},

	/**
	* Indicates whether this documents contains any digital signatures.
	* @return A promise that resolves to true if a digital signature is found in this PDFDoc.
	*/
		PDFNet.PDFDoc.prototype.hasSignatures = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasSignatures'. Expected "+0+" arguments. Function Signature: hasSignatures()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.hasSignatures', {"doc": this.id}, this.userPriority);
	},

	/**
	* Adds a signature handler to the signature manager.
	*
	* @param signature_handler The signature handler instance to add to the signature manager.
	*
	* @return A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
	*/
		PDFNet.PDFDoc.prototype.addSignatureHandler = function(signature_handler)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'addSignatureHandler'. Expected "+1+" argument. Function Signature: addSignatureHandler(SignatureHandler)")};
		if(signature_handler instanceof Promise) {throw new TypeError("1st input argument in function 'addSignatureHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(signature_handler instanceof PDFNet.SignatureHandler)) {
			if(typeof signature_handler == "object") {throw new TypeError("1st input argument in function 'addSignatureHandler' is of type '"+signature_handler.name+"'. Expected type 'SignatureHandler'. Function Signature: addSignatureHandler(SignatureHandler).");}
			else {throw new TypeError("1st input argument '"+signature_handler+"' in function 'addSignatureHandler' is of type '"+(typeof signature_handler)+"'. Expected type 'SignatureHandler'. Function Signature: addSignatureHandler(SignatureHandler).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.addSignatureHandler', {"doc": this.id, "signature_handler": signature_handler.id}, this.userPriority);
	},

	/**
	* Adds a standard (built-in) signature handler to the signature manager. This method will use cryptographic
	* algorithm based on Adobe.PPKLite/adbe.pkcs7.detached filter to sign a PDF.
	*
	* @param pkcs12_file The private key certificate store to use.
	* @param pkcs12_pass The passphrase for the provided private key.
	*
	* @return A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
	*/
		PDFNet.PDFDoc.prototype.addStdSignatureHandlerFromFile = function(pkcs12_file, pkcs12_pass)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addStdSignatureHandlerFromFile'. Expected "+2+" arguments. Function Signature: addStdSignatureHandlerFromFile(string, string)")};
		if(pkcs12_file instanceof Promise) {throw new TypeError("1st input argument in function 'addStdSignatureHandlerFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pkcs12_file != "string") {throw new TypeError("1st input argument '"+pkcs12_file+"' in function 'addStdSignatureHandlerFromFile' is of type '"+(typeof pkcs12_file)+"'. Expected type 'string'. Function Signature: addStdSignatureHandlerFromFile(string, string).");}
		if(pkcs12_pass instanceof Promise) {throw new TypeError("2nd input argument in function 'addStdSignatureHandlerFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pkcs12_pass != "string") {throw new TypeError("2nd input argument '"+pkcs12_pass+"' in function 'addStdSignatureHandlerFromFile' is of type '"+(typeof pkcs12_pass)+"'. Expected type 'string'. Function Signature: addStdSignatureHandlerFromFile(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.addStdSignatureHandlerFromFile', {"doc": this.id, "pkcs12_file": pkcs12_file, "pkcs12_pass": pkcs12_pass}, this.userPriority);
	},

	/**
	* Removes a signature handler from the signature manager.
	*
	* @param signature_handler_id The unique id of the signature handler to remove.
	*/
		PDFNet.PDFDoc.prototype.removeSignatureHandler = function(signature_handler_id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'removeSignatureHandler'. Expected "+1+" argument. Function Signature: removeSignatureHandler(number)")};
		if(signature_handler_id instanceof Promise) {throw new TypeError("1st input argument in function 'removeSignatureHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof signature_handler_id != "number") {throw new TypeError("1st input argument '"+signature_handler_id+"' in function 'removeSignatureHandler' is of type '"+(typeof signature_handler_id)+"'. Expected type 'number'. Function Signature: removeSignatureHandler(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.removeSignatureHandler', {"doc": this.id, "signature_handler_id": signature_handler_id}, this.userPriority);
	},

	/**
	* Gets the associated signature handler instance from the signature manager by looking it up with the handler name.
	*
	* @param signature_handler_id The unique id of the signature handler to get.
	*
	* @return A promise that resolves to the signature handler instance if found, otherwise NULL.
	*/
		PDFNet.PDFDoc.prototype.getSignatureHandler = function(signature_handler_id)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getSignatureHandler'. Expected "+1+" argument. Function Signature: getSignatureHandler(number)")};
		if(signature_handler_id instanceof Promise) {throw new TypeError("1st input argument in function 'getSignatureHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof signature_handler_id != "number") {throw new TypeError("1st input argument '"+signature_handler_id+"' in function 'getSignatureHandler' is of type '"+(typeof signature_handler_id)+"'. Expected type 'number'. Function Signature: getSignatureHandler(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getSignatureHandler', {"doc": this.id, "signature_handler_id": signature_handler_id}, this.userPriority).then(function(id){
			//there is a return type SignatureHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SignatureHandler(id);
		});
	},

	/**
	* Generates thumbnail images for all the pages in this PDF document.
	* @param size The maximum dimension (width or height) that thumbnails will have.
	*/
		PDFNet.PDFDoc.prototype.generateThumbnails = function(size)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'generateThumbnails'. Expected "+1+" argument. Function Signature: generateThumbnails(number)")};
		if(size instanceof Promise) {throw new TypeError("1st input argument in function 'generateThumbnails' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("1st input argument '"+size+"' in function 'generateThumbnails' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: generateThumbnails(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.generateThumbnails', {"doc": this.id, "size": size}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the document's title.
	*/
		PDFNet.PDFDocInfo.prototype.getTitle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitle'. Expected "+0+" arguments. Function Signature: getTitle()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getTitle', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's title.
	*/
		PDFNet.PDFDocInfo.prototype.getTitleObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTitleObj'. Expected "+0+" arguments. Function Signature: getTitleObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getTitleObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set document's title.
	* @param title New title of the document.
	*/
		PDFNet.PDFDocInfo.prototype.setTitle = function(title)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTitle'. Expected "+1+" argument. Function Signature: setTitle(string)")};
		if(title instanceof Promise) {throw new TypeError("1st input argument in function 'setTitle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof title != "string") {throw new TypeError("1st input argument '"+title+"' in function 'setTitle' is of type '"+(typeof title)+"'. Expected type 'string'. Function Signature: setTitle(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setTitle', {"info": this.id, "title": title}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the name of the person who created the document.
	*/
		PDFNet.PDFDocInfo.prototype.getAuthor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAuthor'. Expected "+0+" arguments. Function Signature: getAuthor()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getAuthor', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's author.
	*/
		PDFNet.PDFDocInfo.prototype.getAuthorObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAuthorObj'. Expected "+0+" arguments. Function Signature: getAuthorObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getAuthorObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set the author of the document.
	* @param The name of the person who created the document.
	*/
		PDFNet.PDFDocInfo.prototype.setAuthor = function(author)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAuthor'. Expected "+1+" argument. Function Signature: setAuthor(string)")};
		if(author instanceof Promise) {throw new TypeError("1st input argument in function 'setAuthor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof author != "string") {throw new TypeError("1st input argument '"+author+"' in function 'setAuthor' is of type '"+(typeof author)+"'. Expected type 'string'. Function Signature: setAuthor(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setAuthor', {"info": this.id, "author": author}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the subject of the document.
	*/
		PDFNet.PDFDocInfo.prototype.getSubject = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSubject'. Expected "+0+" arguments. Function Signature: getSubject()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getSubject', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's subject.
	*/
		PDFNet.PDFDocInfo.prototype.getSubjectObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSubjectObj'. Expected "+0+" arguments. Function Signature: getSubjectObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getSubjectObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set the subject of the document
	* @param subject The subject of the document.
	*/
		PDFNet.PDFDocInfo.prototype.setSubject = function(subject)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSubject'. Expected "+1+" argument. Function Signature: setSubject(string)")};
		if(subject instanceof Promise) {throw new TypeError("1st input argument in function 'setSubject' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof subject != "string") {throw new TypeError("1st input argument '"+subject+"' in function 'setSubject' is of type '"+(typeof subject)+"'. Expected type 'string'. Function Signature: setSubject(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setSubject', {"info": this.id, "subject": subject}, this.userPriority);
	},

	/**
	* @return A promise that resolves to keywords associated with the document.
	*/
		PDFNet.PDFDocInfo.prototype.getKeywords = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getKeywords'. Expected "+0+" arguments. Function Signature: getKeywords()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getKeywords', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's keywords.
	*/
		PDFNet.PDFDocInfo.prototype.getKeywordsObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getKeywordsObj'. Expected "+0+" arguments. Function Signature: getKeywordsObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getKeywordsObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set keywords associated with the document.
	* @param Keywords Keywords associated with the document.
	*/
		PDFNet.PDFDocInfo.prototype.setKeywords = function(keywords)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setKeywords'. Expected "+1+" argument. Function Signature: setKeywords(string)")};
		if(keywords instanceof Promise) {throw new TypeError("1st input argument in function 'setKeywords' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof keywords != "string") {throw new TypeError("1st input argument '"+keywords+"' in function 'setKeywords' is of type '"+(typeof keywords)+"'. Expected type 'string'. Function Signature: setKeywords(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setKeywords', {"info": this.id, "keywords": keywords}, this.userPriority);
	},

	/**
	* @return A promise that resolves to if the document was converted to PDF from another
	* format, the name of the application that created the original
	* document from which it was converted.
	*/
		PDFNet.PDFDocInfo.prototype.getCreator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCreator'. Expected "+0+" arguments. Function Signature: getCreator()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getCreator', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's creator.
	*/
		PDFNet.PDFDocInfo.prototype.getCreatorObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCreatorObj'. Expected "+0+" arguments. Function Signature: getCreatorObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getCreatorObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set document's creator.
	* @param creator The name of the application that created
	* the original document.
	*/
		PDFNet.PDFDocInfo.prototype.setCreator = function(creator)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCreator'. Expected "+1+" argument. Function Signature: setCreator(string)")};
		if(creator instanceof Promise) {throw new TypeError("1st input argument in function 'setCreator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof creator != "string") {throw new TypeError("1st input argument '"+creator+"' in function 'setCreator' is of type '"+(typeof creator)+"'. Expected type 'string'. Function Signature: setCreator(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setCreator', {"info": this.id, "creator": creator}, this.userPriority);
	},

	/**
	* @return A promise that resolves to if the document was converted to PDF from another format,
	* the name of the application (for example, Distiller) that
	* converted it to PDF.
	*/
		PDFNet.PDFDocInfo.prototype.getProducer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getProducer'. Expected "+0+" arguments. Function Signature: getProducer()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getProducer', {"info": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to sDF/Cos string object representing document's producer.
	*/
		PDFNet.PDFDocInfo.prototype.getProducerObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getProducerObj'. Expected "+0+" arguments. Function Signature: getProducerObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getProducerObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Set document's producer.
	* @param producer The name of the application that generated PDF.
	*/
		PDFNet.PDFDocInfo.prototype.setProducer = function(producer)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setProducer'. Expected "+1+" argument. Function Signature: setProducer(string)")};
		if(producer instanceof Promise) {throw new TypeError("1st input argument in function 'setProducer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof producer != "string") {throw new TypeError("1st input argument '"+producer+"' in function 'setProducer' is of type '"+(typeof producer)+"'. Expected type 'string'. Function Signature: setProducer(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setProducer', {"info": this.id, "producer": producer}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the date and time the document was created,
	* in human-readable form.
	*/
		PDFNet.PDFDocInfo.prototype.getCreationDate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCreationDate'. Expected "+0+" arguments. Function Signature: getCreationDate()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getCreationDate', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Date
			if(id == "0"){
				return null;
			}
			return new PDFNet.Date(id);
		});
	},

	/**
	* Set document's creation date.
	* @param creation_date The date and time the document was created.
	*/
		PDFNet.PDFDocInfo.prototype.setCreationDate = function(creation_date)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCreationDate'. Expected "+1+" argument. Function Signature: setCreationDate(Date)")};
		if(creation_date instanceof Promise) {throw new TypeError("1st input argument in function 'setCreationDate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(creation_date instanceof PDFNet.Date) && creation_date.name != "Date") {
			if(typeof creation_date == "object") {throw new TypeError("1st input argument in function 'setCreationDate' is of type '"+creation_date.name+"'. Expected type 'Date'. Function Signature: setCreationDate(Date).");}
			else {throw new TypeError("1st input argument '"+creation_date+"' in function 'setCreationDate' is of type '"+(typeof creation_date)+"'. Expected type 'Date'. Function Signature: setCreationDate(Date).");}
		}
		if(typeof creation_date.yieldFunction != "undefined") {throw new Error("Function '"+creation_date.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setCreationDate'. Perhaps a yield statement is required for '"+creation_date.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setCreationDate', {"info": this.id, "creation_date": creation_date}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the date and time the document was most recently
	* modified, in human-readable form.
	*/
		PDFNet.PDFDocInfo.prototype.getModDate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getModDate'. Expected "+0+" arguments. Function Signature: getModDate()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getModDate', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Date
			if(id == "0"){
				return null;
			}
			return new PDFNet.Date(id);
		});
	},

	/**
	* Set document's modification date.
	* @param mod_date The date and time the document was most
	* recently modified.
	*/
		PDFNet.PDFDocInfo.prototype.setModDate = function(mod_date)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setModDate'. Expected "+1+" argument. Function Signature: setModDate(Date)")};
		if(mod_date instanceof Promise) {throw new TypeError("1st input argument in function 'setModDate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mod_date instanceof PDFNet.Date) && mod_date.name != "Date") {
			if(typeof mod_date == "object") {throw new TypeError("1st input argument in function 'setModDate' is of type '"+mod_date.name+"'. Expected type 'Date'. Function Signature: setModDate(Date).");}
			else {throw new TypeError("1st input argument '"+mod_date+"' in function 'setModDate' is of type '"+(typeof mod_date)+"'. Expected type 'Date'. Function Signature: setModDate(Date).");}
		}
		if(typeof mod_date.yieldFunction != "undefined") {throw new Error("Function '"+mod_date.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setModDate'. Perhaps a yield statement is required for '"+mod_date.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.setModDate', {"info": this.id, "mod_date": mod_date}, this.userPriority);
	},

	/**
	* @return A promise that resolves to document's SDF/Cos 'Info' dictionary or NULL if
	* the info dictionary is not available.
	*/
		PDFNet.PDFDocInfo.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.getSDFObj', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* PdFDocInfo constructor. Typically this constructor is
	* never used since it is easier to obtain DocInfo using
	* PDFDoc.GetDocInfo()
	*/
		PDFNet.PDFDocInfo.create = function(tr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(tr instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(tr instanceof PDFNet.Obj)) {
			if(typeof tr == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+tr.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+tr+"' in function 'create' is of type '"+(typeof tr)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfDocInfoCreate', {"tr": tr.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocInfo
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocInfo(id);
		});
	},

		PDFNet.PDFDocInfo.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocInfo.copy', {"info": this.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocInfo
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocInfo(id);
		});
	},

	/**
	* A utility method used to set the fist page displayed after
	* the document is opened. This method is equivalent to
	* PDFDoc::SetOpenAction(goto_action).
	*
	* If OpenAction is not specified the document should be
	* opened to the top of the first page at the default magnification
	* factor.
	*
	* @param dest A value specifying the page destination to be
	* displayed when the document is opened.
	*
	* Example:
	* @code
	* Destination dest = Destination::CreateFit(page);
	* pdfdoc.GetViewPrefs().SetInitialPage(dest);
	* @endcode
	*/
		PDFNet.PDFDocViewPrefs.prototype.setInitialPage = function(dest)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setInitialPage'. Expected "+1+" argument. Function Signature: setInitialPage(Destination)")};
		if(dest instanceof Promise) {throw new TypeError("1st input argument in function 'setInitialPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest instanceof PDFNet.Destination)) {
			if(typeof dest == "object") {throw new TypeError("1st input argument in function 'setInitialPage' is of type '"+dest.name+"'. Expected type 'Destination'. Function Signature: setInitialPage(Destination).");}
			else {throw new TypeError("1st input argument '"+dest+"' in function 'setInitialPage' is of type '"+(typeof dest)+"'. Expected type 'Destination'. Function Signature: setInitialPage(Destination).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setInitialPage', {"p": this.id, "dest": dest.id}, this.userPriority);
	},

	/**
	* Sets PageMode property and change the value of the
	* PageMode key in the Catalog dictionary.
	*
	* @param mode New PageMode setting. Default value is e_UseNone.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setPageMode = function(mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPageMode'. Expected "+1+" argument. Function Signature: setPageMode(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setPageMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setPageMode' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setPageMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setPageMode', {"p": this.id, "mode": mode}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the value of currently selected PageMode property.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getPageMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPageMode'. Expected "+0+" arguments. Function Signature: getPageMode()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getPageMode', {"p": this.id}, this.userPriority);
	},

	/**
	* Sets PageLayout property and change the value of the
	* PageLayout key in the Catalog dictionary.
	*
	* @param mode New PageLayout setting. Default value is
	* e_SinglePage.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setLayoutMode = function(layout)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLayoutMode'. Expected "+1+" argument. Function Signature: setLayoutMode(number)")};
		if(layout instanceof Promise) {throw new TypeError("1st input argument in function 'setLayoutMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof layout != "number") {throw new TypeError("1st input argument '"+layout+"' in function 'setLayoutMode' is of type '"+(typeof layout)+"'. Expected type 'number'. Function Signature: setLayoutMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setLayoutMode', {"p": this.id, "layout": layout}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the value of currently selected PageLayout property.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getLayoutMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLayoutMode'. Expected "+0+" arguments. Function Signature: getLayoutMode()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getLayoutMode', {"p": this.id}, this.userPriority);
	},

	/**
	* sets the value of given ViewerPref property.
	*
	* @param pref the ViewerPref property type to modify.
	* @param value The new value for the property.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setPref = function(pref, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPref'. Expected "+2+" arguments. Function Signature: setPref(number, boolean)")};
		if(pref instanceof Promise) {throw new TypeError("1st input argument in function 'setPref' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pref != "number") {throw new TypeError("1st input argument '"+pref+"' in function 'setPref' is of type '"+(typeof pref)+"'. Expected type 'number'. Function Signature: setPref(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'setPref' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'setPref' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: setPref(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setPref', {"p": this.id, "pref": pref, "value": value}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the value of given ViewerPref property.
	* @param pref the ViewerPref property type to query.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getPref = function(pref)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPref'. Expected "+1+" argument. Function Signature: getPref(number)")};
		if(pref instanceof Promise) {throw new TypeError("1st input argument in function 'getPref' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pref != "number") {throw new TypeError("1st input argument '"+pref+"' in function 'getPref' is of type '"+(typeof pref)+"'. Expected type 'number'. Function Signature: getPref(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getPref', {"p": this.id, "pref": pref}, this.userPriority);
	},

	/**
	* set the document's page mode, specifying how to display the
	* document on exiting full-screen mode.
	*
	* @param mode PageMode used after exiting full-screen mode.
	* Default value: e_UseNone.
	*
	* @note This entry is meaningful only if the value of the
	* PageMode is set to e_FullScreen; it is ignored otherwise.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setNonFullScreenPageMode = function(mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setNonFullScreenPageMode'. Expected "+1+" argument. Function Signature: setNonFullScreenPageMode(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setNonFullScreenPageMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setNonFullScreenPageMode' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setNonFullScreenPageMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setNonFullScreenPageMode', {"p": this.id, "mode": mode}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the PageMode used after exiting full-screen mode.
	* @note This entry is meaningful only if the value of the
	* PageMode is set to e_FullScreen; it is ignored otherwise.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getNonFullScreenPageMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNonFullScreenPageMode'. Expected "+0+" arguments. Function Signature: getNonFullScreenPageMode()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getNonFullScreenPageMode', {"p": this.id}, this.userPriority);
	},

	/**
	* sets the predominant reading order for text.
	*
	* This flag has no direct effect on the document's contents
	* or page numbering but can be used to determine the relative
	* positioning of pages when displayed side by side or
	* printed n-up.
	*
	* @param left_to_right - true if the predominant reading
	* order for text is from left to right and false if it is
	* right to left (including vertical writing systems, such
	* as Chinese, Japanese, and Korean).
	* Default value: left_to_right is true.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setDirection = function(left_to_right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDirection'. Expected "+1+" argument. Function Signature: setDirection(boolean)")};
		if(left_to_right instanceof Promise) {throw new TypeError("1st input argument in function 'setDirection' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof left_to_right != "boolean") {throw new TypeError("1st input argument '"+left_to_right+"' in function 'setDirection' is of type '"+(typeof left_to_right)+"'. Expected type 'boolean'. Function Signature: setDirection(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setDirection', {"p": this.id, "left_to_right": left_to_right}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true is the predominant reading order for text
	* is left to right, false otherwise. See SetDirection() for
	* more information.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getDirection = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDirection'. Expected "+0+" arguments. Function Signature: getDirection()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getDirection', {"p": this.id}, this.userPriority);
	},

	/**
	* Sets the page boundary representing the area of a page
	* to be displayed when viewing the document on the screen.
	*
	* @param box page boundary displayed when viewing the document
	* on the screen. By default, PDF viewers will display the
	* crop-box.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setViewArea = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setViewArea'. Expected "+1+" argument. Function Signature: setViewArea(number)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setViewArea' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box != "number") {throw new TypeError("1st input argument '"+box+"' in function 'setViewArea' is of type '"+(typeof box)+"'. Expected type 'number'. Function Signature: setViewArea(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setViewArea', {"p": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the page boundary representing the area of a page
	* to be displayed when viewing the document on the screen.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getViewArea = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getViewArea'. Expected "+0+" arguments. Function Signature: getViewArea()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getViewArea', {"p": this.id}, this.userPriority);
	},

	/**
	* sets the page boundary to which the contents of a page are
	* to be clipped when viewing the document on the screen.
	*
	* @param box screen clip region. The default value is
	* page crop-box.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setViewClip = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setViewClip'. Expected "+1+" argument. Function Signature: setViewClip(number)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setViewClip' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box != "number") {throw new TypeError("1st input argument '"+box+"' in function 'setViewClip' is of type '"+(typeof box)+"'. Expected type 'number'. Function Signature: setViewClip(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setViewClip', {"p": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the page boundary to which the contents of a page
	* are to be clipped when viewing the document on the screen.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getViewClip = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getViewClip'. Expected "+0+" arguments. Function Signature: getViewClip()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getViewClip', {"p": this.id}, this.userPriority);
	},

	/**
	* sets the page boundary representing the area of a page to
	* be rendered when printing the document.
	*
	* @param box printing region. The default value is page
	* crop-box.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setPrintArea = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintArea'. Expected "+1+" argument. Function Signature: setPrintArea(number)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintArea' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box != "number") {throw new TypeError("1st input argument '"+box+"' in function 'setPrintArea' is of type '"+(typeof box)+"'. Expected type 'number'. Function Signature: setPrintArea(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setPrintArea', {"p": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the page boundary representing the area of a page
	* to be rendered when printing the document.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getPrintArea = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPrintArea'. Expected "+0+" arguments. Function Signature: getPrintArea()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getPrintArea', {"p": this.id}, this.userPriority);
	},

	/**
	* sets the page boundary to which the contents of a page are
	* to be clipped when printing the document.
	*
	* @param box printing clip region. The default value is page
	* crop-box.
	*/
		PDFNet.PDFDocViewPrefs.prototype.setPrintClip = function(box)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintClip'. Expected "+1+" argument. Function Signature: setPrintClip(number)")};
		if(box instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintClip' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof box != "number") {throw new TypeError("1st input argument '"+box+"' in function 'setPrintClip' is of type '"+(typeof box)+"'. Expected type 'number'. Function Signature: setPrintClip(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.setPrintClip', {"p": this.id, "box": box}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the page boundary to which the contents of a page
	* are to be clipped when printing the document.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getPrintClip = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPrintClip'. Expected "+0+" arguments. Function Signature: getPrintClip()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getPrintClip', {"p": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to document's SDF/Cos 'ViewerPreferences' dictionary
	* or NULL if the object is not present.
	*/
		PDFNet.PDFDocViewPrefs.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.getSDFObj', {"p": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* PdFDocViewPrefs constructor. Typically this constructor is
	* never used since it is easier to obtain PDFDocViewPrefs using
	* PDFDoc.GetViewPrefs()
	*/
		PDFNet.PDFDocViewPrefs.create = function(tr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(tr instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(tr instanceof PDFNet.Obj)) {
			if(typeof tr == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+tr.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+tr+"' in function 'create' is of type '"+(typeof tr)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfDocViewPrefsCreate', {"tr": tr.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocViewPrefs
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocViewPrefs(id);
		});
	},

		PDFNet.PDFDocViewPrefs.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDocViewPrefs.copy', {"prefs": this.id}, this.userPriority).then(function(id){
			//there is a return type PDFDocViewPrefs
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDocViewPrefs(id);
		});
	},

	/**
	* PdFRasterizer constructor and destructor
	*/
		PDFNet.PDFRasterizer.create = function(type)
	{
		if(typeof type === "undefined") {type = exports.PDFNet.PDFRasterizer.Type.e_BuiltIn};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(number)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'create' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: create(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfRasterizerCreate', {"type": type}, this.userPriority).then(function(id){
			//there is a return type PDFRasterizer
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFRasterizer(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.PDFRasterizer.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.destroy', {"r": this.id}, this.userPriority);
	},

		PDFNet.ChunkRenderer.prototype.renderNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'renderNext'. Expected "+0+" arguments. Function Signature: renderNext()")};
		return PDFNet.messageHandler.sendWithPromise('ChunkRenderer.renderNext', {"cr": this.id}, this.userPriority);
	},

		PDFNet.ChunkRenderer.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ChunkRenderer.destroy', {"cr": this.id}, this.userPriority);
	},

	/**
	* Enable or disable annotation and forms rendering. By default, annotations and forms
	* are rendered.
	*
	* @param render_annots True to draw annotations, false otherwise.
	*/
		PDFNet.PDFRasterizer.prototype.setDrawAnnotations = function(render_annots)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDrawAnnotations'. Expected "+1+" argument. Function Signature: setDrawAnnotations(boolean)")};
		if(render_annots instanceof Promise) {throw new TypeError("1st input argument in function 'setDrawAnnotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof render_annots != "boolean") {throw new TypeError("1st input argument '"+render_annots+"' in function 'setDrawAnnotations' is of type '"+(typeof render_annots)+"'. Expected type 'boolean'. Function Signature: setDrawAnnotations(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setDrawAnnotations', {"r": this.id, "render_annots": render_annots}, this.userPriority);
	},

	/**
	* Enable or disable highlighting form fields. Default is disabled.
	*
	* @param highlight_fields true to highlight, false otherwise.
	*/
		PDFNet.PDFRasterizer.prototype.setHighlightFields = function(highlight)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHighlightFields'. Expected "+1+" argument. Function Signature: setHighlightFields(boolean)")};
		if(highlight instanceof Promise) {throw new TypeError("1st input argument in function 'setHighlightFields' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof highlight != "boolean") {throw new TypeError("1st input argument '"+highlight+"' in function 'setHighlightFields' is of type '"+(typeof highlight)+"'. Expected type 'boolean'. Function Signature: setHighlightFields(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setHighlightFields', {"r": this.id, "highlight": highlight}, this.userPriority);
	},

	/**
	* Enable or disable anti-aliasing.
	*
	* Anti-Aliasing is a technique used to improve the visual
	* quality of images when displaying them on low resolution
	* devices (for example, low DPI computer monitors).
	*
	* @default Anti-aliasing is enabled by default.
	*/
		PDFNet.PDFRasterizer.prototype.setAntiAliasing = function(enable_aa)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAntiAliasing'. Expected "+1+" argument. Function Signature: setAntiAliasing(boolean)")};
		if(enable_aa instanceof Promise) {throw new TypeError("1st input argument in function 'setAntiAliasing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable_aa != "boolean") {throw new TypeError("1st input argument '"+enable_aa+"' in function 'setAntiAliasing' is of type '"+(typeof enable_aa)+"'. Expected type 'boolean'. Function Signature: setAntiAliasing(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setAntiAliasing', {"r": this.id, "enable_aa": enable_aa}, this.userPriority);
	},

	/**
	* Enable or disable path hinting.
	*
	* @param path_hinting if true path hinting is enabled. Path hinting is used to slightly
	* adjust paths in order to avoid or alleviate artifacts of hair line cracks between
	* certain graphical elements. This option is turned on by default.
	*
	*/
		PDFNet.PDFRasterizer.prototype.setPathHinting = function(enable_ph)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathHinting'. Expected "+1+" argument. Function Signature: setPathHinting(boolean)")};
		if(enable_ph instanceof Promise) {throw new TypeError("1st input argument in function 'setPathHinting' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable_ph != "boolean") {throw new TypeError("1st input argument '"+enable_ph+"' in function 'setPathHinting' is of type '"+(typeof enable_ph)+"'. Expected type 'boolean'. Function Signature: setPathHinting(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setPathHinting', {"r": this.id, "enable_ph": enable_ph}, this.userPriority);
	},

	/**
	* Set thin line adjustment parameters.
	*
	* @param pixel_grid_fit if true (horizontal/vertical) thin lines will be snapped to
	* integer pixel positions. This helps make thin lines look sharper and clearer. This
	* option is turned off by default and it only works if path hinting is enabled.
	*
	* @param stroke_adjust if true auto stroke adjustment is enabled. Currently, this would
	* make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
	*/
		PDFNet.PDFRasterizer.prototype.setThinLineAdjustment = function(grid_fit, stroke_adjust)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setThinLineAdjustment'. Expected "+2+" arguments. Function Signature: setThinLineAdjustment(boolean, boolean)")};
		if(grid_fit instanceof Promise) {throw new TypeError("1st input argument in function 'setThinLineAdjustment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof grid_fit != "boolean") {throw new TypeError("1st input argument '"+grid_fit+"' in function 'setThinLineAdjustment' is of type '"+(typeof grid_fit)+"'. Expected type 'boolean'. Function Signature: setThinLineAdjustment(boolean, boolean).");}
		if(stroke_adjust instanceof Promise) {throw new TypeError("2nd input argument in function 'setThinLineAdjustment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof stroke_adjust != "boolean") {throw new TypeError("2nd input argument '"+stroke_adjust+"' in function 'setThinLineAdjustment' is of type '"+(typeof stroke_adjust)+"'. Expected type 'boolean'. Function Signature: setThinLineAdjustment(boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setThinLineAdjustment', {"r": this.id, "grid_fit": grid_fit, "stroke_adjust": stroke_adjust}, this.userPriority);
	},

	/**
	* sets the gamma factor used for anti-aliased rendering.
	*
	* @param exp is the exponent value of gamma function. Typical values
	* are in the range from 0.1 to 3.
	*
	* Gamma correction can be used to improve the quality of anti-aliased
	* image output and can (to some extent) decrease the appearance common
	* anti-aliasing artifacts (such as pixel width lines between polygons).
	*
	* @note Gamma correction is used only in the built-in rasterizer.
	*/
		PDFNet.PDFRasterizer.prototype.setGamma = function(gamma)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setGamma'. Expected "+1+" argument. Function Signature: setGamma(number)")};
		if(gamma instanceof Promise) {throw new TypeError("1st input argument in function 'setGamma' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof gamma != "number") {throw new TypeError("1st input argument '"+gamma+"' in function 'setGamma' is of type '"+(typeof gamma)+"'. Expected type 'number'. Function Signature: setGamma(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setGamma', {"r": this.id, "gamma": gamma}, this.userPriority);
	},

	/**
	* sets the Optional Content Group (OCG) context that should be used when
	*  rendering the page. This function can be used to selectively render optional
	* content (such as PDF layers) based on the states of optional content groups
	* in the given context.
	*
	* @param ctx Optional Content Group (OCG) context, or NULL if the rasterizer
	* should render all content on the page.
	*/
		PDFNet.PDFRasterizer.prototype.setOCGContext = function(ctx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOCGContext'. Expected "+1+" argument. Function Signature: setOCGContext(OCGContext)")};
		if(ctx instanceof Promise) {throw new TypeError("1st input argument in function 'setOCGContext' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("1st input argument in function 'setOCGContext' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: setOCGContext(OCGContext).");}
			else {throw new TypeError("1st input argument '"+ctx+"' in function 'setOCGContext' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: setOCGContext(OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setOCGContext', {"r": this.id, "ctx": ctx.id}, this.userPriority);
	},

	/**
	* tells the rasterizer to render the page 'print' mode. Certain page elements
	* (such as annotations or OCG-s) are meant to be visible either on the screen or
	* on the printed paper but not both. A common example, is the "Submit" button on
	* electronic forms.
	*
	* @param is_printing set to true is the page should be rendered in print mode.
	* @default By default, print mode flag is set to false.
	*/
		PDFNet.PDFRasterizer.prototype.setPrintMode = function(is_printing)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintMode'. Expected "+1+" argument. Function Signature: setPrintMode(boolean)")};
		if(is_printing instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof is_printing != "boolean") {throw new TypeError("1st input argument '"+is_printing+"' in function 'setPrintMode' is of type '"+(typeof is_printing)+"'. Expected type 'boolean'. Function Signature: setPrintMode(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setPrintMode', {"r": this.id, "is_printing": is_printing}, this.userPriority);
	},

	/**
	* Enable or disable image smoothing.
	*
	* The rasterizer allows a tradeoff between rendering quality and rendering speed.
	* This function can be used to indicate the preference between rendering speed and quality.
	*
	* @note image smoothing option has effect only if the source image has higher resolution
	* that the output resolution of the image on the rasterized page. PDFNet automatically
	* controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
	*
	* @param smoothing_enabled True to enable image smoothing, false otherwise.
	* @param hq_image_resampling True to use a higher quality (but slower) smoothing algorithm
	* @default image smoothing is enabled and hq_image_resampling is false.
	*/
		PDFNet.PDFRasterizer.prototype.setImageSmoothing = function(smoothing_enabled, hq_image_resampling)
	{
		if(typeof smoothing_enabled === "undefined") {smoothing_enabled = true;};
		if(typeof hq_image_resampling === "undefined") {hq_image_resampling = false;};
		if(arguments.length > 2) {throw new RangeError(arguments.length+" arguments passed into function 'setImageSmoothing'. Expected at most "+2+" arguments. Function Signature: setImageSmoothing(boolean, boolean)")};
		if(smoothing_enabled instanceof Promise) {throw new TypeError("1st input argument in function 'setImageSmoothing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof smoothing_enabled != "boolean") {throw new TypeError("1st input argument '"+smoothing_enabled+"' in function 'setImageSmoothing' is of type '"+(typeof smoothing_enabled)+"'. Expected type 'boolean'. Function Signature: setImageSmoothing(boolean, boolean).");}
		if(hq_image_resampling instanceof Promise) {throw new TypeError("2nd input argument in function 'setImageSmoothing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hq_image_resampling != "boolean") {throw new TypeError("2nd input argument '"+hq_image_resampling+"' in function 'setImageSmoothing' is of type '"+(typeof hq_image_resampling)+"'. Expected type 'boolean'. Function Signature: setImageSmoothing(boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setImageSmoothing', {"r": this.id, "smoothing_enabled": smoothing_enabled, "hq_image_resampling": hq_image_resampling}, this.userPriority);
	},

	/**
	* enable or disable support for overprint and overprint simulation.
	* Overprint is a device dependent feature and the results will vary depending on
	* the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
	*
	* @default By default overprint is only enabled for PDF/X files.
	*
	* @param op e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
	*/
		PDFNet.PDFRasterizer.prototype.setOverprint = function(op)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOverprint'. Expected "+1+" argument. Function Signature: setOverprint(number)")};
		if(op instanceof Promise) {throw new TypeError("1st input argument in function 'setOverprint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof op != "number") {throw new TypeError("1st input argument '"+op+"' in function 'setOverprint' is of type '"+(typeof op)+"'. Expected type 'number'. Function Signature: setOverprint(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setOverprint', {"r": this.id, "op": op}, this.userPriority);
	},

	/**
	* enables or disables caching. Caching can improve the rendering performance in cases
	* where the same page will be drawn multiple times.
	*
	* @param enabled - if true PDFRasterizer will cache frequently used graphics objects.
	*/
		PDFNet.PDFRasterizer.prototype.setCaching = function(enabled)
	{
		if(typeof enabled === "undefined") {enabled = true;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCaching'. Expected at most "+1+" arguments. Function Signature: setCaching(boolean)")};
		if(enabled instanceof Promise) {throw new TypeError("1st input argument in function 'setCaching' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enabled != "boolean") {throw new TypeError("1st input argument '"+enabled+"' in function 'setCaching' is of type '"+(typeof enabled)+"'. Expected type 'boolean'. Function Signature: setCaching(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setCaching', {"r": this.id, "enabled": enabled}, this.userPriority);
	},

	/**
	* sets the Optional Content Group (OCG) context that should be used when
	* rendering the page. This function can be used to selectively render optional
	* content (such as PDF layers) based on the states of optional content groups
	* in the given context.
	*
	* @param ctx Optional Content Group (OCG) context, or NULL if the rasterizer
	* should render all content on the page.
	*/
		PDFNet.PDFDraw.prototype.setOCGContext = function(ctx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOCGContext'. Expected "+1+" argument. Function Signature: setOCGContext(OCGContext)")};
		if(ctx instanceof Promise) {throw new TypeError("1st input argument in function 'setOCGContext' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(ctx instanceof PDFNet.OCGContext)) {
			if(typeof ctx == "object") {throw new TypeError("1st input argument in function 'setOCGContext' is of type '"+ctx.name+"'. Expected type 'OCGContext'. Function Signature: setOCGContext(OCGContext).");}
			else {throw new TypeError("1st input argument '"+ctx+"' in function 'setOCGContext' is of type '"+(typeof ctx)+"'. Expected type 'OCGContext'. Function Signature: setOCGContext(OCGContext).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setOCGContext', {"r": this.id, "ctx": ctx.id}, this.userPriority);
	},

	/**
	* Sets the core graphics library used for rasterization and
	* rendering. Using this method it is possible to quickly switch
	* between different implementations. By default, PDFNet uses a
	* built-in, high-quality, and platform independent rasterizer.
	*
	* @param type Rasterizer type.
	*/
		PDFNet.PDFRasterizer.prototype.setRasterizerType = function(type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRasterizerType'. Expected "+1+" argument. Function Signature: setRasterizerType(number)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'setRasterizerType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'setRasterizerType' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: setRasterizerType(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setRasterizerType', {"r": this.id, "type": type}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the type of current rasterizer.
	*/
		PDFNet.PDFRasterizer.prototype.getRasterizerType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRasterizerType'. Expected "+0+" arguments. Function Signature: getRasterizerType()")};
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.getRasterizerType', {"r": this.id}, this.userPriority);
	},

	/**
	* Set the color post processing transformation.
	* This transform is applied to the rasterized bitmap as the final step
	* in the rasterization process, and is applied directly to the resulting
	* bitmap (disregarding any color space information). Color post
	* processing only supported for RGBA output.
	*
	* @param mode is the specific transform to be applied
	*/
		PDFNet.PDFRasterizer.prototype.setColorPostProcessMode = function(mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setColorPostProcessMode'. Expected "+1+" argument. Function Signature: setColorPostProcessMode(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setColorPostProcessMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setColorPostProcessMode' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setColorPostProcessMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.setColorPostProcessMode', {"r": this.id, "mode": mode}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the current color post processing mode.
	*/
		PDFNet.PDFRasterizer.prototype.getColorPostProcessMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getColorPostProcessMode'. Expected "+0+" arguments. Function Signature: getColorPostProcessMode()")};
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.getColorPostProcessMode', {"r": this.id}, this.userPriority);
	},

		PDFNet.PDFRasterizer.prototype.updateBuffer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'updateBuffer'. Expected "+0+" arguments. Function Signature: updateBuffer()")};
		return PDFNet.messageHandler.sendWithPromise('PDFRasterizer.updateBuffer', {"r": this.id}, this.userPriority);
	},

	/**
	* PdFDraw constructor and destructor
	*
	* @param dpi - Default resolution used to rasterize pages. If the parameter is not
	* specified, the initial resolution is 92 dots per inch. DPI parameter can be
	* modified at any time using PDFDraw::SetDPI() method.
	*/
		PDFNet.PDFDraw.create = function(dpi)
	{
		if(typeof dpi === "undefined") {dpi = 92;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(number)")};
		if(dpi instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dpi != "number") {throw new TypeError("1st input argument '"+dpi+"' in function 'create' is of type '"+(typeof dpi)+"'. Expected type 'number'. Function Signature: create(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfDrawCreate', {"dpi": dpi}, this.userPriority).then(function(id){
			//there is a return type PDFDraw
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDraw(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.PDFDraw.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.destroy', {"d": this.id}, this.userPriority);
	},

	/**
	* Sets the core graphics library used for rasterization and
	* rendering. Using this method it is possible to quickly switch
	* between different implementations. By default, PDFDraw uses
	* the built-in, platform independent rasterizer.
	*
	* @param type Rasterizer type.
	*/
		PDFNet.PDFDraw.prototype.setRasterizerType = function(type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRasterizerType'. Expected "+1+" argument. Function Signature: setRasterizerType(number)")};
		if(type instanceof Promise) {throw new TypeError("1st input argument in function 'setRasterizerType' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof type != "number") {throw new TypeError("1st input argument '"+type+"' in function 'setRasterizerType' is of type '"+(typeof type)+"'. Expected type 'number'. Function Signature: setRasterizerType(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setRasterizerType', {"d": this.id, "type": type}, this.userPriority);
	},

	/**
	* Sets the output image resolution.
	*
	* DPI stands for Dots Per Inch. This parameter is used to specify the output
	* image size and quality. A typical screen resolution for monitors these days is
	* 92 DPI, but printers could use 200 DPI or more.
	*
	* @note The size of resulting image is a function of DPI and the dimensions of
	* the source PDF page. For example, if DPI is 92 and page is 8 inches wide, the
	* output bitmap will have 92*8 = 736 pixels per line. If you know the dimensions
	* of the destination bitmap, but don't care about DPI of the image you can use
	* pdfdraw.SetImageSize() instead.
	*
	* @note if you would like to rasterize extremely large bitmaps (e.g. with
	* resolutions of 2000 DPI or more) it is not practical to use PDFDraw directly
	* because of the memory required to store the entire image. In this case, you
	* can use PDFRasterizer directly to generate the rasterized image in stripes or
	* tiles.
	*/
		PDFNet.PDFDraw.prototype.setDPI = function(dpi)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDPI'. Expected "+1+" argument. Function Signature: setDPI(number)")};
		if(dpi instanceof Promise) {throw new TypeError("1st input argument in function 'setDPI' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dpi != "number") {throw new TypeError("1st input argument '"+dpi+"' in function 'setDPI' is of type '"+(typeof dpi)+"'. Expected type 'number'. Function Signature: setDPI(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setDPI', {"d": this.id, "dpi": dpi}, this.userPriority);
	},

	/**
	* SetImageSize can be used instead of SetDPI() to adjust page  scaling so that
	* image fits into a buffer of given dimensions.
	*
	* If this function is used, DPI will be calculated dynamically for each
	* page so that every page fits into the buffer of given dimensions.
	*
	* @param width - The width of the image, in pixels/samples.
	* @param height - The height of the image, in pixels/samples.
	* @param preserve_aspect_ratio - True to preserve the aspect ratio, false
	* otherwise. By default, preserve_aspect_ratio is true.
	*/
		PDFNet.PDFDraw.prototype.setImageSize = function(width, height, preserve_aspect_ratio)
	{
		if(typeof preserve_aspect_ratio === "undefined") {preserve_aspect_ratio = true;};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'setImageSize'. Expected "+2+" to "+3+" arguments. Function Signature: setImageSize(number, number, boolean)")};
		if(width instanceof Promise) {throw new TypeError("1st input argument in function 'setImageSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof width != "number") {throw new TypeError("1st input argument '"+width+"' in function 'setImageSize' is of type '"+(typeof width)+"'. Expected type 'number'. Function Signature: setImageSize(number, number, boolean).");}
		if(height instanceof Promise) {throw new TypeError("2nd input argument in function 'setImageSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof height != "number") {throw new TypeError("2nd input argument '"+height+"' in function 'setImageSize' is of type '"+(typeof height)+"'. Expected type 'number'. Function Signature: setImageSize(number, number, boolean).");}
		if(preserve_aspect_ratio instanceof Promise) {throw new TypeError("3rd input argument in function 'setImageSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof preserve_aspect_ratio != "boolean") {throw new TypeError("3rd input argument '"+preserve_aspect_ratio+"' in function 'setImageSize' is of type '"+(typeof preserve_aspect_ratio)+"'. Expected type 'boolean'. Function Signature: setImageSize(number, number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setImageSize', {"d": this.id, "width": width, "height": height, "preserve_aspect_ratio": preserve_aspect_ratio}, this.userPriority);
	},

	/**
	* Selects the page box/region to rasterize.
	*
	* @param region Page box to rasterize. By default, PDFDraw will rasterize
	* page crop box.
	*/
		PDFNet.PDFDraw.prototype.setPageBox = function(region)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPageBox'. Expected "+1+" argument. Function Signature: setPageBox(number)")};
		if(region instanceof Promise) {throw new TypeError("1st input argument in function 'setPageBox' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof region != "number") {throw new TypeError("1st input argument '"+region+"' in function 'setPageBox' is of type '"+(typeof region)+"'. Expected type 'number'. Function Signature: setPageBox(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setPageBox', {"d": this.id, "region": region}, this.userPriority);
	},

	/**
	* Flips the vertical (i.e. Y) axis of the image.
	*
	* @param flip_y true to flip the Y axis, false otherwise. For compatibility with
	* most raster formats 'flip_y' is true by default.
	*/
		PDFNet.PDFDraw.prototype.setFlipYAxis = function(flip_y)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFlipYAxis'. Expected "+1+" argument. Function Signature: setFlipYAxis(boolean)")};
		if(flip_y instanceof Promise) {throw new TypeError("1st input argument in function 'setFlipYAxis' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flip_y != "boolean") {throw new TypeError("1st input argument '"+flip_y+"' in function 'setFlipYAxis' is of type '"+(typeof flip_y)+"'. Expected type 'boolean'. Function Signature: setFlipYAxis(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setFlipYAxis', {"d": this.id, "flip_y": flip_y}, this.userPriority);
	},

	/**
	* Sets the rotation value for this page.
	*
	* @note This method is used only for drawing purposes and it does not modify
	* the document (unlike Page::SetRotate()).
	*
	* @param angle Rotation value to be set for a given page. Must be one
	* of the Page::Rotate values.
	*/
		PDFNet.PDFDraw.prototype.setRotate = function(r)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRotate'. Expected "+1+" argument. Function Signature: setRotate(number)")};
		if(r instanceof Promise) {throw new TypeError("1st input argument in function 'setRotate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r != "number") {throw new TypeError("1st input argument '"+r+"' in function 'setRotate' is of type '"+(typeof r)+"'. Expected type 'number'. Function Signature: setRotate(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setRotate', {"d": this.id, "r": r}, this.userPriority);
	},

	/**
	* Enable or disable annotation and forms rendering. By default, all annotations
	* and form fields are rendered.
	*
	* @param render_annots True to draw annotations, false otherwise.
	*/
		PDFNet.PDFDraw.prototype.setDrawAnnotations = function(render_annots)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDrawAnnotations'. Expected "+1+" argument. Function Signature: setDrawAnnotations(boolean)")};
		if(render_annots instanceof Promise) {throw new TypeError("1st input argument in function 'setDrawAnnotations' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof render_annots != "boolean") {throw new TypeError("1st input argument '"+render_annots+"' in function 'setDrawAnnotations' is of type '"+(typeof render_annots)+"'. Expected type 'boolean'. Function Signature: setDrawAnnotations(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setDrawAnnotations', {"d": this.id, "render_annots": render_annots}, this.userPriority);
	},

	/**
	* Enable or disable highlighting form fields. Default is disabled.
	*
	* @param highlight_fields true to highlight, false otherwise.
	*/
		PDFNet.PDFDraw.prototype.setHighlightFields = function(highlight)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setHighlightFields'. Expected "+1+" argument. Function Signature: setHighlightFields(boolean)")};
		if(highlight instanceof Promise) {throw new TypeError("1st input argument in function 'setHighlightFields' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof highlight != "boolean") {throw new TypeError("1st input argument '"+highlight+"' in function 'setHighlightFields' is of type '"+(typeof highlight)+"'. Expected type 'boolean'. Function Signature: setHighlightFields(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setHighlightFields', {"d": this.id, "highlight": highlight}, this.userPriority);
	},

	/**
	* Enable or disable anti-aliasing.
	*
	* Anti-Aliasing is a technique used to improve the visual
	* quality of images when displaying them on low resolution
	* devices (for example, low DPI computer monitors).
	*
	* @default Anti-aliasing is enabled by default.
	*/
		PDFNet.PDFDraw.prototype.setAntiAliasing = function(enable_aa)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAntiAliasing'. Expected "+1+" argument. Function Signature: setAntiAliasing(boolean)")};
		if(enable_aa instanceof Promise) {throw new TypeError("1st input argument in function 'setAntiAliasing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable_aa != "boolean") {throw new TypeError("1st input argument '"+enable_aa+"' in function 'setAntiAliasing' is of type '"+(typeof enable_aa)+"'. Expected type 'boolean'. Function Signature: setAntiAliasing(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setAntiAliasing', {"d": this.id, "enable_aa": enable_aa}, this.userPriority);
	},

	/**
	* Enable or disable path hinting.
	*
	* @param path_hinting if true path hinting is enabled. Path hinting is used to slightly
	* adjust paths in order to avoid or alleviate artifacts of hair line cracks between
	* certain graphical elements. This option is turned on by default.
	*
	*/
		PDFNet.PDFDraw.prototype.setPathHinting = function(enable_ph)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPathHinting'. Expected "+1+" argument. Function Signature: setPathHinting(boolean)")};
		if(enable_ph instanceof Promise) {throw new TypeError("1st input argument in function 'setPathHinting' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enable_ph != "boolean") {throw new TypeError("1st input argument '"+enable_ph+"' in function 'setPathHinting' is of type '"+(typeof enable_ph)+"'. Expected type 'boolean'. Function Signature: setPathHinting(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setPathHinting', {"d": this.id, "enable_ph": enable_ph}, this.userPriority);
	},

	/**
	* Set thin line adjustment parameters.
	*
	* @param pixel_grid_fit if true (horizontal/vertical) thin lines will be snapped to
	* integer pixel positions. This helps make thin lines look sharper and clearer. This
	* option is turned off by default and it only works if path hinting is enabled.
	*
	* @param stroke_adjust if true auto stroke adjustment is enabled. Currently, this would
	* make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
	*/
		PDFNet.PDFDraw.prototype.setThinLineAdjustment = function(grid_fit, stroke_adjust)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setThinLineAdjustment'. Expected "+2+" arguments. Function Signature: setThinLineAdjustment(boolean, boolean)")};
		if(grid_fit instanceof Promise) {throw new TypeError("1st input argument in function 'setThinLineAdjustment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof grid_fit != "boolean") {throw new TypeError("1st input argument '"+grid_fit+"' in function 'setThinLineAdjustment' is of type '"+(typeof grid_fit)+"'. Expected type 'boolean'. Function Signature: setThinLineAdjustment(boolean, boolean).");}
		if(stroke_adjust instanceof Promise) {throw new TypeError("2nd input argument in function 'setThinLineAdjustment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof stroke_adjust != "boolean") {throw new TypeError("2nd input argument '"+stroke_adjust+"' in function 'setThinLineAdjustment' is of type '"+(typeof stroke_adjust)+"'. Expected type 'boolean'. Function Signature: setThinLineAdjustment(boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setThinLineAdjustment', {"d": this.id, "grid_fit": grid_fit, "stroke_adjust": stroke_adjust}, this.userPriority);
	},

	/**
	* Sets the gamma factor used for anti-aliased rendering.
	*
	* @param exp is the exponent value of gamma function. Typical values
	* are in the range from 0.1 to 3.
	*
	* Gamma correction can be used to improve the quality of anti-aliased
	* image output and can (to some extent) decrease the appearance common
	* anti-aliasing artifacts (such as pixel width lines between polygons).
	*
	* @note Gamma correction is used only in the built-in rasterizer.
	*/
		PDFNet.PDFDraw.prototype.setGamma = function(gamma)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setGamma'. Expected "+1+" argument. Function Signature: setGamma(number)")};
		if(gamma instanceof Promise) {throw new TypeError("1st input argument in function 'setGamma' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof gamma != "number") {throw new TypeError("1st input argument '"+gamma+"' in function 'setGamma' is of type '"+(typeof gamma)+"'. Expected type 'number'. Function Signature: setGamma(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setGamma', {"d": this.id, "gamma": gamma}, this.userPriority);
	},

	/**
	* tells the rasterizer to render the page 'print' mode. Certain page elements
	* (such as annotations or OCG-s) are meant to be visible either on the screen or
	* on the printed paper but not both. A common example, is the "Submit" button on
	* electronic forms.
	*
	* @param is_printing set to true if the page should be rendered in print mode.
	* @default By default, print mode flag is set to false.
	*/
		PDFNet.PDFDraw.prototype.setPrintMode = function(is_printing)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPrintMode'. Expected "+1+" argument. Function Signature: setPrintMode(boolean)")};
		if(is_printing instanceof Promise) {throw new TypeError("1st input argument in function 'setPrintMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof is_printing != "boolean") {throw new TypeError("1st input argument '"+is_printing+"' in function 'setPrintMode' is of type '"+(typeof is_printing)+"'. Expected type 'boolean'. Function Signature: setPrintMode(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setPrintMode', {"d": this.id, "is_printing": is_printing}, this.userPriority);
	},

	/**
	* sets the page color to transparent.
	*
	* @default By default, PDFDraw assumes that the page is imposed directly on an
	* opaque white surface. Some applications may need to impose the page on a different
	* backdrop. In this case any pixels that are not covered during rendering will
	* be transparent.
	*
	* @param is_transparent If true, page's backdrop color will be transparent.
	* If false, the page's backdrop will be a opaque white.
	*
	* @note If page transparency is enabled, the alpha channel will be preserved when
	* the image is exported as PNG, TIFF(when in RGB space), or RAW.
	*/
		PDFNet.PDFDraw.prototype.setPageTransparent = function(is_transp)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPageTransparent'. Expected "+1+" argument. Function Signature: setPageTransparent(boolean)")};
		if(is_transp instanceof Promise) {throw new TypeError("1st input argument in function 'setPageTransparent' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof is_transp != "boolean") {throw new TypeError("1st input argument '"+is_transp+"' in function 'setPageTransparent' is of type '"+(typeof is_transp)+"'. Expected type 'boolean'. Function Signature: setPageTransparent(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setPageTransparent', {"d": this.id, "is_transp": is_transp}, this.userPriority);
	},

	/**
	* sets the default color of the page backdrop.
	*
	* @default By default, the page color is white.
	*
	* @param r, the red component of the page backdrop color.
	* @param g, the green component of the page backdrop color.
	* @param b, the blue component of the page backdrop color.
	*
	* @note Only when the page backdrop is not set to transparent (SetPageTransparent), default
	* page color is used.
	*/
		PDFNet.PDFDraw.prototype.setDefaultPageColor = function(r, g, b)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultPageColor'. Expected "+3+" arguments. Function Signature: setDefaultPageColor(number, number, number)")};
		if(r instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultPageColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof r != "number") {throw new TypeError("1st input argument '"+r+"' in function 'setDefaultPageColor' is of type '"+(typeof r)+"'. Expected type 'number'. Function Signature: setDefaultPageColor(number, number, number).");}
		if(g instanceof Promise) {throw new TypeError("2nd input argument in function 'setDefaultPageColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof g != "number") {throw new TypeError("2nd input argument '"+g+"' in function 'setDefaultPageColor' is of type '"+(typeof g)+"'. Expected type 'number'. Function Signature: setDefaultPageColor(number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("3rd input argument in function 'setDefaultPageColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("3rd input argument '"+b+"' in function 'setDefaultPageColor' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: setDefaultPageColor(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setDefaultPageColor', {"d": this.id, "r": r, "g": g, "b": b}, this.userPriority);
	},

	/**
	* enable or disable support for overprint and overprint simulation.
	* Overprint is a device dependent feature and the results will vary depending on
	* the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
	*
	* @default By default overprint is only enabled for PDF/X files.
	*
	* @param op e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
	*/
		PDFNet.PDFDraw.prototype.setOverprint = function(op)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOverprint'. Expected "+1+" argument. Function Signature: setOverprint(number)")};
		if(op instanceof Promise) {throw new TypeError("1st input argument in function 'setOverprint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof op != "number") {throw new TypeError("1st input argument '"+op+"' in function 'setOverprint' is of type '"+(typeof op)+"'. Expected type 'number'. Function Signature: setOverprint(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setOverprint', {"d": this.id, "op": op}, this.userPriority);
	},

	/**
	* Enable or disable image smoothing.
	*
	* The rasterizer allows a tradeoff between rendering quality and rendering speed.
	* This function can be used to indicate the preference between rendering speed and quality.
	*
	* @note image smoothing option has effect only if the source image has higher resolution
	* that the output resolution of the image on the rasterized page. PDFNet automatically
	* controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
	*
	* @param smoothing_enabled True to enable image smoothing, false otherwise.
	* @param hq_image_resampling True to use a higher quality (but slower) smoothing algorithm
	* @default image smoothing is enabled and hq_image_resampling is false.
	*/
		PDFNet.PDFDraw.prototype.setImageSmoothing = function(smoothing_enabled, hq_image_resampling)
	{
		if(typeof smoothing_enabled === "undefined") {smoothing_enabled = true;};
		if(typeof hq_image_resampling === "undefined") {hq_image_resampling = false;};
		if(arguments.length > 2) {throw new RangeError(arguments.length+" arguments passed into function 'setImageSmoothing'. Expected at most "+2+" arguments. Function Signature: setImageSmoothing(boolean, boolean)")};
		if(smoothing_enabled instanceof Promise) {throw new TypeError("1st input argument in function 'setImageSmoothing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof smoothing_enabled != "boolean") {throw new TypeError("1st input argument '"+smoothing_enabled+"' in function 'setImageSmoothing' is of type '"+(typeof smoothing_enabled)+"'. Expected type 'boolean'. Function Signature: setImageSmoothing(boolean, boolean).");}
		if(hq_image_resampling instanceof Promise) {throw new TypeError("2nd input argument in function 'setImageSmoothing' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof hq_image_resampling != "boolean") {throw new TypeError("2nd input argument '"+hq_image_resampling+"' in function 'setImageSmoothing' is of type '"+(typeof hq_image_resampling)+"'. Expected type 'boolean'. Function Signature: setImageSmoothing(boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setImageSmoothing', {"d": this.id, "smoothing_enabled": smoothing_enabled, "hq_image_resampling": hq_image_resampling}, this.userPriority);
	},

	/**
	* enables or disables caching. Caching can improve the rendering performance in cases
	* where the same page will be drawn multiple times.
	*
	* @param enabled - if true PDFRasterizer will cache frequently used graphics objects.
	*/
		PDFNet.PDFDraw.prototype.setCaching = function(enabled)
	{
		if(typeof enabled === "undefined") {enabled = true;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setCaching'. Expected at most "+1+" arguments. Function Signature: setCaching(boolean)")};
		if(enabled instanceof Promise) {throw new TypeError("1st input argument in function 'setCaching' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enabled != "boolean") {throw new TypeError("1st input argument '"+enabled+"' in function 'setCaching' is of type '"+(typeof enabled)+"'. Expected type 'boolean'. Function Signature: setCaching(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setCaching', {"d": this.id, "enabled": enabled}, this.userPriority);
	},

	/**
	* Set the color post processing transformation.
	* This transform is applied to the rasterized bitmap as the final step
	* in the rasterization process, and is applied directly to the resulting
	* bitmap (disregarding any color space information). Color post
	* processing only supported for RGBA output.
	*
	* @param mode is the specific transform to be applied
	*/
		PDFNet.PDFDraw.prototype.setColorPostProcessMode = function(mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setColorPostProcessMode'. Expected "+1+" argument. Function Signature: setColorPostProcessMode(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setColorPostProcessMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setColorPostProcessMode' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setColorPostProcessMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.setColorPostProcessMode', {"d": this.id, "mode": mode}, this.userPriority);
	},

		PDFNet.PDFNet.connectToCloud = function(username, password)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'connectToCloud'. Expected "+2+" arguments. Function Signature: connectToCloud(string, string)")};
		if(username instanceof Promise) {throw new TypeError("1st input argument in function 'connectToCloud' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof username != "string") {throw new TypeError("1st input argument '"+username+"' in function 'connectToCloud' is of type '"+(typeof username)+"'. Expected type 'string'. Function Signature: connectToCloud(string, string).");}
		if(password instanceof Promise) {throw new TypeError("2nd input argument in function 'connectToCloud' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("2nd input argument '"+password+"' in function 'connectToCloud' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: connectToCloud(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetConnectToCloud', {"username": username, "password": password}, this.userPriority);
	},

	/**
	* ConnectToCloud() is used to connect PDFNet with your 'pay-as-you-go' account
	* (http://www.pdftron.com/pws/onpremise.html).
	*
	* PDFTron Cloud is a 'pay-as-you-go' service that offers PDFTron document
	* conversion and processing capabilities with minimal startup costs.
	*
	* PDFTron Cloud account allows applications to convert documents either on your
	* own servers (e.g. using PDFNet SDK or DocPub CLI) or via PDFTron hosted REST
	* service.
	*
	* Benefits of the self-hosted model are related to privacy and increased
	* flexibility and speed from your own hardware infrastructure. On the other hand,
	* self-hosted model may be more costly due to operation fees.
	*
	* @note Please note that in order to use ConnectToCloud() you need to have a
	* valid Enterprise or Web CPU license for PDFNet. If you do not need additional
	* functionality provided by PDFNet (e.g. you simply need to convert), please use
	* DocPub CLI instead of PDFNet SDK.
	*
	* @note ConnectToCloud() should be called once, immediately after
	* PDFNet.Initialize("...license key...").
	*
	* @note List of functions supported by pay-as-you-go:
	* - FromEmf		(free)
	* - ToEmf			(free)
	* - ToSvg			(chargeable)
	* - ToPDF			(chargeable, except image to PDF)
	* - FromXps		(chargeable)
	* - ToXps			(chargeable)
	* - ToXod			(chargeable)
	* - Flattener		(chargeable)
	* - PDFACompliance	(chargeable)
	* - ToHtml			(chargeable)
	* - ToEpub			(chargeable)
	*
	* @param api_id Your API ID (i.e. username). You should receive this information
	* via email after Cloud API service (https://api.pdftron.com) sign-up. You can also
	* find your 'API ID' in the 'Account' section in your PDFTron Cloud account.
	* @param api_secret (i.e. password). This information is provided together with
	* 'api_id' and can also be retrieved from https://api.pdftron.com.
	*
	* @return A promise that resolves to cloudErrorCode will be returned. STATUS_OK if PDFNet successfully connected to your Cloud account.
	*
	* @exception If called before call to PDFNet.Initialized or in DEMO mode, the function will throw an exception.
	*/
		PDFNet.PDFNet.connectToCloudEx = function(username, password, demo_mode)
	{
		if(typeof demo_mode === "undefined") {demo_mode = false;};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'connectToCloudEx'. Expected "+2+" to "+3+" arguments. Function Signature: connectToCloudEx(string, string, boolean)")};
		if(username instanceof Promise) {throw new TypeError("1st input argument in function 'connectToCloudEx' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof username != "string") {throw new TypeError("1st input argument '"+username+"' in function 'connectToCloudEx' is of type '"+(typeof username)+"'. Expected type 'string'. Function Signature: connectToCloudEx(string, string, boolean).");}
		if(password instanceof Promise) {throw new TypeError("2nd input argument in function 'connectToCloudEx' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("2nd input argument '"+password+"' in function 'connectToCloudEx' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: connectToCloudEx(string, string, boolean).");}
		if(demo_mode instanceof Promise) {throw new TypeError("3rd input argument in function 'connectToCloudEx' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof demo_mode != "boolean") {throw new TypeError("3rd input argument '"+demo_mode+"' in function 'connectToCloudEx' is of type '"+(typeof demo_mode)+"'. Expected type 'boolean'. Function Signature: connectToCloudEx(string, string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetConnectToCloudEx', {"username": username, "password": password, "demo_mode": demo_mode}, this.userPriority);
	},

	/**
	* terminates PDFNet library.
	* Terminate() is usually called once, when the process is terminated.
	*
	* @note it is unsafe to call any other PDFNet API after you terminate
	* the library.
	*/
		PDFNet.PDFNet.terminate = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'terminate'. Expected "+0+" arguments. Function Signature: terminate()")};
		return PDFNet.messageHandler.sendWithPromise('pdfNetTerminate', {}, this.userPriority);
	},

	/**
	* Sets the location of PDFNet resource file.
	*
	* @note Starting with v.4.5 PDFNet no longer requires a seperate resource file,
	* and so this function is not required for proper PDFNet initialization. It remains
	* available for backward compatibility.
	* On mobile systems (iOS, Android, etc.) this method is required for proper
	* initialization starting with version 6.0. (This helps reduce overall app size.)
	* The function can be used on all platforms to specify a default search path for
	* ICC profiles, fonts, and other user defined resources.
	*
	* @param path - The default resource directory path.
	* @return A promise that resolves to true if path is found, false otherwise.
	*/
		PDFNet.PDFNet.setResourcesPath = function(path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setResourcesPath'. Expected "+1+" argument. Function Signature: setResourcesPath(string)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'setResourcesPath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'setResourcesPath' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: setResourcesPath(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetResourcesPath', {"path": path}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the location of PDFNet resources folder. Empty string means
	* that resources are located in your application folder.
	*/
		PDFNet.PDFNet.getResourcesPath = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getResourcesPath'. Expected "+0+" arguments. Function Signature: getResourcesPath()")};
		return PDFNet.messageHandler.sendWithPromise('pdfNetGetResourcesPath', {}, this.userPriority);
	},

		PDFNet.PDFNet.setResourceData = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setResourceData'. Expected "+1+" argument. Function Signature: setResourceData(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'setResourceData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'setResourceData' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: setResourceData(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'setResourceData' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: setResourceData(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetResourceData', {"buf": buf.buffer}, this.userPriority);
	},

	/**
	* used to set a specific Color Management System (CMS) for
	* use during color conversion operators, image rendering, etc.
	*
	* @param t identifies the type of color management to use.
	*/
		PDFNet.PDFNet.setColorManagement = function(t)
	{
		if(typeof t === "undefined") {t = exports.PDFNet.PDFNet.CMSType.e_lcms};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setColorManagement'. Expected at most "+1+" arguments. Function Signature: setColorManagement(number)")};
		if(t instanceof Promise) {throw new TypeError("1st input argument in function 'setColorManagement' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t != "number") {throw new TypeError("1st input argument '"+t+"' in function 'setColorManagement' is of type '"+(typeof t)+"'. Expected type 'number'. Function Signature: setColorManagement(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetColorManagement', {"t": t}, this.userPriority);
	},

	/**
	* sets the default ICC color profile for DeviceCMYK color space.
	*
	* @note You can use this method to override default PDFNet settings.
	* For more information on default color spaces please refer to
	* section 'Default Color Spaces' in Chapter 4.5.4 of PDF Reference Manual.
	*
	* @exception the function will throw Exception if the ICC profile
	* can't be found or if it fails to open.
	*/
		PDFNet.PDFNet.setDefaultDeviceCMYKProfile = function(icc_filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultDeviceCMYKProfile'. Expected "+1+" argument. Function Signature: setDefaultDeviceCMYKProfile(string)")};
		if(icc_filename instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultDeviceCMYKProfile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof icc_filename != "string") {throw new TypeError("1st input argument '"+icc_filename+"' in function 'setDefaultDeviceCMYKProfile' is of type '"+(typeof icc_filename)+"'. Expected type 'string'. Function Signature: setDefaultDeviceCMYKProfile(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetDefaultDeviceCMYKProfile', {"icc_filename": icc_filename}, this.userPriority);
	},

	/**
	* sets the default ICC color profile for DeviceRGB color space.
	*
	* @note You can use this method to override default PDFNet settings.
	* For more information on default color spaces please refer to
	* section 'Default Color Spaces' in Chapter 4.5.4 of PDF Reference Manual.
	*
	* @exception the function will throw Exception if the ICC profile
	* can't be found or if it fails to open.
	*/
		PDFNet.PDFNet.setDefaultDeviceRGBProfile = function(icc_filename)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultDeviceRGBProfile'. Expected "+1+" argument. Function Signature: setDefaultDeviceRGBProfile(string)")};
		if(icc_filename instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultDeviceRGBProfile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof icc_filename != "string") {throw new TypeError("1st input argument '"+icc_filename+"' in function 'setDefaultDeviceRGBProfile' is of type '"+(typeof icc_filename)+"'. Expected type 'string'. Function Signature: setDefaultDeviceRGBProfile(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetDefaultDeviceRGBProfile', {"icc_filename": icc_filename}, this.userPriority);
	},

	/**
	* sets the default policy on using temporary files.
	*
	* @use_disk if parameter is true then new documents are allowed to create
	* temporary files; otherwise all document contents will be stored in memory.
	*/
		PDFNet.PDFNet.setDefaultDiskCachingEnabled = function(use_disk)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultDiskCachingEnabled'. Expected "+1+" argument. Function Signature: setDefaultDiskCachingEnabled(boolean)")};
		if(use_disk instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultDiskCachingEnabled' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof use_disk != "boolean") {throw new TypeError("1st input argument '"+use_disk+"' in function 'setDefaultDiskCachingEnabled' is of type '"+(typeof use_disk)+"'. Expected type 'boolean'. Function Signature: setDefaultDiskCachingEnabled(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetDefaultDiskCachingEnabled', {"use_disk": use_disk}, this.userPriority);
	},

	/**
	*  sets the default compression level for Flate (ZLib).
	*
	*	@param level An integer in range 0-9 representing the compression value to use as
	*  a default for any Flate streams (e.g used to compress content streams, PNG images, etc).
	*  The library normally uses the default compression level (Z_DEFAULT_COMPRESSION).
	*  For most images, compression values in the range 3-6 compress nearly as well as higher
	*  levels, and do so much faster. For on-line applications it may be desirable to have
	*  maximum speed Z_BEST_SPEED = 1). You can also specify no compression (Z_NO_COMPRESSION = 0).
	*
	*	@default Z_DEFAULT_COMPRESSION (-1).
	*/
		PDFNet.PDFNet.setDefaultFlateCompressionLevel = function(level)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setDefaultFlateCompressionLevel'. Expected "+1+" argument. Function Signature: setDefaultFlateCompressionLevel(number)")};
		if(level instanceof Promise) {throw new TypeError("1st input argument in function 'setDefaultFlateCompressionLevel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof level != "number") {throw new TypeError("1st input argument '"+level+"' in function 'setDefaultFlateCompressionLevel' is of type '"+(typeof level)+"'. Expected type 'number'. Function Signature: setDefaultFlateCompressionLevel(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetDefaultFlateCompressionLevel', {"level": level}, this.userPriority);
	},

	/**
	*
	*  Sets the default parameters for the viewer cache. Any subsequently created documents
	*	will use these parameters.
	*
	*	@param max_cache_size - The maximum size, in bytes, of the entire document's page cache. Set to zero to disable the viewer cache.
	*	@param on_disk - If set to 'true', cache will be stored on the local filesystem. If set to 'false', cache will be stored in heap memory.
	*
	*	@default Desktop: max_cache_size = 512 MB, on_disk = true | Mobile:  max_cache_size = 100 MB, on_disk = false
	*/
		PDFNet.PDFNet.setViewerCache = function(max_cache_size, on_disk)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setViewerCache'. Expected "+2+" arguments. Function Signature: setViewerCache(number, boolean)")};
		if(max_cache_size instanceof Promise) {throw new TypeError("1st input argument in function 'setViewerCache' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof max_cache_size != "number") {throw new TypeError("1st input argument '"+max_cache_size+"' in function 'setViewerCache' is of type '"+(typeof max_cache_size)+"'. Expected type 'number'. Function Signature: setViewerCache(number, boolean).");}
		if(on_disk instanceof Promise) {throw new TypeError("2nd input argument in function 'setViewerCache' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof on_disk != "boolean") {throw new TypeError("2nd input argument '"+on_disk+"' in function 'setViewerCache' is of type '"+(typeof on_disk)+"'. Expected type 'boolean'. Function Signature: setViewerCache(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetViewerCache', {"max_cache_size": max_cache_size, "on_disk": on_disk}, this.userPriority);
	},

	/**
	* addFontSubst functions can be used to create font substitutes
	* that can override default PDFNet font selection algorithm.
	*
	* These functions are useful in situations where referenced fonts
	* are not present in the document and PDFNet font substitution
	* algorithm is not producing desired results.
	*
	* AddFontSubst(fontname, fontpath) maps the given font name (i.e. 'BaseFont'
	* entry from the font dictionary) to a font file.
	*
	* AddFontSubst(ordering, fontpath) maps the given character ordering (see
	* Ordering entry in CIDSystemInfo dictionary; Section 5.6.2 in PDF Reference)
	* to a font file. This method is less specific that the former variant of
	* AddFontSubst, and can be used to override a range of missing fonts (or
	* any missing font) with a predefined substitute.
	*
	* The following is an example of using these functions to provide user
	* defined font substitutes:
	*
	* @code
	* PDFNet::Initialize();
	* PDFNet::SetResourcesPath("c:/myapp/resources");
	* // Specify specific font mappings...
	* PDFNet::AddFontSubst("MinionPro-Regular", "c:/myfonts/MinionPro-Regular.otf");
	* PDFNet::AddFontSubst("Times-Roman", "c:/windows/fonts/times.ttf");
	* PDFNet::AddFontSubst("Times-Italic", "c:/windows/fonts/timesi.ttf");
	*
	* // Specify more general font mappings...
	* PDFNet::AddFontSubst(PDFNet::e_Identity, "c:/myfonts/arialuni.ttf");  // Arial Unicode MS
	* PDFNet::AddFontSubst(PDFNet::e_Japan1, "c:/myfonts/KozMinProVI-Regular.otf");
	* PDFNet::AddFontSubst(PDFNet::e_Japan2, "c:/myfonts/KozMinProVI-Regular.otf");
	* PDFNet::AddFontSubst(PDFNet::e_Korea1, "c:/myfonts/AdobeSongStd-Light.otf");
	* PDFNet::AddFontSubst(PDFNet::e_CNS1, "c:/myfonts/AdobeMingStd-Light.otf");
	* PDFNet::AddFontSubst(PDFNet::e_GB1, "c:/myfonts/AdobeMyungjoStd-Medium.otf");
	* ...
	* PDFDoc doc("c:/my.pdf");
	* ...
	* @endcode
	*/
		PDFNet.PDFNet.addFontSubstFromName = function(fontname, fontpath)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addFontSubstFromName'. Expected "+2+" arguments. Function Signature: addFontSubstFromName(string, string)")};
		if(fontname instanceof Promise) {throw new TypeError("1st input argument in function 'addFontSubstFromName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof fontname != "string") {throw new TypeError("1st input argument '"+fontname+"' in function 'addFontSubstFromName' is of type '"+(typeof fontname)+"'. Expected type 'string'. Function Signature: addFontSubstFromName(string, string).");}
		if(fontpath instanceof Promise) {throw new TypeError("2nd input argument in function 'addFontSubstFromName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof fontpath != "string") {throw new TypeError("2nd input argument '"+fontpath+"' in function 'addFontSubstFromName' is of type '"+(typeof fontpath)+"'. Expected type 'string'. Function Signature: addFontSubstFromName(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetAddFontSubstFromName', {"fontname": fontname, "fontpath": fontpath}, this.userPriority);
	},

		PDFNet.PDFNet.addFontSubst = function(ordering, fontpath)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'addFontSubst'. Expected "+2+" arguments. Function Signature: addFontSubst(number, string)")};
		if(ordering instanceof Promise) {throw new TypeError("1st input argument in function 'addFontSubst' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ordering != "number") {throw new TypeError("1st input argument '"+ordering+"' in function 'addFontSubst' is of type '"+(typeof ordering)+"'. Expected type 'number'. Function Signature: addFontSubst(number, string).");}
		if(fontpath instanceof Promise) {throw new TypeError("2nd input argument in function 'addFontSubst' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof fontpath != "string") {throw new TypeError("2nd input argument '"+fontpath+"' in function 'addFontSubst' is of type '"+(typeof fontpath)+"'. Expected type 'string'. Function Signature: addFontSubst(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetAddFontSubst', {"ordering": ordering, "fontpath": fontpath}, this.userPriority);
	},

	/**
	* Set the location of temporary folder.
	*
	* This method is provided for applications that require tight control of
	* the location where temporary files are created.
	*/
		PDFNet.PDFNet.setTempPath = function(temp_path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTempPath'. Expected "+1+" argument. Function Signature: setTempPath(string)")};
		if(temp_path instanceof Promise) {throw new TypeError("1st input argument in function 'setTempPath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof temp_path != "string") {throw new TypeError("1st input argument '"+temp_path+"' in function 'setTempPath' is of type '"+(typeof temp_path)+"'. Expected type 'string'. Function Signature: setTempPath(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetTempPath', {"temp_path": temp_path}, this.userPriority);
	},

	/**
	* Set the location of persistent cache files.
	*
	* This method is provided for applications that require tight control of
	* the location where temporary files are created.
	*/
		PDFNet.PDFNet.setPersistentCachePath = function(persistent_path)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPersistentCachePath'. Expected "+1+" argument. Function Signature: setPersistentCachePath(string)")};
		if(persistent_path instanceof Promise) {throw new TypeError("1st input argument in function 'setPersistentCachePath' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof persistent_path != "string") {throw new TypeError("1st input argument '"+persistent_path+"' in function 'setPersistentCachePath' is of type '"+(typeof persistent_path)+"'. Expected type 'string'. Function Signature: setPersistentCachePath(string).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetPersistentCachePath', {"persistent_path": persistent_path}, this.userPriority);
	},

	/**
	* @return A promise that resolves to pDFNet version number.
	*/
		PDFNet.PDFNet.getVersion = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getVersion'. Expected "+0+" arguments. Function Signature: getVersion()")};
		return PDFNet.messageHandler.sendWithPromise('pdfNetGetVersion', {}, this.userPriority);
	},

	/**
	* @return A promise that resolves to iterator to the first SecurityDescriptor in the list of currently
	* registered SecurityHandler types.
	*/
		PDFNet.PDFNet.getSecHdlrInfoIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSecHdlrInfoIterator'. Expected "+0+" arguments. Function Signature: getSecHdlrInfoIterator()")};
		return PDFNet.messageHandler.sendWithPromise('pdfNetGetSecHdlrInfoIterator', {}, this.userPriority).then(function(id){
			//there is a return type Iterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id);
		});
	},

		PDFNet.PDFNet.setLogLevel = function(level)
	{
		if(typeof level === "undefined") {level = exports.PDFNet.PDFNet.LogLevel.e_LogLevel_Fatal};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setLogLevel'. Expected at most "+1+" arguments. Function Signature: setLogLevel(number)")};
		if(level instanceof Promise) {throw new TypeError("1st input argument in function 'setLogLevel' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof level != "number") {throw new TypeError("1st input argument '"+level+"' in function 'setLogLevel' is of type '"+(typeof level)+"'. Expected type 'number'. Function Signature: setLogLevel(number).");}
		return PDFNet.messageHandler.sendWithPromise('pdfNetSetLogLevel', {"level": level}, this.userPriority);
	},

	/**
	* Create a Rect and initialize it using specified parameters.
	* The rect is not attached to any Cos/SDF object.
	*/
		PDFNet.Rect.init = function(x1, y1, x2, y2)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'init'. Expected "+4+" arguments. Function Signature: init(number, number, number, number)")};
		if(x1 instanceof Promise) {throw new TypeError("1st input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x1 != "number") {throw new TypeError("1st input argument '"+x1+"' in function 'init' is of type '"+(typeof x1)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(y1 instanceof Promise) {throw new TypeError("2nd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y1 != "number") {throw new TypeError("2nd input argument '"+y1+"' in function 'init' is of type '"+(typeof y1)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("3rd input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("3rd input argument '"+x2+"' in function 'init' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("4th input argument in function 'init' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("4th input argument '"+y2+"' in function 'init' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: init(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('rectInit', {"x1": x1, "y1": y1, "x2": x2, "y2": y2}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

		PDFNet.Rect.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Rect)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Rect) && right.name != "Rect") {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Rect'. Function Signature: assign(Rect).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Rect'. Function Signature: assign(Rect).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'assign'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof right.yieldFunction != "undefined") {throw new Error("Function '"+right.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'assign'. Perhaps a yield statement is required for '"+right.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Rect.assign"; // TRN_Rect* left
		return PDFNet.messageHandler.sendWithPromise('Rect.assign', {"left": this, "right": right}, this.userPriority).then(function(id){
			copyFunc(id.left, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* attach the Cos/SDF object to the Rect.
	*
	* @param rect - underlying Cos/SDF object. Must be an SDF::Array with four
	*  SDF::Number elements.
	*/
		PDFNet.Rect.prototype.attach = function(obj)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'attach'. Expected "+1+" argument. Function Signature: attach(Obj)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'attach' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'attach' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: attach(Obj).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'attach' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: attach(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'attach'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.attach"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.attach', {"rect": this, "obj": obj.id}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Saves changes made to the Rect object in the attached (or specified) SDF/Cos rectangle.
	*
	* @param rect - an optional parameter indicating a SDF array that should be
	*  updated and attached to this Rect. If parameter rect is NULL or is omitted, update
	*  is performed on previously attached Cos/SDF rectangle.
	*
	* @return A promise that resolves to true if the attached Cos/SDF rectangle array was successfully updated,
	* false otherwise.
	*/
		PDFNet.Rect.prototype.update = function(obj)
	{
		if(typeof obj === "undefined") {obj = new PDFNet.Obj("__null");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'update'. Expected at most "+1+" arguments. Function Signature: update(Obj)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'update' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'update' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: update(Obj).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'update' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: update(Obj).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'update'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.update"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.update', {"rect": this, "obj": obj.id}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* Get the coordinates of the rectangle
	*/
		PDFNet.Rect.prototype.get = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'get'. Expected "+0+" arguments. Function Signature: get()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'get'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Rect.get', {"rect": this}, this.userPriority);
	},

	/**
	* Set the coordinates of the rectangle
	*/
		PDFNet.Rect.prototype.set = function(x1, y1, x2, y2)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'set'. Expected "+4+" arguments. Function Signature: set(number, number, number, number)")};
		if(x1 instanceof Promise) {throw new TypeError("1st input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x1 != "number") {throw new TypeError("1st input argument '"+x1+"' in function 'set' is of type '"+(typeof x1)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(y1 instanceof Promise) {throw new TypeError("2nd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y1 != "number") {throw new TypeError("2nd input argument '"+y1+"' in function 'set' is of type '"+(typeof y1)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("3rd input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("3rd input argument '"+x2+"' in function 'set' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("4th input argument in function 'set' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("4th input argument '"+y2+"' in function 'set' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: set(number, number, number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'set'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.set"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.set', {"rect": this, "x1": x1, "y1": y1, "x2": x2, "y2": y2}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to rectangle's width
	*/
		PDFNet.Rect.prototype.width = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'width'. Expected "+0+" arguments. Function Signature: width()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'width'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Rect.width', {"rect": this}, this.userPriority);
	},

	/**
	* @return A promise that resolves to rectangle's height
	*/
		PDFNet.Rect.prototype.height = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'height'. Expected "+0+" arguments. Function Signature: height()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'height'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Rect.height', {"rect": this}, this.userPriority);
	},

	/**
	* Determines if the specified point is contained within the rectangular region
	* defined by this Rectangle
	*
	* @return A promise that resolves to true is the point is in the rectangle, false otherwise.
	*/
		PDFNet.Rect.prototype.contains = function(x, y)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'contains'. Expected "+2+" arguments. Function Signature: contains(number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'contains' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'contains' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: contains(number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'contains' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'contains' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: contains(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'contains'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		return PDFNet.messageHandler.sendWithPromise('Rect.contains', {"rect": this, "x": x, "y": y}, this.userPriority);
	},

	/**
	* Makes a Rect equal to the intersection of two existing rectangles.
	*
	* @param rect1 - A Rect object that contains a source rectangle.
	* @param rect2 - A Rect object that contains a source rectangle.
	*
	* @return A promise that resolves to true if the intersection is not empty; 0 if the intersection is empty.
	*
	* @note The intersection is the largest rectangle contained in both existing rectangles.
	*/
		PDFNet.Rect.prototype.intersectRect = function(rect1, rect2)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'intersectRect'. Expected "+2+" arguments. Function Signature: intersectRect(Rect, Rect)")};
		if(rect1 instanceof Promise) {throw new TypeError("1st input argument in function 'intersectRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(rect1 instanceof PDFNet.Rect) && rect1.name != "Rect") {
			if(typeof rect1 == "object") {throw new TypeError("1st input argument in function 'intersectRect' is of type '"+rect1.name+"'. Expected type 'Rect'. Function Signature: intersectRect(Rect, Rect).");}
			else {throw new TypeError("1st input argument '"+rect1+"' in function 'intersectRect' is of type '"+(typeof rect1)+"'. Expected type 'Rect'. Function Signature: intersectRect(Rect, Rect).");}
		}
		if(rect2 instanceof Promise) {throw new TypeError("2nd input argument in function 'intersectRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(rect2 instanceof PDFNet.Rect) && rect2.name != "Rect") {
			if(typeof rect2 == "object") {throw new TypeError("2nd input argument in function 'intersectRect' is of type '"+rect2.name+"'. Expected type 'Rect'. Function Signature: intersectRect(Rect, Rect).");}
			else {throw new TypeError("2nd input argument '"+rect2+"' in function 'intersectRect' is of type '"+(typeof rect2)+"'. Expected type 'Rect'. Function Signature: intersectRect(Rect, Rect).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'intersectRect'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof rect1.yieldFunction != "undefined") {throw new Error("Function '"+rect1.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'intersectRect'. Perhaps a yield statement is required for '"+rect1.yieldFunction+"'?");}
		if(typeof rect2.yieldFunction != "undefined") {throw new Error("Function '"+rect2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'intersectRect'. Perhaps a yield statement is required for '"+rect2.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Rect.intersectRect"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.intersectRect', {"rect": this, "rect1": rect1, "rect2": rect2}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/**
	* Arrange the points in the rectangle so that the first point is the lower-left
	* corner and the second point is the upper-right corner of the rectangle.
	*
	* @note Although rectangles are conventionally specified by their lower-left
	* and upper-right corners, it is acceptable to specify any two diagonally
	* opposite corners.
	*/
		PDFNet.Rect.prototype.normalize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'normalize'. Expected "+0+" arguments. Function Signature: normalize()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'normalize'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.normalize"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.normalize', {"rect": this}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Expands the rectangle by the specified size, in all directions.
	*
	* @param amount Specifies the amount to increase the rectangle in all directions.
	*/
		PDFNet.Rect.prototype.inflate1 = function(amount)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'inflate1'. Expected "+1+" argument. Function Signature: inflate1(number)")};
		if(amount instanceof Promise) {throw new TypeError("1st input argument in function 'inflate1' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof amount != "number") {throw new TypeError("1st input argument '"+amount+"' in function 'inflate1' is of type '"+(typeof amount)+"'. Expected type 'number'. Function Signature: inflate1(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'inflate1'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.inflate1"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.inflate1', {"rect": this, "amount": amount}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Expands the rectangle by the specified size, in all directions.
	*
	* @param x Specifies the amount to increase the rectangle's Left (x1) and Right (x2) properties.
	* @param y Specifies the amount to increase the rectangle's Top (y1) and Bottom (y1) properties.
	*/
		PDFNet.Rect.prototype.inflate2 = function(x, y)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'inflate2'. Expected "+2+" arguments. Function Signature: inflate2(number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'inflate2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'inflate2' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: inflate2(number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'inflate2' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'inflate2' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: inflate2(number, number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'inflate2'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "Rect.inflate2"; // TRN_Rect* rect
		return PDFNet.messageHandler.sendWithPromise('Rect.inflate2', {"rect": this, "x": x, "y": y}, this.userPriority).then(function(id){
			copyFunc(id.rect, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.Redactor.RedactionCreate = function(page_num, bbox, negative, text)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'RedactionCreate'. Expected "+4+" arguments. Function Signature: RedactionCreate(number, Rect, boolean, string)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'RedactionCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'RedactionCreate' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: RedactionCreate(number, Rect, boolean, string).");}
		if(bbox instanceof Promise) {throw new TypeError("2nd input argument in function 'RedactionCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(bbox instanceof PDFNet.Rect) && bbox.name != "Rect") {
			if(typeof bbox == "object") {throw new TypeError("2nd input argument in function 'RedactionCreate' is of type '"+bbox.name+"'. Expected type 'Rect'. Function Signature: RedactionCreate(number, Rect, boolean, string).");}
			else {throw new TypeError("2nd input argument '"+bbox+"' in function 'RedactionCreate' is of type '"+(typeof bbox)+"'. Expected type 'Rect'. Function Signature: RedactionCreate(number, Rect, boolean, string).");}
		}
		if(negative instanceof Promise) {throw new TypeError("3rd input argument in function 'RedactionCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof negative != "boolean") {throw new TypeError("3rd input argument '"+negative+"' in function 'RedactionCreate' is of type '"+(typeof negative)+"'. Expected type 'boolean'. Function Signature: RedactionCreate(number, Rect, boolean, string).");}
		if(text instanceof Promise) {throw new TypeError("4th input argument in function 'RedactionCreate' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text != "string") {throw new TypeError("4th input argument '"+text+"' in function 'RedactionCreate' is of type '"+(typeof text)+"'. Expected type 'string'. Function Signature: RedactionCreate(number, Rect, boolean, string).");}
		if(typeof bbox.yieldFunction != "undefined") {throw new Error("Function '"+bbox.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'RedactionCreate'. Perhaps a yield statement is required for '"+bbox.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('redactor_RedactionCreate', {"page_num": page_num, "bbox": bbox, "negative": negative, "text": text}, this.userPriority).then(function(id){
			//there is a return type Redaction
			if(id == "0"){
				return null;
			}
			return new PDFNet.Redaction(id);
		});
	},

		PDFNet.Redactor.RedactionDestroy = function(redaction)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'RedactionDestroy'. Expected "+1+" argument. Function Signature: RedactionDestroy(Redaction)")};
		if(redaction instanceof Promise) {throw new TypeError("1st input argument in function 'RedactionDestroy' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(redaction instanceof PDFNet.Redaction)) {
			if(typeof redaction == "object") {throw new TypeError("1st input argument in function 'RedactionDestroy' is of type '"+redaction.name+"'. Expected type 'Redaction'. Function Signature: RedactionDestroy(Redaction).");}
			else {throw new TypeError("1st input argument '"+redaction+"' in function 'RedactionDestroy' is of type '"+(typeof redaction)+"'. Expected type 'Redaction'. Function Signature: RedactionDestroy(Redaction).");}
		}
		return PDFNet.messageHandler.sendWithPromise('redactor_RedactionDestroy', {"redaction": redaction.id}, this.userPriority);
	},

		PDFNet.Redactor.RedactionCopy = function(other)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'RedactionCopy'. Expected "+1+" argument. Function Signature: RedactionCopy(Redaction)")};
		if(other instanceof Promise) {throw new TypeError("1st input argument in function 'RedactionCopy' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(other instanceof PDFNet.Redaction)) {
			if(typeof other == "object") {throw new TypeError("1st input argument in function 'RedactionCopy' is of type '"+other.name+"'. Expected type 'Redaction'. Function Signature: RedactionCopy(Redaction).");}
			else {throw new TypeError("1st input argument '"+other+"' in function 'RedactionCopy' is of type '"+(typeof other)+"'. Expected type 'Redaction'. Function Signature: RedactionCopy(Redaction).");}
		}
		return PDFNet.messageHandler.sendWithPromise('redactor_RedactionCopy', {"other": other.id}, this.userPriority).then(function(id){
			//there is a return type Redaction
			if(id == "0"){
				return null;
			}
			return new PDFNet.Redaction(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.RedactionAppearance.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('RedactionAppearance.destroy', {"app": this.id}, this.userPriority);
	},

		PDFNet.Redactor.redact = function(doc, red_arr, buf_size, appearance, ext_neg_mode, page_coord_sys)
	{
		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'redact'. Expected "+6+" arguments. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'redact' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'redact' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		if(red_arr instanceof Promise) {throw new TypeError("2nd input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(red_arr instanceof PDFNet.Redaction)) {
			if(typeof red_arr == "object") {throw new TypeError("2nd input argument in function 'redact' is of type '"+red_arr.name+"'. Expected type 'Redaction'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("2nd input argument '"+red_arr+"' in function 'redact' is of type '"+(typeof red_arr)+"'. Expected type 'Redaction'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		if(buf_size instanceof Promise) {throw new TypeError("3rd input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof buf_size != "number") {throw new TypeError("3rd input argument '"+buf_size+"' in function 'redact' is of type '"+(typeof buf_size)+"'. Expected type 'number'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		if(appearance instanceof Promise) {throw new TypeError("4th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(appearance instanceof PDFNet.RedactionAppearance)) {
			if(typeof appearance == "object") {throw new TypeError("4th input argument in function 'redact' is of type '"+appearance.name+"'. Expected type 'RedactionAppearance'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("4th input argument '"+appearance+"' in function 'redact' is of type '"+(typeof appearance)+"'. Expected type 'RedactionAppearance'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		if(ext_neg_mode instanceof Promise) {throw new TypeError("5th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ext_neg_mode != "boolean") {throw new TypeError("5th input argument '"+ext_neg_mode+"' in function 'redact' is of type '"+(typeof ext_neg_mode)+"'. Expected type 'boolean'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		if(page_coord_sys instanceof Promise) {throw new TypeError("6th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_coord_sys != "boolean") {throw new TypeError("6th input argument '"+page_coord_sys+"' in function 'redact' is of type '"+(typeof page_coord_sys)+"'. Expected type 'boolean'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('redactorRedact', {"doc": doc.id, "red_arr": red_arr, "buf_size": buf_size, "appearance": appearance.id, "ext_neg_mode": ext_neg_mode, "page_coord_sys": page_coord_sys}, this.userPriority);
	},

	/**
	* Create a Shading from the given SDF/Cos object listed under /Shading entry
	* in the page Resource dictionary. If shading_dict dictionary is null, a non valid Shading
	* object is created.
	*/
		PDFNet.Shading.create = function(shading_dict)
	{
		if(typeof shading_dict === "undefined") {shading_dict = new PDFNet.Obj("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected at most "+1+" arguments. Function Signature: create(Obj)")};
		if(shading_dict instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(shading_dict instanceof PDFNet.Obj)) {
			if(typeof shading_dict == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+shading_dict.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+shading_dict+"' in function 'create' is of type '"+(typeof shading_dict)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('shadingCreate', {"shading_dict": shading_dict.id}, this.userPriority).then(function(id){
			//there is a return type Shading
			if(id == "0"){
				return null;
			}
			return new PDFNet.Shading(id);
		});
	},

		PDFNet.Shading.prototype.assign = function(right)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'assign'. Expected "+1+" argument. Function Signature: assign(Shading)")};
		if(right instanceof Promise) {throw new TypeError("1st input argument in function 'assign' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(right instanceof PDFNet.Shading)) {
			if(typeof right == "object") {throw new TypeError("1st input argument in function 'assign' is of type '"+right.name+"'. Expected type 'Shading'. Function Signature: assign(Shading).");}
			else {throw new TypeError("1st input argument '"+right+"' in function 'assign' is of type '"+(typeof right)+"'. Expected type 'Shading'. Function Signature: assign(Shading).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Shading.assign', {"left": this.id, "right": right.id}, this.userPriority);
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Shading.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.destroy', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the Type of a given SDF/Cos shading dictionary, or e_null for if
	* SDF object is not a valid shading object
	*
	* @param cs
	*/
		PDFNet.Shading.getTypeFromObj = function(shading_dict)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTypeFromObj'. Expected "+1+" argument. Function Signature: getTypeFromObj(Obj)")};
		if(shading_dict instanceof Promise) {throw new TypeError("1st input argument in function 'getTypeFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(shading_dict instanceof PDFNet.Obj)) {
			if(typeof shading_dict == "object") {throw new TypeError("1st input argument in function 'getTypeFromObj' is of type '"+shading_dict.name+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+shading_dict+"' in function 'getTypeFromObj' is of type '"+(typeof shading_dict)+"'. Expected type 'Obj'. Function Signature: getTypeFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('shadingGetTypeFromObj', {"shading_dict": shading_dict.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the shading type
	*/
		PDFNet.Shading.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getType', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the underlying SDF/Cos object
	*/
		PDFNet.Shading.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getSDFObj', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the color space in which color values are expressed.
	* This may be any device, CIE-based, or special color space
	* except a Pattern space.
	*/
		PDFNet.Shading.prototype.getBaseColorSpace = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBaseColorSpace'. Expected "+0+" arguments. Function Signature: getBaseColorSpace()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getBaseColorSpace', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorSpace
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorSpace(id);
		});
	},

	/**
	* @return A promise that resolves to true if shading has a bounding box, false otherwise.
	*/
		PDFNet.Shading.prototype.hasBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasBBox'. Expected "+0+" arguments. Function Signature: hasBBox()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.hasBBox', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a rectangle giving the left, bottom, right, and top
	* coordinates, respectively, of the shading's bounding box. The coordinates
	* are interpreted in the shading's target coordinate space. If present, this
	* bounding box is applied as a temporary clipping boundary when the shading
	* is painted, in addition to the current clipping path and any other clipping
	* boundaries in effect at that time.
	*
	* @note Use HasBBox() method to determine whether the shading has a
	* background color.
	*/
		PDFNet.Shading.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getBBox', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Rect
			if(id == "0"){
				return null;
			}
			return new PDFNet.Rect(id);
		});
	},

	/**
	* @return A promise that resolves to true if the shading has a background color or false otherwise.
	*/
		PDFNet.Shading.prototype.hasBackground = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasBackground'. Expected "+0+" arguments. Function Signature: hasBackground()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.hasBackground', {"s": this.id}, this.userPriority);
	},

	/**
	* An color point represented in base color space specifying a single
	* background color value. If present, this color is used before
	* any painting operation involving the shading, to fill those portions of the
	* area to be painted that lie outside the bounds of the shading object itself.
	* In the opaque imaging model, the effect is as if the painting operation were
	* performed twice: first with the background color and then again with the
	* shading.
	*
	* @note The background color is applied only when the shading is used as part
	* of a shading pattern, not when it is painted directly with the sh operator.
	*
	* @note Use HasBackground() method to determine whether the shading has a
	* background color.
	*/
		PDFNet.Shading.prototype.getBackground = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBackground'. Expected "+0+" arguments. Function Signature: getBackground()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getBackground', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type ColorPt
			if(id == "0"){
				return null;
			}
			return new PDFNet.ColorPt(id);
		});
	},

	/**
	* @return A promise that resolves to a flag indicating whether to filter the shading function to prevent
	* aliasing artifacts. See Table 4.25
	*/
		PDFNet.Shading.prototype.getAntialias = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getAntialias'. Expected "+0+" arguments. Function Signature: getAntialias()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getAntialias', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a number specifying the limiting value of a parametric variable t.
	* The variable is considered to vary linearly between GetParamStart() and
	* GetParamEnd() as the color gradient varies between the starting and ending points
	* of the axis for Axial shading or circles for Radial shading.
	* The variable t becomes the input argument to the color function(s).
	* @note the returned value corresponds to the first value in Domain array.
	*
	* @note for shadings other than Axial or Radial this method throws an exception.
	*/
		PDFNet.Shading.prototype.getParamStart = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParamStart'. Expected "+0+" arguments. Function Signature: getParamStart()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getParamStart', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a number specifying the limiting value of a parametric variable t.
	* The variable is considered to vary linearly between GetParamStart() and
	* GetParamEnd() as the color gradient varies between the starting and ending points
	* of the axis for Axial shading or circles for Radial shading.
	* The variable t becomes the input argument to the color function(s).
	* @note the returned value corresponds to the second value in Domain array.
	*
	* @note for shadings other than Axial or Radial this method throws an exception.
	*/
		PDFNet.Shading.prototype.getParamEnd = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParamEnd'. Expected "+0+" arguments. Function Signature: getParamEnd()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getParamEnd', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a flag specifying whether to extend the shading beyond the starting
	* point of the axis for Axial shading or starting circle for Radial shading.
	*
	* @note for shadings other than Axial or Radial this method throws an exception.
	*/
		PDFNet.Shading.prototype.isExtendStart = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isExtendStart'. Expected "+0+" arguments. Function Signature: isExtendStart()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.isExtendStart', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a flag specifying whether to extend the shading beyond the ending
	* point of the axis for Axial shading or ending circle for Radial shading.
	*
	* @note for shadings other than Axial or Radial this method throws an exception.
	*/
		PDFNet.Shading.prototype.isExtendEnd = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isExtendEnd'. Expected "+0+" arguments. Function Signature: isExtendEnd()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.isExtendEnd', {"s": this.id}, this.userPriority);
	},

		PDFNet.Shading.prototype.getColor = function(t)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getColor'. Expected "+1+" argument. Function Signature: getColor(number)")};
		if(t instanceof Promise) {throw new TypeError("1st input argument in function 'getColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t != "number") {throw new TypeError("1st input argument '"+t+"' in function 'getColor' is of type '"+(typeof t)+"'. Expected type 'number'. Function Signature: getColor(number).");}
		var me = this;
		this.yieldFunction = "Shading.getColor"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('Shading.getColor', {"s": this.id, "t": t}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.Shading.prototype.getCoords = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCoords'. Expected "+0+" arguments. Function Signature: getCoords()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getCoords', {"s": this.id}, this.userPriority);
	},

		PDFNet.Shading.prototype.getCoordsRadial = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCoordsRadial'. Expected "+0+" arguments. Function Signature: getCoordsRadial()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getCoordsRadial', {"s": this.id}, this.userPriority);
	},

		PDFNet.Shading.prototype.getDomain = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDomain'. Expected "+0+" arguments. Function Signature: getDomain()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getDomain', {"s": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a matrix specifying a mapping from the coordinate space specified
	* by the Domain entry into the shading's target coordinate space.
	*
	* @note for shadings other than Function this method throws an exception.
	*/
		PDFNet.Shading.prototype.getMatrix = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMatrix'. Expected "+0+" arguments. Function Signature: getMatrix()")};
		return PDFNet.messageHandler.sendWithPromise('Shading.getMatrix', {"s": this.id}, this.userPriority).then(function(id){
			//there is a return type Matrix2D
			if(id == "0"){
				return null;
			}
			return new PDFNet.Matrix2D(id);
		});
	},

		PDFNet.Shading.prototype.getColorForFunction = function(t1, t2)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'getColorForFunction'. Expected "+2+" arguments. Function Signature: getColorForFunction(number, number)")};
		if(t1 instanceof Promise) {throw new TypeError("1st input argument in function 'getColorForFunction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t1 != "number") {throw new TypeError("1st input argument '"+t1+"' in function 'getColorForFunction' is of type '"+(typeof t1)+"'. Expected type 'number'. Function Signature: getColorForFunction(number, number).");}
		if(t2 instanceof Promise) {throw new TypeError("2nd input argument in function 'getColorForFunction' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t2 != "number") {throw new TypeError("2nd input argument '"+t2+"' in function 'getColorForFunction' is of type '"+(typeof t2)+"'. Expected type 'number'. Function Signature: getColorForFunction(number, number).");}
		var me = this;
		this.yieldFunction = "Shading.getColorForFunction"; // TRN_ColorPt* out_color
		return PDFNet.messageHandler.sendWithPromise('Shading.getColorForFunction', {"s": this.id, "t1": t1, "t2": t2}, this.userPriority).then(function(id){
			copyFunc(id.out_color, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Stamper constructor
	*
	* @param size_type Specifies how the stamp will be sized
	*		-e_relative_scale: Stamp size is relative to the size of the crop box of
	*		the destination page. 'a' is a percentage of the width of the crop box
	*		(e.g.: 0.5 is 50% of the width of the crop box) 'b' is a percentage of the
	*		height of the crop box. If 'a' <= 0 then only b will be used. If 'b' <= 0
	*		then only 'a' will be used.
	*
	*		-e_absolute_scale: Stamp size is explicitly set. 'a' sets the width of
	*		of the stamp's bounding box. 'b' sets the height of the stamp's bounding
	*		box. The width and height are constant, regardless of the size of the
	*		destination page's bounding box.
	*
	*		-e_font_size: This type only applies to text stamps. 'a' sets the font
	*		size. 'b' is ignored.
	* @param a @see size_type
	* @param b @see size_type
	*/
		PDFNet.Stamper.create = function(size_type, a, b)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+3+" arguments. Function Signature: create(number, number, number)")};
		if(size_type instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size_type != "number") {throw new TypeError("1st input argument '"+size_type+"' in function 'create' is of type '"+(typeof size_type)+"'. Expected type 'number'. Function Signature: create(number, number, number).");}
		if(a instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("2nd input argument '"+a+"' in function 'create' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: create(number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("3rd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("3rd input argument '"+b+"' in function 'create' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: create(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('stamperCreate', {"size_type": size_type, "a": a, "b": b}, this.userPriority).then(function(id){
			//there is a return type Stamper
			if(id == "0"){
				return null;
			}
			return new PDFNet.Stamper(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.Stamper.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Stamper.destroy', {"stamp": this.id}, this.userPriority);
	},

	/**
	* Stamps an image to the given destination document at the set of page numbers
	*
	* @param dest_doc The document being stamped
	* @param src_img The image that is being stamped to the document
	* @param dest_pages The set of pages in the document being stamped
	*/
		PDFNet.Stamper.prototype.stampImage = function(dest_doc, img, page_set)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'stampImage'. Expected "+3+" arguments. Function Signature: stampImage(PDFDoc, Image, PageSet)")};
		if(dest_doc instanceof Promise) {throw new TypeError("1st input argument in function 'stampImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest_doc instanceof PDFNet.PDFDoc || dest_doc instanceof PDFNet.SDFDoc)) {
			if(typeof dest_doc == "object") {throw new TypeError("1st input argument in function 'stampImage' is of type '"+dest_doc.name+"'. Expected type 'PDFDoc'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
			else {throw new TypeError("1st input argument '"+dest_doc+"' in function 'stampImage' is of type '"+(typeof dest_doc)+"'. Expected type 'PDFDoc'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
		}
		if(img instanceof Promise) {throw new TypeError("2nd input argument in function 'stampImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(img instanceof PDFNet.Image)) {
			if(typeof img == "object") {throw new TypeError("2nd input argument in function 'stampImage' is of type '"+img.name+"'. Expected type 'Image'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
			else {throw new TypeError("2nd input argument '"+img+"' in function 'stampImage' is of type '"+(typeof img)+"'. Expected type 'Image'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
		}
		if(page_set instanceof Promise) {throw new TypeError("3rd input argument in function 'stampImage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_set instanceof PDFNet.PageSet)) {
			if(typeof page_set == "object") {throw new TypeError("3rd input argument in function 'stampImage' is of type '"+page_set.name+"'. Expected type 'PageSet'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
			else {throw new TypeError("3rd input argument '"+page_set+"' in function 'stampImage' is of type '"+(typeof page_set)+"'. Expected type 'PageSet'. Function Signature: stampImage(PDFDoc, Image, PageSet).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Stamper.stampImage', {"stamp": this.id, "dest_doc": dest_doc.id, "img": img.id, "page_set": page_set.id}, this.userPriority);
	},

	/**
	* Stamps a PDF page to the given destination document at the set of page numbers
	*
	* @param dest_doc The document being stamped
	* @param src_page The page that is being stamped to the document
	* @param dest_pages The set of pages in the document being stamped
	*/
		PDFNet.Stamper.prototype.stampPage = function(dest_doc, page, page_set)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'stampPage'. Expected "+3+" arguments. Function Signature: stampPage(PDFDoc, Page, PageSet)")};
		if(dest_doc instanceof Promise) {throw new TypeError("1st input argument in function 'stampPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest_doc instanceof PDFNet.PDFDoc || dest_doc instanceof PDFNet.SDFDoc)) {
			if(typeof dest_doc == "object") {throw new TypeError("1st input argument in function 'stampPage' is of type '"+dest_doc.name+"'. Expected type 'PDFDoc'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
			else {throw new TypeError("1st input argument '"+dest_doc+"' in function 'stampPage' is of type '"+(typeof dest_doc)+"'. Expected type 'PDFDoc'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
		}
		if(page instanceof Promise) {throw new TypeError("2nd input argument in function 'stampPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("2nd input argument in function 'stampPage' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
			else {throw new TypeError("2nd input argument '"+page+"' in function 'stampPage' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
		}
		if(page_set instanceof Promise) {throw new TypeError("3rd input argument in function 'stampPage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_set instanceof PDFNet.PageSet)) {
			if(typeof page_set == "object") {throw new TypeError("3rd input argument in function 'stampPage' is of type '"+page_set.name+"'. Expected type 'PageSet'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
			else {throw new TypeError("3rd input argument '"+page_set+"' in function 'stampPage' is of type '"+(typeof page_set)+"'. Expected type 'PageSet'. Function Signature: stampPage(PDFDoc, Page, PageSet).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Stamper.stampPage', {"stamp": this.id, "dest_doc": dest_doc.id, "page": page.id, "page_set": page_set.id}, this.userPriority);
	},

	/**
	* Stamps text to the given destination document at the set of page numbers
	*
	* @param dest_doc The document being stamped
	* @param src_txt The image that is being stamped to the document
	* @param dest_pages The set of pages in the document being stamped
	*/
		PDFNet.Stamper.prototype.stampText = function(dest_doc, txt, page_set)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'stampText'. Expected "+3+" arguments. Function Signature: stampText(PDFDoc, string, PageSet)")};
		if(dest_doc instanceof Promise) {throw new TypeError("1st input argument in function 'stampText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(dest_doc instanceof PDFNet.PDFDoc || dest_doc instanceof PDFNet.SDFDoc)) {
			if(typeof dest_doc == "object") {throw new TypeError("1st input argument in function 'stampText' is of type '"+dest_doc.name+"'. Expected type 'PDFDoc'. Function Signature: stampText(PDFDoc, string, PageSet).");}
			else {throw new TypeError("1st input argument '"+dest_doc+"' in function 'stampText' is of type '"+(typeof dest_doc)+"'. Expected type 'PDFDoc'. Function Signature: stampText(PDFDoc, string, PageSet).");}
		}
		if(txt instanceof Promise) {throw new TypeError("2nd input argument in function 'stampText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof txt != "string") {throw new TypeError("2nd input argument '"+txt+"' in function 'stampText' is of type '"+(typeof txt)+"'. Expected type 'string'. Function Signature: stampText(PDFDoc, string, PageSet).");}
		if(page_set instanceof Promise) {throw new TypeError("3rd input argument in function 'stampText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_set instanceof PDFNet.PageSet)) {
			if(typeof page_set == "object") {throw new TypeError("3rd input argument in function 'stampText' is of type '"+page_set.name+"'. Expected type 'PageSet'. Function Signature: stampText(PDFDoc, string, PageSet).");}
			else {throw new TypeError("3rd input argument '"+page_set+"' in function 'stampText' is of type '"+(typeof page_set)+"'. Expected type 'PageSet'. Function Signature: stampText(PDFDoc, string, PageSet).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Stamper.stampText', {"stamp": this.id, "dest_doc": dest_doc.id, "txt": txt, "page_set": page_set.id}, this.userPriority);
	},

	/**
	*
	* Defines the font of the stamp. (This only applies to text-based stamps)
	*
	* @param font The font of the text stamp
	*/
		PDFNet.Stamper.prototype.setFont = function(font)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFont'. Expected "+1+" argument. Function Signature: setFont(Font)")};
		if(font instanceof Promise) {throw new TypeError("1st input argument in function 'setFont' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font instanceof PDFNet.Font)) {
			if(typeof font == "object") {throw new TypeError("1st input argument in function 'setFont' is of type '"+font.name+"'. Expected type 'Font'. Function Signature: setFont(Font).");}
			else {throw new TypeError("1st input argument '"+font+"' in function 'setFont' is of type '"+(typeof font)+"'. Expected type 'Font'. Function Signature: setFont(Font).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setFont', {"stamp": this.id, "font": font.id}, this.userPriority);
	},

	/**
	* Sets the font color (This only effects text-based stamps)
	*
	* @param font_color The color of the font
	*/
		PDFNet.Stamper.prototype.setFontColor = function(font_color)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setFontColor'. Expected "+1+" argument. Function Signature: setFontColor(ColorPt)")};
		if(font_color instanceof Promise) {throw new TypeError("1st input argument in function 'setFontColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(font_color instanceof PDFNet.ColorPt) && font_color.name != "ColorPt") {
			if(typeof font_color == "object") {throw new TypeError("1st input argument in function 'setFontColor' is of type '"+font_color.name+"'. Expected type 'ColorPt'. Function Signature: setFontColor(ColorPt).");}
			else {throw new TypeError("1st input argument '"+font_color+"' in function 'setFontColor' is of type '"+(typeof font_color)+"'. Expected type 'ColorPt'. Function Signature: setFontColor(ColorPt).");}
		}
		if(typeof font_color.yieldFunction != "undefined") {throw new Error("Function '"+font_color.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'setFontColor'. Perhaps a yield statement is required for '"+font_color.yieldFunction+"'?");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setFontColor', {"stamp": this.id, "font_color": font_color.id}, this.userPriority);
	},

	/**
	* Sets the text alignment (note: this only applies to text watermarks)
	*
	* @param text_alignment Enumerator for text alignment (e_left, e_center, e_right)
	*/
		PDFNet.Stamper.prototype.setTextAlignment = function(text_alignment)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setTextAlignment'. Expected "+1+" argument. Function Signature: setTextAlignment(number)")};
		if(text_alignment instanceof Promise) {throw new TypeError("1st input argument in function 'setTextAlignment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof text_alignment != "number") {throw new TypeError("1st input argument '"+text_alignment+"' in function 'setTextAlignment' is of type '"+(typeof text_alignment)+"'. Expected type 'number'. Function Signature: setTextAlignment(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setTextAlignment', {"stamp": this.id, "text_alignment": text_alignment}, this.userPriority);
	},

	/**
	* Sets the opacity value for the stamp
	*
	* @param opacity The opacity value of the stamp
	*/
		PDFNet.Stamper.prototype.setOpacity = function(opacity)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setOpacity'. Expected "+1+" argument. Function Signature: setOpacity(number)")};
		if(opacity instanceof Promise) {throw new TypeError("1st input argument in function 'setOpacity' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof opacity != "number") {throw new TypeError("1st input argument '"+opacity+"' in function 'setOpacity' is of type '"+(typeof opacity)+"'. Expected type 'number'. Function Signature: setOpacity(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setOpacity', {"stamp": this.id, "opacity": opacity}, this.userPriority);
	},

	/**
	* Rotates the stamp by the given number of degrees
	*
	* @param rotation Rotation in degrees
	*/
		PDFNet.Stamper.prototype.setRotation = function(rotation)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRotation'. Expected "+1+" argument. Function Signature: setRotation(number)")};
		if(rotation instanceof Promise) {throw new TypeError("1st input argument in function 'setRotation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rotation != "number") {throw new TypeError("1st input argument '"+rotation+"' in function 'setRotation' is of type '"+(typeof rotation)+"'. Expected type 'number'. Function Signature: setRotation(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setRotation', {"stamp": this.id, "rotation": rotation}, this.userPriority);
	},

	/**
	* Specifies if the stamp is to be stamped in the background or the foreground.
	*
	* @param background A flag specifying if the stamp should be added
	* as a background layer to the destination page
	*/
		PDFNet.Stamper.prototype.setAsBackground = function(background)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAsBackground'. Expected "+1+" argument. Function Signature: setAsBackground(number)")};
		if(background instanceof Promise) {throw new TypeError("1st input argument in function 'setAsBackground' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof background != "number") {throw new TypeError("1st input argument '"+background+"' in function 'setAsBackground' is of type '"+(typeof background)+"'. Expected type 'number'. Function Signature: setAsBackground(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setAsBackground', {"stamp": this.id, "background": background}, this.userPriority);
	},

	/**
	* Specifies if the stamp is to be stamped as an annotation.
	*
	* @param annotation A flag specifying if the stamp should be added
	* as an annotation or not
	*
	* @note Stamps created with this setting do not work with SetAsBackground,
	* HasStamps, and DeleteStamps, if annotation is true.
	*/
		PDFNet.Stamper.prototype.setAsAnnotation = function(annotation)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setAsAnnotation'. Expected "+1+" argument. Function Signature: setAsAnnotation(number)")};
		if(annotation instanceof Promise) {throw new TypeError("1st input argument in function 'setAsAnnotation' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof annotation != "number") {throw new TypeError("1st input argument '"+annotation+"' in function 'setAsAnnotation' is of type '"+(typeof annotation)+"'. Expected type 'number'. Function Signature: setAsAnnotation(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setAsAnnotation', {"stamp": this.id, "annotation": annotation}, this.userPriority);
	},

		PDFNet.Stamper.prototype.showsOnScreen = function(on_screen)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'showsOnScreen'. Expected "+1+" argument. Function Signature: showsOnScreen(number)")};
		if(on_screen instanceof Promise) {throw new TypeError("1st input argument in function 'showsOnScreen' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof on_screen != "number") {throw new TypeError("1st input argument '"+on_screen+"' in function 'showsOnScreen' is of type '"+(typeof on_screen)+"'. Expected type 'number'. Function Signature: showsOnScreen(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.showsOnScreen', {"stamp": this.id, "on_screen": on_screen}, this.userPriority);
	},

		PDFNet.Stamper.prototype.showsOnPrint = function(on_print)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'showsOnPrint'. Expected "+1+" argument. Function Signature: showsOnPrint(number)")};
		if(on_print instanceof Promise) {throw new TypeError("1st input argument in function 'showsOnPrint' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof on_print != "number") {throw new TypeError("1st input argument '"+on_print+"' in function 'showsOnPrint' is of type '"+(typeof on_print)+"'. Expected type 'number'. Function Signature: showsOnPrint(number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.showsOnPrint', {"stamp": this.id, "on_print": on_print}, this.userPriority);
	},

	/**
	* Sets the alignment for the x and y variables.
	*
	* @see SetPosition
	*
	* @param horizontal_alignment Can be set to e_left, e_center or e_right
	*		e_left:	horizontal_distance measures the distance between the left edge of the stamp's
	*			bounding box and the left edge of the crop box
	*		e_center: horizontal_distance measures the distance between the horizontal bisector of the
	*			stamp's bounding box and the horizontal bisector of the crop box
	*		e_right: horizontal_distance measures the distance between the right edge of the stamp's
	*			bounding box and the right edge of the crop box
	*
	* @param vert_alignment Can be set to e_top, e_center or e_bottom
	*		e_bottom: vertical_distance measures the distance between the bottom edge of the stamp's
	*			bounding box and the bottom edge of the crop box
	*		e_center: vertical_distance measures the distance between the vertical bisector of the
	*			stamp's bounding box and the vertical bisector of the crop box
	*		e_top: vertical_distance measures the distance between the top edge of the stamp's
	*			bounding box and the top edge of the crop box
	*/
		PDFNet.Stamper.prototype.setAlignment = function(horizontal_alignment, vertical_alignment)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setAlignment'. Expected "+2+" arguments. Function Signature: setAlignment(number, number)")};
		if(horizontal_alignment instanceof Promise) {throw new TypeError("1st input argument in function 'setAlignment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof horizontal_alignment != "number") {throw new TypeError("1st input argument '"+horizontal_alignment+"' in function 'setAlignment' is of type '"+(typeof horizontal_alignment)+"'. Expected type 'number'. Function Signature: setAlignment(number, number).");}
		if(vertical_alignment instanceof Promise) {throw new TypeError("2nd input argument in function 'setAlignment' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof vertical_alignment != "number") {throw new TypeError("2nd input argument '"+vertical_alignment+"' in function 'setAlignment' is of type '"+(typeof vertical_alignment)+"'. Expected type 'number'. Function Signature: setAlignment(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setAlignment', {"stamp": this.id, "horizontal_alignment": horizontal_alignment, "vertical_alignment": vertical_alignment}, this.userPriority);
	},

		PDFNet.Stamper.prototype.setPosition = function(x, y, percentage)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'setPosition'. Expected "+3+" arguments. Function Signature: setPosition(number, number, number)")};
		if(x instanceof Promise) {throw new TypeError("1st input argument in function 'setPosition' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x != "number") {throw new TypeError("1st input argument '"+x+"' in function 'setPosition' is of type '"+(typeof x)+"'. Expected type 'number'. Function Signature: setPosition(number, number, number).");}
		if(y instanceof Promise) {throw new TypeError("2nd input argument in function 'setPosition' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y != "number") {throw new TypeError("2nd input argument '"+y+"' in function 'setPosition' is of type '"+(typeof y)+"'. Expected type 'number'. Function Signature: setPosition(number, number, number).");}
		if(percentage instanceof Promise) {throw new TypeError("3rd input argument in function 'setPosition' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof percentage != "number") {throw new TypeError("3rd input argument '"+percentage+"' in function 'setPosition' is of type '"+(typeof percentage)+"'. Expected type 'number'. Function Signature: setPosition(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setPosition', {"stamp": this.id, "x": x, "y": y, "percentage": percentage}, this.userPriority);
	},

	/**
	* sets the size of the stamp
	*
	* @param size_type Specifies how the stamp will be sized
	*		-e_relative_scale: Stamp size is relative to the size of the crop box of
	*		the destination page. 'a' is a percentage of the width of the crop box
	*		(e.g.: 0.5 is 50% of the width of the crop box) 'b' is a percentage of the
	*		height of the crop box. If 'a' <= 0 then only b will be used. If 'b' <= 0
	*		then only 'a' will be used.
	*
	*		-e_absolute_scale: Stamp size is explicitly set. 'a' sets the width of
	*		of the stamp's bounding box. 'b' sets the height of the stamp's bounding
	*		box. The width and height are constant, regardless of the size of the
	*		destination page's bounding box.
	*
	*		-e_font_size: This type only applies to text stamps. 'a' sets the font
	*		size. 'b' is ignored.
	*/
		PDFNet.Stamper.prototype.setSize = function(size_type, a, b)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'setSize'. Expected "+3+" arguments. Function Signature: setSize(number, number, number)")};
		if(size_type instanceof Promise) {throw new TypeError("1st input argument in function 'setSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size_type != "number") {throw new TypeError("1st input argument '"+size_type+"' in function 'setSize' is of type '"+(typeof size_type)+"'. Expected type 'number'. Function Signature: setSize(number, number, number).");}
		if(a instanceof Promise) {throw new TypeError("2nd input argument in function 'setSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("2nd input argument '"+a+"' in function 'setSize' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: setSize(number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("3rd input argument in function 'setSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("3rd input argument '"+b+"' in function 'setSize' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: setSize(number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Stamper.setSize', {"stamp": this.id, "size_type": size_type, "a": a, "b": b}, this.userPriority);
	},

	/**
	* Deletes PDFTron stamps from document at given page numbers
	*
	* @param doc The document to delete stamps from
	* @param page_set The set of pages to delete stamps from
	*/
		PDFNet.Stamper.deleteStamps = function(doc, page_set)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'deleteStamps'. Expected "+2+" arguments. Function Signature: deleteStamps(PDFDoc, PageSet)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'deleteStamps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'deleteStamps' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: deleteStamps(PDFDoc, PageSet).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'deleteStamps' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: deleteStamps(PDFDoc, PageSet).");}
		}
		if(page_set instanceof Promise) {throw new TypeError("2nd input argument in function 'deleteStamps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_set instanceof PDFNet.PageSet)) {
			if(typeof page_set == "object") {throw new TypeError("2nd input argument in function 'deleteStamps' is of type '"+page_set.name+"'. Expected type 'PageSet'. Function Signature: deleteStamps(PDFDoc, PageSet).");}
			else {throw new TypeError("2nd input argument '"+page_set+"' in function 'deleteStamps' is of type '"+(typeof page_set)+"'. Expected type 'PageSet'. Function Signature: deleteStamps(PDFDoc, PageSet).");}
		}
		return PDFNet.messageHandler.sendWithPromise('stamperDeleteStamps', {"doc": doc.id, "page_set": page_set.id}, this.userPriority);
	},

	/**
	* Returns true if the given set of pages has at least one stamp
	*
	* @param doc The document that's being checked
	* @param page_set The set of page that's being checked
	*/
		PDFNet.Stamper.hasStamps = function(doc, page_set)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'hasStamps'. Expected "+2+" arguments. Function Signature: hasStamps(PDFDoc, PageSet)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'hasStamps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'hasStamps' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: hasStamps(PDFDoc, PageSet).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'hasStamps' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: hasStamps(PDFDoc, PageSet).");}
		}
		if(page_set instanceof Promise) {throw new TypeError("2nd input argument in function 'hasStamps' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page_set instanceof PDFNet.PageSet)) {
			if(typeof page_set == "object") {throw new TypeError("2nd input argument in function 'hasStamps' is of type '"+page_set.name+"'. Expected type 'PageSet'. Function Signature: hasStamps(PDFDoc, PageSet).");}
			else {throw new TypeError("2nd input argument '"+page_set+"' in function 'hasStamps' is of type '"+(typeof page_set)+"'. Expected type 'PageSet'. Function Signature: hasStamps(PDFDoc, PageSet).");}
		}
		return PDFNet.messageHandler.sendWithPromise('stamperHasStamps', {"doc": doc.id, "page_set": page_set.id}, this.userPriority);
	},

	/**
	* Constructor and destructor
	*/
		PDFNet.TextExtractor.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('textExtractorCreate', {}, this.userPriority).then(function(id){
			//there is a return type TextExtractor
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextExtractor(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.TextExtractor.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.destroy', {"te": this.id}, this.userPriority);
	},

	/**
	* Start reading the page.
	*
	* @param page Page to read.
	* @param clip_ptr A pointer to the optional clipping rectangle. This
	* parameter can be used to selectively read text from a given rectangle.
	* @param flags A list of ProcessingFlags used to control text extraction
	* algorithm.
	*/
		PDFNet.TextExtractor.prototype.begin = function(page, clip_ptr, flags)
	{
		if(typeof clip_ptr === "undefined") {clip_ptr = new PDFNet.Rect("0");};
		if(typeof flags === "undefined") {flags = 0;};
		if((arguments.length < 1) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+1+" to "+3+" arguments. Function Signature: begin(Page, Rect, number)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'begin' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: begin(Page, Rect, number).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'begin' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: begin(Page, Rect, number).");}
		}
		if(clip_ptr instanceof Promise) {throw new TypeError("2nd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(clip_ptr instanceof PDFNet.Rect) && clip_ptr.name != "Rect") {
			if(typeof clip_ptr == "object") {throw new TypeError("2nd input argument in function 'begin' is of type '"+clip_ptr.name+"'. Expected type 'Rect'. Function Signature: begin(Page, Rect, number).");}
			else {throw new TypeError("2nd input argument '"+clip_ptr+"' in function 'begin' is of type '"+(typeof clip_ptr)+"'. Expected type 'Rect'. Function Signature: begin(Page, Rect, number).");}
		}
		if(flags instanceof Promise) {throw new TypeError("3rd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("3rd input argument '"+flags+"' in function 'begin' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: begin(Page, Rect, number).");}
		if(typeof clip_ptr.yieldFunction != "undefined") {throw new Error("Function '"+clip_ptr.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'begin'. Perhaps a yield statement is required for '"+clip_ptr.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "TextExtractor.begin"; // TRN_Rect* clip_ptr
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.begin', {"te": this.id, "page": page.id, "clip_ptr": clip_ptr, "flags": flags}, this.userPriority).then(function(id){
			copyFunc(id.clip_ptr, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* @return A promise that resolves to the number of words on the page.
	*/
		PDFNet.TextExtractor.prototype.getWordCount = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getWordCount'. Expected "+0+" arguments. Function Signature: getWordCount()")};
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getWordCount', {"te": this.id}, this.userPriority);
	},

	/**
	* Sets the directionality of text extractor.
	* Must be called before the processing of a page started.
	* @param rtl mode reverses the directionality of TextExtractor algorithm.
	*/
		PDFNet.TextExtractor.prototype.setRightToLeftLanguage = function(rtl)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRightToLeftLanguage'. Expected "+1+" argument. Function Signature: setRightToLeftLanguage(boolean)")};
		if(rtl instanceof Promise) {throw new TypeError("1st input argument in function 'setRightToLeftLanguage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rtl != "boolean") {throw new TypeError("1st input argument '"+rtl+"' in function 'setRightToLeftLanguage' is of type '"+(typeof rtl)+"'. Expected type 'boolean'. Function Signature: setRightToLeftLanguage(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.setRightToLeftLanguage', {"te": this.id, "rtl": rtl}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the directionality of text extractor.
	*/
		PDFNet.TextExtractor.prototype.getRightToLeftLanguage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRightToLeftLanguage'. Expected "+0+" arguments. Function Signature: getRightToLeftLanguage()")};
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getRightToLeftLanguage', {"te": this.id}, this.userPriority);
	},

	/**
	* get all words in the current selection as a single string.
	*
	* @param out_str The string containing all words in the current
	* selection. Words will be separated with space (i.e. ' ') or
	* new line (i.e. '\n') characters.
	*
	* @param dehyphen If true, finds and removes hyphens that split words
	* across two lines. Hyphens are often used a the end of lines as an
	* indicator that a word spans two lines. Hyphen detection enables removal
	* of hyphen character and merging of text runs to form a single word.
	* This option has no effect on Tagged PDF files.
	*/
		PDFNet.TextExtractor.prototype.getAsText = function(dehyphen)
	{
		if(typeof dehyphen === "undefined") {dehyphen = true;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAsText'. Expected at most "+1+" arguments. Function Signature: getAsText(boolean)")};
		if(dehyphen instanceof Promise) {throw new TypeError("1st input argument in function 'getAsText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof dehyphen != "boolean") {throw new TypeError("1st input argument '"+dehyphen+"' in function 'getAsText' is of type '"+(typeof dehyphen)+"'. Expected type 'boolean'. Function Signature: getAsText(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getAsText', {"te": this.id, "dehyphen": dehyphen}, this.userPriority);
	},

	/**
	* Get all the characters that intersect an annotation.
	*
	* @param annot The annotation to intersect with.
	*/
		PDFNet.TextExtractor.prototype.getTextUnderAnnot = function(annot)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getTextUnderAnnot'. Expected "+1+" argument. Function Signature: getTextUnderAnnot(Annot)")};
		if(annot instanceof Promise) {throw new TypeError("1st input argument in function 'getTextUnderAnnot' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(annot instanceof PDFNet.Annot)) {
			if(typeof annot == "object") {throw new TypeError("1st input argument in function 'getTextUnderAnnot' is of type '"+annot.name+"'. Expected type 'Annot'. Function Signature: getTextUnderAnnot(Annot).");}
			else {throw new TypeError("1st input argument '"+annot+"' in function 'getTextUnderAnnot' is of type '"+(typeof annot)+"'. Expected type 'Annot'. Function Signature: getTextUnderAnnot(Annot).");}
		}
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getTextUnderAnnot', {"te": this.id, "annot": annot.id}, this.userPriority);
	},

	/**
	* get text content in a form of an XML string.
	*
	* @param out_xml - The string containing XML output.
	* @param xml_output_flags - flags controlling XML output. For more
	* information, please see TextExtract::XMLOutputFlags.
	*
	* XML output will be encoded in UTF-8 and will have the following
	* structure:
	* @code
	* <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
	*  <Flow id="1">
	*   <Para id="1">
	*    <Line box="72, 708.075, 467.895, 10.02" style="font-family:Calibri; font-size:10.02; color: #000000;">
	*      <Word box="72, 708.075, 30.7614, 10.02">PDFNet</Word>
	*      <Word box="106.188, 708.075, 15.9318, 10.02">SDK</Word>
	*      <Word box="125.617, 708.075, 6.22242, 10.02">is</Word>
	*      ...
	*    </Line>
	*   </Para>
	*  </Flow>
	* </Page>
	* @endcode
	*
	* The above XML output was generated by passing the following union of
	* flags in the call to GetAsXML():
	*   (TextExtractor::e_words_as_elements | TextExtractor::e_output_bbox | TextExtractor::e_output_style_info)
	*
	* In case 'xml_output_flags' was not specified, the default XML output
	* would look as follows:
	*
	* <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
	* <Flow id="1">
	* <Para id="1">
	*     <Line>PDFNet SDK is an amazingly comprehensive, high-quality PDF developer toolkit...</Line>
	*     <Line>levels. Using the PDFNet PDF library, ...</Line>
	*     ...
	*   </Para>
	*  </Flow>
	* </Page>
	* @endcode
	*/
		PDFNet.TextExtractor.prototype.getAsXML = function(xml_output_flags)
	{
		if(typeof xml_output_flags === "undefined") {xml_output_flags = 0;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAsXML'. Expected at most "+1+" arguments. Function Signature: getAsXML(number)")};
		if(xml_output_flags instanceof Promise) {throw new TypeError("1st input argument in function 'getAsXML' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof xml_output_flags != "number") {throw new TypeError("1st input argument '"+xml_output_flags+"' in function 'getAsXML' is of type '"+(typeof xml_output_flags)+"'. Expected type 'number'. Function Signature: getAsXML(number).");}
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getAsXML', {"te": this.id, "xml_output_flags": xml_output_flags}, this.userPriority);
	},

		PDFNet.TextExtractorStyle.prototype.getFont = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFont'. Expected "+0+" arguments. Function Signature: getFont()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFont'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getFont"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getFont', {"tes": this}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

		PDFNet.TextExtractorStyle.prototype.getFontName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFontName'. Expected "+0+" arguments. Function Signature: getFontName()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFontName'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getFontName"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getFontName', {"tes": this}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.prototype.getFontSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFontSize'. Expected "+0+" arguments. Function Signature: getFontSize()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFontSize'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getFontSize"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getFontSize', {"tes": this}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.prototype.getWeight = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getWeight'. Expected "+0+" arguments. Function Signature: getWeight()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getWeight'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getWeight"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getWeight', {"tes": this}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.prototype.isItalic = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isItalic'. Expected "+0+" arguments. Function Signature: isItalic()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isItalic'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.isItalic"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.isItalic', {"tes": this}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.prototype.isSerif = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isSerif'. Expected "+0+" arguments. Function Signature: isSerif()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isSerif'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.isSerif"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.isSerif', {"tes": this}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.prototype.getColor = function(rgb)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getColor'. Expected "+1+" argument. Function Signature: getColor(number)")};
		if(rgb instanceof Promise) {throw new TypeError("1st input argument in function 'getColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rgb != "number") {throw new TypeError("1st input argument '"+rgb+"' in function 'getColor' is of type '"+(typeof rgb)+"'. Expected type 'number'. Function Signature: getColor(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getColor'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getColor"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getColor', {"tes": this, "rgb": rgb}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.TextExtractorStyle.prototype.compare = function(s)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(TextExtractorStyle)")};
		if(s instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(s instanceof PDFNet.TextExtractorStyle) && s.name != "TextExtractorStyle") {
			if(typeof s == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+s.name+"'. Expected type 'TextExtractorStyle'. Function Signature: compare(TextExtractorStyle).");}
			else {throw new TypeError("1st input argument '"+s+"' in function 'compare' is of type '"+(typeof s)+"'. Expected type 'TextExtractorStyle'. Function Signature: compare(TextExtractorStyle).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'compare'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof s.yieldFunction != "undefined") {throw new Error("Function '"+s.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'compare'. Perhaps a yield statement is required for '"+s.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.compare"; // TRN_TextExtractorStyle* s
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.compare', {"tes": this, "s": s}, this.userPriority).then(function(id){
			copyFunc(id.tes, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorStyle.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('textExtractorStyleCreate', {}, this.userPriority).then(function(id){
			//there is a return type TextExtractorStyle
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextExtractorStyle(id);
		});
	},

		PDFNet.TextExtractorStyle.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'copy'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.copy"; // TRN_TextExtractorStyle* s
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.copy', {"s": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorStyle
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.s, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorStyle(id.result.mp_imp);
		});
	},

		PDFNet.TextExtractorWord.prototype.getNumGlyphs = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumGlyphs'. Expected "+0+" arguments. Function Signature: getNumGlyphs()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getNumGlyphs'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getNumGlyphs"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getNumGlyphs', {"tew": this}, this.userPriority).then(function(id){
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorWord.prototype.getCharStyle = function(char_idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getCharStyle'. Expected "+1+" argument. Function Signature: getCharStyle(number)")};
		if(char_idx instanceof Promise) {throw new TypeError("1st input argument in function 'getCharStyle' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof char_idx != "number") {throw new TypeError("1st input argument '"+char_idx+"' in function 'getCharStyle' is of type '"+(typeof char_idx)+"'. Expected type 'number'. Function Signature: getCharStyle(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getCharStyle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getCharStyle"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getCharStyle', {"tew": this, "char_idx": char_idx}, this.userPriority).then(function(id){
			//there is a return type TextExtractorStyle
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorStyle(id.result.mp_imp);
		});
	},

		PDFNet.TextExtractorWord.prototype.getStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStyle'. Expected "+0+" arguments. Function Signature: getStyle()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStyle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getStyle"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getStyle', {"tew": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorStyle
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorStyle(id.result.mp_imp);
		});
	},

		PDFNet.TextExtractorWord.prototype.getStringLen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStringLen'. Expected "+0+" arguments. Function Signature: getStringLen()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStringLen'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getStringLen"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getStringLen', {"tew": this}, this.userPriority).then(function(id){
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorWord.prototype.getNextWord = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNextWord'. Expected "+0+" arguments. Function Signature: getNextWord()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getNextWord'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getNextWord"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getNextWord', {"tew": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorWord
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorWord(id.result.line, id.result.word, id.result.end, id.result.uni, id.result.num, id.result.cur_num, id.result.mp_bld);
		});
	},

		PDFNet.TextExtractorWord.prototype.getCurrentNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentNum'. Expected "+0+" arguments. Function Signature: getCurrentNum()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getCurrentNum'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getCurrentNum"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getCurrentNum', {"tew": this}, this.userPriority).then(function(id){
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorWord.prototype.compare = function(word)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(TextExtractorWord)")};
		if(word instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(word instanceof PDFNet.TextExtractorWord) && word.name != "TextExtractorWord") {
			if(typeof word == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+word.name+"'. Expected type 'TextExtractorWord'. Function Signature: compare(TextExtractorWord).");}
			else {throw new TypeError("1st input argument '"+word+"' in function 'compare' is of type '"+(typeof word)+"'. Expected type 'TextExtractorWord'. Function Signature: compare(TextExtractorWord).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'compare'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof word.yieldFunction != "undefined") {throw new Error("Function '"+word.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'compare'. Perhaps a yield statement is required for '"+word.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.compare"; // TRN_TextExtractorWord* word
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.compare', {"tew": this, "word": word}, this.userPriority).then(function(id){
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorWord.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('textExtractorWordCreate', {}, this.userPriority).then(function(id){
			//there is a return type TextExtractorWord
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextExtractorWord(id);
		});
	},

		PDFNet.TextExtractorWord.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.isValid"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.isValid', {"tew": this}, this.userPriority).then(function(id){
			copyFunc(id.tew, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.getNumWords = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumWords'. Expected "+0+" arguments. Function Signature: getNumWords()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getNumWords'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getNumWords"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getNumWords', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.isSimpleLine = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isSimpleLine'. Expected "+0+" arguments. Function Signature: isSimpleLine()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isSimpleLine'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.isSimpleLine"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.isSimpleLine', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.getQuad = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuad'. Expected "+0+" arguments. Function Signature: getQuad()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getQuad'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getQuad"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getQuad', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
		});
	},

		PDFNet.TextExtractorLine.prototype.getFirstWord = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFirstWord'. Expected "+0+" arguments. Function Signature: getFirstWord()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFirstWord'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getFirstWord"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getFirstWord', {"line": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorWord
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorWord(id.result.line, id.result.word, id.result.end, id.result.uni, id.result.num, id.result.cur_num, id.result.mp_bld);
		});
	},

		PDFNet.TextExtractorLine.prototype.getWord = function(word_idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getWord'. Expected "+1+" argument. Function Signature: getWord(number)")};
		if(word_idx instanceof Promise) {throw new TypeError("1st input argument in function 'getWord' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof word_idx != "number") {throw new TypeError("1st input argument '"+word_idx+"' in function 'getWord' is of type '"+(typeof word_idx)+"'. Expected type 'number'. Function Signature: getWord(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getWord'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getWord"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getWord', {"line": this, "word_idx": word_idx}, this.userPriority).then(function(id){
			//there is a return type TextExtractorWord
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorWord(id.result.line, id.result.word, id.result.end, id.result.uni, id.result.num, id.result.cur_num, id.result.mp_bld);
		});
	},

		PDFNet.TextExtractorLine.prototype.getNextLine = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNextLine'. Expected "+0+" arguments. Function Signature: getNextLine()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getNextLine'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getNextLine"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getNextLine', {"line": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorLine
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorLine(id.result.line, id.result.uni, id.result.num, id.result.cur_num, id.result.m_direction, id.result.mp_bld);
		});
	},

		PDFNet.TextExtractorLine.prototype.getCurrentNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentNum'. Expected "+0+" arguments. Function Signature: getCurrentNum()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getCurrentNum'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getCurrentNum"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getCurrentNum', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.getStyle = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getStyle'. Expected "+0+" arguments. Function Signature: getStyle()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getStyle'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getStyle"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getStyle', {"line": this}, this.userPriority).then(function(id){
			//there is a return type TextExtractorStyle
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return new PDFNet.TextExtractorStyle(id.result.mp_imp);
		});
	},

		PDFNet.TextExtractorLine.prototype.getParagraphID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getParagraphID'. Expected "+0+" arguments. Function Signature: getParagraphID()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getParagraphID'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getParagraphID"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getParagraphID', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.getFlowID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFlowID'. Expected "+0+" arguments. Function Signature: getFlowID()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getFlowID'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getFlowID"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getFlowID', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.endsWithHyphen = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'endsWithHyphen'. Expected "+0+" arguments. Function Signature: endsWithHyphen()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'endsWithHyphen'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.endsWithHyphen"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.endsWithHyphen', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.prototype.compare = function(line2)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'compare'. Expected "+1+" argument. Function Signature: compare(TextExtractorLine)")};
		if(line2 instanceof Promise) {throw new TypeError("1st input argument in function 'compare' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(line2 instanceof PDFNet.TextExtractorLine) && line2.name != "TextExtractorLine") {
			if(typeof line2 == "object") {throw new TypeError("1st input argument in function 'compare' is of type '"+line2.name+"'. Expected type 'TextExtractorLine'. Function Signature: compare(TextExtractorLine).");}
			else {throw new TypeError("1st input argument '"+line2+"' in function 'compare' is of type '"+(typeof line2)+"'. Expected type 'TextExtractorLine'. Function Signature: compare(TextExtractorLine).");}
		}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'compare'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		if(typeof line2.yieldFunction != "undefined") {throw new Error("Function '"+line2.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'compare'. Perhaps a yield statement is required for '"+line2.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.compare"; // TRN_TextExtractorLine* line2
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.compare', {"line": this, "line2": line2}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

		PDFNet.TextExtractorLine.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('textExtractorLineCreate', {}, this.userPriority).then(function(id){
			//there is a return type TextExtractorLine
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextExtractorLine(id);
		});
	},

		PDFNet.TextExtractorLine.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'isValid'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.isValid"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.isValid', {"line": this}, this.userPriority).then(function(id){
			copyFunc(id.line, me);
			me.yieldFunction = undefined;
			return id.result;
		});
	},

	/// @endcond
	/**
	* @return A promise that resolves to the number of lines of text on the selected page.
	*/
		PDFNet.TextExtractor.prototype.getNumLines = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumLines'. Expected "+0+" arguments. Function Signature: getNumLines()")};
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getNumLines', {"te": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the first line of text on the selected page.
	*
	* @note To traverse the list of all text lines on the page use line.GetNextLine().
	* @note To traverse the list of all word on a given line use line.GetFirstWord().
	*/
		PDFNet.TextExtractor.prototype.getFirstLine = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFirstLine'. Expected "+0+" arguments. Function Signature: getFirstLine()")};
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getFirstLine', {"te": this.id}, this.userPriority).then(function(id){
			//there is a return type TextExtractorLine
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextExtractorLine(id);
		});
	},

		PDFNet.TextExtractor.prototype.getQuads = function(mtx, quads, quads_size)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'getQuads'. Expected "+3+" arguments. Function Signature: getQuads(Matrix2D, number, number)")};
		if(mtx instanceof Promise) {throw new TypeError("1st input argument in function 'getQuads' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("1st input argument in function 'getQuads' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: getQuads(Matrix2D, number, number).");}
			else {throw new TypeError("1st input argument '"+mtx+"' in function 'getQuads' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: getQuads(Matrix2D, number, number).");}
		}
		if(quads instanceof Promise) {throw new TypeError("2nd input argument in function 'getQuads' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quads != "number") {throw new TypeError("2nd input argument '"+quads+"' in function 'getQuads' is of type '"+(typeof quads)+"'. Expected type 'number'. Function Signature: getQuads(Matrix2D, number, number).");}
		if(quads_size instanceof Promise) {throw new TypeError("3rd input argument in function 'getQuads' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof quads_size != "number") {throw new TypeError("3rd input argument '"+quads_size+"' in function 'getQuads' is of type '"+(typeof quads_size)+"'. Expected type 'number'. Function Signature: getQuads(Matrix2D, number, number).");}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'getQuads'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "TextExtractor.getQuads"; // TRN_Matrix2D* mtx
		return PDFNet.messageHandler.sendWithPromise('TextExtractor.getQuads', {"te": this.id, "mtx": mtx, "quads": quads, "quads_size": quads_size}, this.userPriority).then(function(id){
			copyFunc(id.mtx, me);
			me.yieldFunction = undefined;
		});
	},

	/**
	* Constructor and destructor.
	*/
		PDFNet.TextSearch.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('textSearchCreate', {}, this.userPriority).then(function(id){
			//there is a return type TextSearch
			if(id == "0"){
				return null;
			}
			return new PDFNet.TextSearch(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.TextSearch.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('TextSearch.destroy', {"ts": this.id}, this.userPriority);
	},

	/**
	* Initialize for search process. This should be called before starting the actual search
	* with method Run().
	*
	* @param doc the PDF document to search in.
	* @param pattern the pattern to search for. When regular expression is used, it contains
	*        the expression, and in verbatim mode, it is the exact string to search for.
	* @param mode the mode of the search process.
	* @param start_page the start page of the page range to search in. The default value is -1
	*        indicating the range starts from the first page.
	* @param end_page the end page of the page range to search in. The default value is -1
	*        indicating the range ends at the last page.
	* @return A promise that resolves to true if the initialization has succeeded.
	*/
		PDFNet.TextSearch.prototype.begin = function(doc, pattern, mode, start_page, end_page)
	{
		if(typeof start_page === "undefined") {start_page = -1;};
		if(typeof end_page === "undefined") {end_page = -1;};
		if((arguments.length < 3) || (arguments.length > 5)) {throw new RangeError(arguments.length+" arguments passed into function 'begin'. Expected "+3+" to "+5+" arguments. Function Signature: begin(PDFDoc, string, number, number, number)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'begin' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: begin(PDFDoc, string, number, number, number).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'begin' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: begin(PDFDoc, string, number, number, number).");}
		}
		if(pattern instanceof Promise) {throw new TypeError("2nd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pattern != "string") {throw new TypeError("2nd input argument '"+pattern+"' in function 'begin' is of type '"+(typeof pattern)+"'. Expected type 'string'. Function Signature: begin(PDFDoc, string, number, number, number).");}
		if(mode instanceof Promise) {throw new TypeError("3rd input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("3rd input argument '"+mode+"' in function 'begin' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: begin(PDFDoc, string, number, number, number).");}
		if(start_page instanceof Promise) {throw new TypeError("4th input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof start_page != "number") {throw new TypeError("4th input argument '"+start_page+"' in function 'begin' is of type '"+(typeof start_page)+"'. Expected type 'number'. Function Signature: begin(PDFDoc, string, number, number, number).");}
		if(end_page instanceof Promise) {throw new TypeError("5th input argument in function 'begin' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof end_page != "number") {throw new TypeError("5th input argument '"+end_page+"' in function 'begin' is of type '"+(typeof end_page)+"'. Expected type 'number'. Function Signature: begin(PDFDoc, string, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('TextSearch.begin', {"ts": this.id, "doc": doc.id, "pattern": pattern, "mode": mode, "start_page": start_page, "end_page": end_page}, this.userPriority);
	},

		PDFNet.TextSearch.prototype.run = function(page_num, ambient_str, hlts)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'run'. Expected "+3+" arguments. Function Signature: run(number, string, Highlights)")};
		if(page_num instanceof Promise) {throw new TypeError("1st input argument in function 'run' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_num != "number") {throw new TypeError("1st input argument '"+page_num+"' in function 'run' is of type '"+(typeof page_num)+"'. Expected type 'number'. Function Signature: run(number, string, Highlights).");}
		if(ambient_str instanceof Promise) {throw new TypeError("3rd input argument in function 'run' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ambient_str != "string") {throw new TypeError("3rd input argument '"+ambient_str+"' in function 'run' is of type '"+(typeof ambient_str)+"'. Expected type 'string'. Function Signature: run(number, string, Highlights).");}
		if(hlts instanceof Promise) {throw new TypeError("4th input argument in function 'run' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(hlts instanceof PDFNet.Highlights)) {
			if(typeof hlts == "object") {throw new TypeError("4th input argument in function 'run' is of type '"+hlts.name+"'. Expected type 'Highlights'. Function Signature: run(number, string, Highlights).");}
			else {throw new TypeError("4th input argument '"+hlts+"' in function 'run' is of type '"+(typeof hlts)+"'. Expected type 'Highlights'. Function Signature: run(number, string, Highlights).");}
		}
		return PDFNet.messageHandler.sendWithPromise('TextSearch.run', {"ts": this.id, "page_num": page_num, "ambient_str": ambient_str, "hlts": hlts.id}, this.userPriority);
	},

	/**
	* Set the current search pattern. Note that it is not necessary to call this method since
	* the search pattern is already set when calling the Begin() method. This method is provided
	* for users to change the search pattern while searching through a document.
	*
	* @param pattern the search pattern to set.
	* @return A promise that resolves to true if the setting has succeeded.
	*/
		PDFNet.TextSearch.prototype.setPattern = function(pattern)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setPattern'. Expected "+1+" argument. Function Signature: setPattern(string)")};
		if(pattern instanceof Promise) {throw new TypeError("1st input argument in function 'setPattern' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pattern != "string") {throw new TypeError("1st input argument '"+pattern+"' in function 'setPattern' is of type '"+(typeof pattern)+"'. Expected type 'string'. Function Signature: setPattern(string).");}
		return PDFNet.messageHandler.sendWithPromise('TextSearch.setPattern', {"ts": this.id, "pattern": pattern}, this.userPriority);
	},

	/**
	* Retrieve the current search mode.
	* @return A promise that resolves to the current search mode.
	*/
		PDFNet.TextSearch.prototype.getMode = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getMode'. Expected "+0+" arguments. Function Signature: getMode()")};
		return PDFNet.messageHandler.sendWithPromise('TextSearch.getMode', {"ts": this.id}, this.userPriority);
	},

	/**
	* set the current search mode. For example, the following code turns on the regular
	* expressions:
	*
	*	TextSearch ts;
	*   ...
	*   TextSearch::Mode mode = ts.GetMode();
	*   mode |= TextSearch::e_reg_expression;
	*   ts.SetMode(mode);
	*   ...
	*
	* @param mode the search mode to set.
	*/
		PDFNet.TextSearch.prototype.setMode = function(mode)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMode'. Expected "+1+" argument. Function Signature: setMode(number)")};
		if(mode instanceof Promise) {throw new TypeError("1st input argument in function 'setMode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mode != "number") {throw new TypeError("1st input argument '"+mode+"' in function 'setMode' is of type '"+(typeof mode)+"'. Expected type 'number'. Function Signature: setMode(number).");}
		return PDFNet.messageHandler.sendWithPromise('TextSearch.setMode', {"ts": this.id, "mode": mode}, this.userPriority);
	},

	/**
	* Tells TextSearch that language is from right to left.
	* @param flag Set to true if the language is right to left.
	*/
		PDFNet.TextSearch.prototype.setRightToLeftLanguage = function(flag)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setRightToLeftLanguage'. Expected "+1+" argument. Function Signature: setRightToLeftLanguage(boolean)")};
		if(flag instanceof Promise) {throw new TypeError("1st input argument in function 'setRightToLeftLanguage' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flag != "boolean") {throw new TypeError("1st input argument '"+flag+"' in function 'setRightToLeftLanguage' is of type '"+(typeof flag)+"'. Expected type 'boolean'. Function Signature: setRightToLeftLanguage(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('TextSearch.setRightToLeftLanguage', {"ts": this.id, "flag": flag}, this.userPriority);
	},

	/**
	* Retrieve the number of the current page that is searched in.
	* If the returned value is -1, it indicates the search process has not been initialized
	* (e.g., Begin() is not called yet); if the returned value is 0, it indicates the search
	* process has finished, and if the returned value is positive, it is a valid page number.
	* @return A promise that resolves to the current page number.
	*/
		PDFNet.TextSearch.prototype.getCurrentPage = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getCurrentPage'. Expected "+0+" arguments. Function Signature: getCurrentPage()")};
		return PDFNet.messageHandler.sendWithPromise('TextSearch.getCurrentPage', {"ts": this.id}, this.userPriority);
	},

	/**
	* Retrieves the NameTree inside the '/Root/Names' dictionary with the
	* specified key name, or creates it if it does not exist.
	*
	* @param doc - The document in which the name tree is created.
	* @param name - The name of the NameTree to create.
	*
	* @return A promise that resolves to the newly created NameTree for the doc or an existing tree with
	* the same key name.
	*
	* @note although it is possible to create a name tree anywhere in the document
	* the convention is that all trees are located under '/Root/Names' dictionary.
	*/
		PDFNet.NameTree.create = function(doc, name)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+2+" arguments. Function Signature: create(SDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'create' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: create(SDFDoc, string).");}
		}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'create' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: create(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('nameTreeCreate', {"doc": doc.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type NameTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NameTree(id);
		});
	},

	/**
	* Retrieves a name tree, with the given key name, from the '/Root/Names'
	* dictionary of the doc.
	*
	* @param doc - The document in which to search for the name.
	* @param name - The name of the name tree to find.
	*
	* @return A promise that resolves to the requested NameTree. If the requested NameTree exists
	* NameTree.IsValid() will return true, and false otherwise.
	*/
		PDFNet.NameTree.find = function(doc, name)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'find'. Expected "+2+" arguments. Function Signature: find(SDFDoc, string)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'find' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'find' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: find(SDFDoc, string).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'find' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: find(SDFDoc, string).");}
		}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'find' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'find' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: find(SDFDoc, string).");}
		return PDFNet.messageHandler.sendWithPromise('nameTreeFind', {"doc": doc.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type NameTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NameTree(id);
		});
	},

	/**
	* Create a high level NameTree wrapper around an existing SDF/Cos NameTree.
	* This does not copy the object.
	*
	* @param name_tree SDF/Cos root of the NameTree object.
	*/
		PDFNet.NameTree.createFromObj = function(name_tree)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromObj'. Expected "+1+" argument. Function Signature: createFromObj(Obj)")};
		if(name_tree instanceof Promise) {throw new TypeError("1st input argument in function 'createFromObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(name_tree instanceof PDFNet.Obj)) {
			if(typeof name_tree == "object") {throw new TypeError("1st input argument in function 'createFromObj' is of type '"+name_tree.name+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
			else {throw new TypeError("1st input argument '"+name_tree+"' in function 'createFromObj' is of type '"+(typeof name_tree)+"'. Expected type 'Obj'. Function Signature: createFromObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('nameTreeCreateFromObj', {"name_tree": name_tree.id}, this.userPriority).then(function(id){
			//there is a return type NameTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NameTree(id);
		});
	},

		PDFNet.NameTree.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('NameTree.copy', {"d": this.id}, this.userPriority).then(function(id){
			//there is a return type NameTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NameTree(id);
		});
	},

	/**
	* @return A promise that resolves to whether this is a valid (non-null) NameTree. If the
	* function returns false the underlying SDF/Cos object is null and
	* the NameTree object should be treated as null as well.
	*/
		PDFNet.NameTree.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('NameTree.isValid', {"tree": this.id}, this.userPriority);
	},

		PDFNet.NameTree.prototype.getIterator = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getIterator'. Expected "+1+" argument. Function Signature: getIterator(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'getIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'getIterator' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: getIterator(string).");}
		return PDFNet.messageHandler.sendWithPromise('NameTree.getIterator', {"tree": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

		PDFNet.NameTree.prototype.getValue = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getValue'. Expected "+1+" argument. Function Signature: getValue(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'getValue' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'getValue' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: getValue(string).");}
		return PDFNet.messageHandler.sendWithPromise('NameTree.getValue', {"tree": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to an iterator that addresses the first element in the NameTree.
	* The iterator can be used to traverse all entries stored in the NameTree.
	*
	* @code
	*  UString key;
	*  for (NameTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next()) {
	*    i.GetKey().GetAsPDFText(key); // ...
	*  }
	* @endcode
	*/
		PDFNet.NameTree.prototype.getIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIteratorBegin'. Expected "+0+" arguments. Function Signature: getIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('NameTree.getIteratorBegin', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

		PDFNet.NameTree.prototype.put = function(key, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'put'. Expected "+2+" arguments. Function Signature: put(string, Obj)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'put' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: put(string, Obj).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("2nd input argument in function 'put' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: put(string, Obj).");}
			else {throw new TypeError("2nd input argument '"+value+"' in function 'put' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: put(string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('NameTree.put', {"tree": this.id, "key": key, "value": value.id}, this.userPriority);
	},

		PDFNet.NameTree.prototype.eraseKey = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'eraseKey'. Expected "+1+" argument. Function Signature: eraseKey(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'eraseKey' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'eraseKey' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: eraseKey(string).");}
		return PDFNet.messageHandler.sendWithPromise('NameTree.eraseKey', {"tree": this.id, "key": key}, this.userPriority);
	},

	/**
	* Removes the NameTree entry pointed by the iterator.
	*/
		PDFNet.NameTree.prototype.erase = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'erase'. Expected "+1+" argument. Function Signature: erase(DictIterator)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.DictIterator)) {
			if(typeof pos == "object") {throw new TypeError("1st input argument in function 'erase' is of type '"+pos.name+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
			else {throw new TypeError("1st input argument '"+pos+"' in function 'erase' is of type '"+(typeof pos)+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
		}
		return PDFNet.messageHandler.sendWithPromise('NameTree.erase', {"tree": this.id, "pos": pos.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the object to the underlying SDF/Cos object. If the NameTree.IsValid()
	* returns false the SDF/Cos object is NULL.
	*/
		PDFNet.NameTree.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('NameTree.getSDFObj', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a high level NumberTree wrapper around an existing SDF/Cos NumberTree.
	* This does not copy the object.
	*
	* @param number_tree SDF/Cos root of the NumberTree object.
	*/
		PDFNet.NumberTree.create = function(number_tree)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(Obj)")};
		if(number_tree instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(number_tree instanceof PDFNet.Obj)) {
			if(typeof number_tree == "object") {throw new TypeError("1st input argument in function 'create' is of type '"+number_tree.name+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
			else {throw new TypeError("1st input argument '"+number_tree+"' in function 'create' is of type '"+(typeof number_tree)+"'. Expected type 'Obj'. Function Signature: create(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('numberTreeCreate', {"number_tree": number_tree.id}, this.userPriority).then(function(id){
			//there is a return type NumberTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NumberTree(id);
		});
	},

		PDFNet.NumberTree.prototype.copy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'copy'. Expected "+0+" arguments. Function Signature: copy()")};
		return PDFNet.messageHandler.sendWithPromise('NumberTree.copy', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type NumberTree
			if(id == "0"){
				return null;
			}
			return new PDFNet.NumberTree(id);
		});
	},

	/**
	* @return A promise that resolves to whether this is a valid (non-null) NumberTree. If the
	* function returns false the underlying SDF/Cos object is null and
	* the NumberTree object should be treated as null as well.
	*/
		PDFNet.NumberTree.prototype.isValid = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isValid'. Expected "+0+" arguments. Function Signature: isValid()")};
		return PDFNet.messageHandler.sendWithPromise('NumberTree.isValid', {"tree": this.id}, this.userPriority);
	},

	/**
	* Search for the specified key in the NumberTree.
	*
	* @return A promise that resolves to if the key is present the function returns a NumberTreeIterator the points
	* to the given Key/Value pair. If the key is not found the function returns End()
	* (a non-valid) iterator.
	*
	* @param key the number representing the key to be found.
	*
	* Sample code:
	*   NumberTreeIterator i = dests.Find(5);
	*   if (i.HasNext()) {
	*     cout << "Key: " << i.GetKey()->GetNumber() << endl;
	*     cout << "Value: " << i.GetValue()->GetType() << endl;
	*   }
	*
	*/
		PDFNet.NumberTree.prototype.getIterator = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getIterator'. Expected "+1+" argument. Function Signature: getIterator(number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'getIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "number") {throw new TypeError("1st input argument '"+key+"' in function 'getIterator' is of type '"+(typeof key)+"'. Expected type 'number'. Function Signature: getIterator(number).");}
		return PDFNet.messageHandler.sendWithPromise('NumberTree.getIterator', {"tree": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

		PDFNet.NumberTree.prototype.getValue = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getValue'. Expected "+1+" argument. Function Signature: getValue(number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'getValue' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "number") {throw new TypeError("1st input argument '"+key+"' in function 'getValue' is of type '"+(typeof key)+"'. Expected type 'number'. Function Signature: getValue(number).");}
		return PDFNet.messageHandler.sendWithPromise('NumberTree.getValue', {"tree": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to an iterator to the first key/value pair (i.e. NNTreeData) in
	* the document. You can use the Next method on the returned iterator to
	* traverse all entries stored under the NumberTree.
	*
	* Sample code:
	* 	 for (NumberTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next())
	* 	   cout << "Key: " << i.GetKey().GetNumber() << endl;
	*/
		PDFNet.NumberTree.prototype.getIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getIteratorBegin'. Expected "+0+" arguments. Function Signature: getIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('NumberTree.getIteratorBegin', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

	/**
	* Puts a new entry in the name tree. If an entry with this number
	* is already in the tree, it is replaced.
	*
	* @param key A number representing the key of the new entry.
	* @param the value associated with the key. It can be any SDF::Obj.
	*/
		PDFNet.NumberTree.prototype.put = function(key, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'put'. Expected "+2+" arguments. Function Signature: put(number, Obj)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "number") {throw new TypeError("1st input argument '"+key+"' in function 'put' is of type '"+(typeof key)+"'. Expected type 'number'. Function Signature: put(number, Obj).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(value instanceof PDFNet.Obj)) {
			if(typeof value == "object") {throw new TypeError("2nd input argument in function 'put' is of type '"+value.name+"'. Expected type 'Obj'. Function Signature: put(number, Obj).");}
			else {throw new TypeError("2nd input argument '"+value+"' in function 'put' is of type '"+(typeof value)+"'. Expected type 'Obj'. Function Signature: put(number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('NumberTree.put', {"tree": this.id, "key": key, "value": value.id}, this.userPriority);
	},

	/**
	* Removes the specified object from the tree. Does nothing if no object
	* with that number exists.
	*
	* @param key A number representing the key of the entry to be removed.
	*/
		PDFNet.NumberTree.prototype.eraseKey = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'eraseKey'. Expected "+1+" argument. Function Signature: eraseKey(number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'eraseKey' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "number") {throw new TypeError("1st input argument '"+key+"' in function 'eraseKey' is of type '"+(typeof key)+"'. Expected type 'number'. Function Signature: eraseKey(number).");}
		return PDFNet.messageHandler.sendWithPromise('NumberTree.eraseKey', {"tree": this.id, "key": key}, this.userPriority);
	},

	/**
	* Removes the NumberTree entry pointed by the iterator.
	*/
		PDFNet.NumberTree.prototype.erase = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'erase'. Expected "+1+" argument. Function Signature: erase(DictIterator)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.DictIterator)) {
			if(typeof pos == "object") {throw new TypeError("1st input argument in function 'erase' is of type '"+pos.name+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
			else {throw new TypeError("1st input argument '"+pos+"' in function 'erase' is of type '"+(typeof pos)+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
		}
		return PDFNet.messageHandler.sendWithPromise('NumberTree.erase', {"tree": this.id, "pos": pos.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the object to the underlying SDF/Cos object. If the NumberTree.IsValid()
	* returns false the SDF/Cos object is NULL.
	*/
		PDFNet.NumberTree.prototype.getSDFObj = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSDFObj'. Expected "+0+" arguments. Function Signature: getSDFObj()")};
		return PDFNet.messageHandler.sendWithPromise('NumberTree.getSDFObj', {"tree": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to the object type.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.getType = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getType'. Expected "+0+" arguments. Function Signature: getType()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getType', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the document to which this object belongs.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.getDoc = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDoc'. Expected "+0+" arguments. Function Signature: getDoc()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getDoc', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

	/**
	* The function writes the Obj to the output stream
	* @param stream - the input stream where the Obj will be written
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.write = function(stream)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'write'. Expected "+1+" argument. Function Signature: write(FilterWriter)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'write' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.FilterWriter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'write' is of type '"+stream.name+"'. Expected type 'FilterWriter'. Function Signature: write(FilterWriter).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'write' is of type '"+(typeof stream)+"'. Expected type 'FilterWriter'. Function Signature: write(FilterWriter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.write', {"o": this.id, "stream": stream.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if two Obj's point to the same object.
	* This method does not compare object content. For this operation use
	* IsEqualValue() instead.
	* @param to - Obj to compare to
	*/
		PDFNet.Obj.prototype.isEqual = function(to)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isEqual'. Expected "+1+" argument. Function Signature: isEqual(Obj)")};
		if(to instanceof Promise) {throw new TypeError("1st input argument in function 'isEqual' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(to instanceof PDFNet.Obj)) {
			if(typeof to == "object") {throw new TypeError("1st input argument in function 'isEqual' is of type '"+to.name+"'. Expected type 'Obj'. Function Signature: isEqual(Obj).");}
			else {throw new TypeError("1st input argument '"+to+"' in function 'isEqual' is of type '"+(typeof to)+"'. Expected type 'Obj'. Function Signature: isEqual(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.isEqual', {"o": this.id, "to": to.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Bool object, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isBool = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isBool'. Expected "+0+" arguments. Function Signature: isBool()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isBool', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to bool value if this is Bool.
	* @exception Exception is thrown if the object is not Obj::Type::e_bool
	*/
		PDFNet.Obj.prototype.getBool = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBool'. Expected "+0+" arguments. Function Signature: getBool()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getBool', {"o": this.id}, this.userPriority);
	},

	/**
	* @param b - bool value used to set Bool object.
	* @exception An Exception is thrown if this is not a Obj::Type::e_bool
	*/
		PDFNet.Obj.prototype.setBool = function(b)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setBool'. Expected "+1+" argument. Function Signature: setBool(boolean)")};
		if(b instanceof Promise) {throw new TypeError("1st input argument in function 'setBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "boolean") {throw new TypeError("1st input argument '"+b+"' in function 'setBool' is of type '"+(typeof b)+"'. Expected type 'boolean'. Function Signature: setBool(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setBool', {"o": this.id, "b": b}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Number object, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isNumber = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isNumber'. Expected "+0+" arguments. Function Signature: isNumber()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isNumber', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to value, if this is Number.
	* @exception An Exception is thrown if the object is not a Obj::Type::e_number
	*/
		PDFNet.Obj.prototype.getNumber = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getNumber'. Expected "+0+" arguments. Function Signature: getNumber()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getNumber', {"o": this.id}, this.userPriority);
	},

	/**
	* @param n - value used to set Number object.
	* @exception An Exception is thrown if this is not a Obj::Type::e_number
	*/
		PDFNet.Obj.prototype.setNumber = function(n)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setNumber'. Expected "+1+" argument. Function Signature: setNumber(number)")};
		if(n instanceof Promise) {throw new TypeError("1st input argument in function 'setNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof n != "number") {throw new TypeError("1st input argument '"+n+"' in function 'setNumber' is of type '"+(typeof n)+"'. Expected type 'number'. Function Signature: setNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setNumber', {"o": this.id, "n": n}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Null object, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isNull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isNull'. Expected "+0+" arguments. Function Signature: isNull()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isNull', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Str (String) object, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isString'. Expected "+0+" arguments. Function Signature: isString()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isString', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to a pointer to the string buffer. Please note that the string may not
	* be NULL terminated and that it may not be represented in ASCII or Unicode
	* encoding. For more information on SDF/Cos String objects, please refer to
	* section 3.2.3 'String Objects' in PDF Reference Manual.
	*
	* @note if SDF/Cos String object is represented as 'PDF Text' (Section 3.8.1
	* 'Text Strings' in PDF Reference) you can use GetAsPDFText method to obtain
	* Unicode representation of the string.
	*
	* @note use Size() member function in order to obtain the number of bytes in string buffer.
	*
	* @exception Exception is thrown if this is not a Obj::Type::e_string.
	*/
		PDFNet.Obj.prototype.getBuffer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBuffer'. Expected "+0+" arguments. Function Signature: getBuffer()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getBuffer', {"o": this.id}, this.userPriority);
	},

		PDFNet.Obj.prototype.setString = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setString'. Expected "+1+" argument. Function Signature: setString(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setString(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setString', {"o": this.id, "value": value}, this.userPriority);
	},

	/**
	* Sets the string object value.
	* @param str - A Unicode string value.
	* @exception An Exception is thrown if this is not a Obj::Type::e_string
	*/
		PDFNet.Obj.prototype.setUString = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setUString'. Expected "+1+" argument. Function Signature: setUString(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'setUString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'setUString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: setUString(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setUString', {"o": this.id, "value": value}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is Name, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isName'. Expected "+0+" arguments. Function Signature: isName()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isName', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to string representing the Name object.
	* @exception An Exception is thrown if this is not a Obj::Type::e_name
	*/
		PDFNet.Obj.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getName', {"o": this.id}, this.userPriority);
	},

	/**
	* @param name - value used to set Name object.
	* @exception An Exception is thrown if this is not a Obj::Type::e_name
	*/
		PDFNet.Obj.prototype.setName = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setName'. Expected "+1+" argument. Function Signature: setName(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'setName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'setName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: setName(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setName', {"o": this.id, "name": name}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is Indirect object (i.e. object referenced in the
	* cross-reference table), false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isIndirect = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isIndirect'. Expected "+0+" arguments. Function Signature: isIndirect()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isIndirect', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to object number. If this is not an Indirect object, object number of
	* a containing indirect object is returned.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.getObjNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getObjNum'. Expected "+0+" arguments. Function Signature: getObjNum()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getObjNum', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to generation number. If this is not an Indirect object, generation number of
	* a containing indirect object is returned.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.getGenNum = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getGenNum'. Expected "+0+" arguments. Function Signature: getGenNum()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getGenNum', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to object offset from the beginning of the file. If this is not an Indirect object,
	* offset of a containing indirect object is returned.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.getOffset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getOffset'. Expected "+0+" arguments. Function Signature: getOffset()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getOffset', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the object is in use or is marked as free.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isFree = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isFree'. Expected "+0+" arguments. Function Signature: isFree()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isFree', {"o": this.id}, this.userPriority);
	},

	/**
	* Set the object mark. Mark is a boolean value that can be associated with every
	* indirect object. This is especially useful when and object graph should be
	* traversed and an operation should be performed on each node only once.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.setMark = function(mark)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setMark'. Expected "+1+" argument. Function Signature: setMark(boolean)")};
		if(mark instanceof Promise) {throw new TypeError("1st input argument in function 'setMark' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof mark != "boolean") {throw new TypeError("1st input argument '"+mark+"' in function 'setMark' is of type '"+(typeof mark)+"'. Expected type 'boolean'. Function Signature: setMark(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setMark', {"o": this.id, "mark": mark}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the object is marked.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isMarked = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isMarked'. Expected "+0+" arguments. Function Signature: isMarked()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isMarked', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the object is loaded in memory.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isLoaded = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isLoaded'. Expected "+0+" arguments. Function Signature: isLoaded()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isLoaded', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Container (a dictionary, array, or a stream),
	* false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isContainer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isContainer'. Expected "+0+" arguments. Function Signature: isContainer()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isContainer', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the 'size' of the object. The definition of 'size' depends on
	* the object type. In particular:
	*  - For a dictionary or a stream object, the method will return the
	*    number of key/value pairs in the dictionary.
	*  - For an array object the method will return the number of Obj
	*    entries in the array.
	*  - For a string object the method will return the number of bytes
	*    in the string buffer.
	*  - For any other object the method will always return 1.
	*
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.size = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'size'. Expected "+0+" arguments. Function Signature: size()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.size', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to an iterator that addresses the first element in the dictionary.
	* @exception An Exception is thrown if this is not a dictionary object (Dict).
	*
	* Sample code used to traverse all entries in the dictionary:
	* @code
	*  DictIterator itr = dict.GetDictIterator();
	*  while (itr.HasNext()) {
	*      Obj key = itr.Key();
	*      Obj value = itr.Value();
	*      // ...
	*      itr.Next()
	*   }
	* @endcode
	*/
		PDFNet.Obj.prototype.getDictIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDictIterator'. Expected "+0+" arguments. Function Signature: getDictIterator()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getDictIterator', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

	/**
	* @return A promise that resolves to true if this is a dictionary (i.e. Dict), false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isDict'. Expected "+0+" arguments. Function Signature: isDict()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isDict', {"o": this.id}, this.userPriority);
	},

	/**
	* Search the dictionary for a given key.
	*
	* @param key - a key to search for in the dictionary
	*
	* @return A promise that resolves to the iterator to the matching key/value pair or invalid iterator
	* (i.e. itr.HasNext()==fase) if the if the dictionary does not contain the given key.
	*
	* @note A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
	* @exception Exception is thrown if this is not a dictionary or a stream
	*
	* Sample code used to search a dictionary for a given key:
	* @code
	*  DictIterator itr = info_dict.Find("Info");
	*  if (itr.HasNext()) {
	*    Obj info = itr.Value();
	*    if (info.IsDict())
	*      info.PutString("Producer", "PDFTron PDFNet SDK");
	* }
	* @endcode
	*/
		PDFNet.Obj.prototype.find = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'find'. Expected "+1+" argument. Function Signature: find(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'find' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'find' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: find(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.find', {"o": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

	/**
	* Search the dictionary for a given key.
	*
	* @param key - a key to search for in the dictionary
	* @return A promise that resolves to nULL if the dictionary does not contain the specified key.
	* Otherwise return the corresponding value.
	* @note A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
	* @exception Exception is thrown if this is not a dictionary or a stream
	*/
		PDFNet.Obj.prototype.findObj = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'findObj'. Expected "+1+" argument. Function Signature: findObj(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'findObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'findObj' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: findObj(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.findObj', {"o": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Search the dictionary for a given key and throw an exception if the key is not found.
	*
	* @param key - a key to search for in the dictionary
	* @return A promise that resolves to obj::Null object if the value matching specified key is a Obj::Null object.
	* @return A promise that resolves to otherwise return the iterator to the matching key/value pair.
	* @exception An Exception is thrown if the dictionary does not contain the specified key.
	* @exception An Exception is thrown if this is not a Obj::Type::e_dict or a stream.
	*/
		PDFNet.Obj.prototype.get = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'get'. Expected "+1+" argument. Function Signature: get(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'get' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'get' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: get(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.get', {"o": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type DictIterator
			if(id == "0"){
				return null;
			}
			return new PDFNet.DictIterator(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_name> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param name The value of the Obj::Type::e_name object to be inserted into
	* the dictionary.
	*
	* @return A promise that resolves to a newly created name object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putName = function(key, name)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putName'. Expected "+2+" arguments. Function Signature: putName(string, string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putName' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putName(string, string).");}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'putName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'putName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: putName(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putName', {"o": this.id, "key": key, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_array> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @return A promise that resolves to a newly created array object.
	*
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	*
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putArray = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'putArray'. Expected "+1+" argument. Function Signature: putArray(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putArray' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putArray' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putArray(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putArray', {"o": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_bool> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value The value of the Obj::Type::e_bool object to be inserted into
	* the dictionary.
	*
	* @return A promise that resolves to a newly created boolean object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putBool = function(key, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putBool'. Expected "+2+" arguments. Function Signature: putBool(string, boolean)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putBool' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putBool(string, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'putBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'putBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: putBool(string, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putBool', {"o": this.id, "key": key, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_dict> pair in the dictionary.
	*
	* @param key The key of the value to set.
	*
	* @return A promise that resolves to a newly created dictionary.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putDict = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'putDict'. Expected "+1+" argument. Function Signature: putDict(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putDict' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putDict' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putDict(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putDict', {"o": this.id, "key": key}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_number> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value The value of the Obj::Type::e_number object to be inserted into
	* the dictionary.
	*
	* @return A promise that resolves to a newly created number object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putNumber = function(key, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putNumber'. Expected "+2+" arguments. Function Signature: putNumber(string, number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putNumber' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putNumber(string, number).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'putNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("2nd input argument '"+value+"' in function 'putNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: putNumber(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putNumber', {"o": this.id, "key": key, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_string> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value The value of the Obj::Type::e_string object to be inserted into
	* the dictionary.
	*
	* @return A promise that resolves to a newly created string object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putString = function(key, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putString'. Expected "+2+" arguments. Function Signature: putString(string, string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putString' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putString(string, string).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'putString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("2nd input argument '"+value+"' in function 'putString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: putString(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putString', {"o": this.id, "key": key, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_string> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value The buffer used to set the value of the Obj::Type::e_string
	* object to be inserted into the dictionary.
	* @param size The number of bytes to copy from the 'value' buffer parameter.
	*
	* @return A promise that resolves to a newly created string object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putStringWithSize = function(key, value, size)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'putStringWithSize'. Expected "+3+" arguments. Function Signature: putStringWithSize(string, string, number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putStringWithSize' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putStringWithSize(string, string, number).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'putStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("2nd input argument '"+value+"' in function 'putStringWithSize' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: putStringWithSize(string, string, number).");}
		if(size instanceof Promise) {throw new TypeError("3rd input argument in function 'putStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("3rd input argument '"+size+"' in function 'putStringWithSize' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: putStringWithSize(string, string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putStringWithSize', {"o": this.id, "key": key, "value": value, "size": size}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_string> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value The value of the Obj::Type::e_string object to be inserted into
	* the dictionary.
	* @note PutText will create the string object as a 'PDF Text' object.
	*
	* @return A promise that resolves to a newly created string object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putText = function(key, t)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putText'. Expected "+2+" arguments. Function Signature: putText(string, string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putText' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putText(string, string).");}
		if(t instanceof Promise) {throw new TypeError("2nd input argument in function 'putText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t != "string") {throw new TypeError("2nd input argument '"+t+"' in function 'putText' is of type '"+(typeof t)+"'. Expected type 'string'. Function Signature: putText(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putText', {"o": this.id, "key": key, "t": t}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, Obj::Type::e_null> pair in the dictionary.
	* @param key The key of the value to set.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note The effect of calling this method is essentially the same as dict.Erase(key) .
	*/
		PDFNet.Obj.prototype.putNull = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'putNull'. Expected "+1+" argument. Function Signature: putNull(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putNull' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putNull' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putNull(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putNull', {"o": this.id, "key": key}, this.userPriority);
	},

	/**
	* Inserts a <key, Obj> pair in the dictionary.
	* @param key The key of the value to set.
	* @param obj The value to be inserted into the dictionary. If 'obj' is
	* indirect (i.e. is a shared) object it will be inserted by reference,
	* otherwise the object will be cloned and then inserted into the dictionary.
	* @return A promise that resolves to a newly inserted object.
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	*/
		PDFNet.Obj.prototype.put = function(key, input_obj)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'put'. Expected "+2+" arguments. Function Signature: put(string, Obj)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'put' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: put(string, Obj).");}
		if(input_obj instanceof Promise) {throw new TypeError("2nd input argument in function 'put' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(input_obj instanceof PDFNet.Obj)) {
			if(typeof input_obj == "object") {throw new TypeError("2nd input argument in function 'put' is of type '"+input_obj.name+"'. Expected type 'Obj'. Function Signature: put(string, Obj).");}
			else {throw new TypeError("2nd input argument '"+input_obj+"' in function 'put' is of type '"+(typeof input_obj)+"'. Expected type 'Obj'. Function Signature: put(string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.put', {"o": this.id, "key": key, "input_obj": input_obj.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, [x1,y1,x2,y2]> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param x1,y1,x2,y2 - The values for an array of four numbers to be
	* inserted into the dictionary.
	* @return A promise that resolves to a newly created array object.
	*
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putRect = function(key, x1, y1, x2, y2)
	{
		if(arguments.length != 5) {throw new RangeError(arguments.length+" arguments passed into function 'putRect'. Expected "+5+" arguments. Function Signature: putRect(string, number, number, number, number)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putRect' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putRect(string, number, number, number, number).");}
		if(x1 instanceof Promise) {throw new TypeError("2nd input argument in function 'putRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x1 != "number") {throw new TypeError("2nd input argument '"+x1+"' in function 'putRect' is of type '"+(typeof x1)+"'. Expected type 'number'. Function Signature: putRect(string, number, number, number, number).");}
		if(y1 instanceof Promise) {throw new TypeError("3rd input argument in function 'putRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y1 != "number") {throw new TypeError("3rd input argument '"+y1+"' in function 'putRect' is of type '"+(typeof y1)+"'. Expected type 'number'. Function Signature: putRect(string, number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("4th input argument in function 'putRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("4th input argument '"+x2+"' in function 'putRect' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: putRect(string, number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("5th input argument in function 'putRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("5th input argument '"+y2+"' in function 'putRect' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: putRect(string, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.putRect', {"o": this.id, "key": key, "x1": x1, "y1": y1, "x2": x2, "y2": y2}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts a <key, [a,b,c,d,h,v]> pair in the dictionary.
	*
	* @param key The key of the value to set.
	* @param value - A matrix used to set the values in an array of six numbers.
	* The resulting array will be inserted into the dictionary.
	* @return A promise that resolves to a newly created array object.
	*
	* @exception An Exception is thrown if this is not a dictionary or a stream object.
	* @note If a dictionary already contains an entry with the same key, the old entry
	* will be deleted and all DictIterators to this entry will be invalidated.
	*/
		PDFNet.Obj.prototype.putMatrix = function(key, mtx)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'putMatrix'. Expected "+2+" arguments. Function Signature: putMatrix(string, Matrix2D)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'putMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'putMatrix' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: putMatrix(string, Matrix2D).");}
		if(mtx instanceof Promise) {throw new TypeError("2nd input argument in function 'putMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("2nd input argument in function 'putMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: putMatrix(string, Matrix2D).");}
			else {throw new TypeError("2nd input argument '"+mtx+"' in function 'putMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: putMatrix(string, Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'putMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Obj.putMatrix"; // TRN_Matrix2D* mtx
		return PDFNet.messageHandler.sendWithPromise('Obj.putMatrix', {"o": this.id, "key": key, "mtx": mtx}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.mtx, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* Removes an element in the dictionary that matches the given key.
	* @exception An Exception is thrown if this is not a dictionary or a stream.
	*/
		PDFNet.Obj.prototype.eraseFromKey = function(key)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'eraseFromKey'. Expected "+1+" argument. Function Signature: eraseFromKey(string)")};
		if(key instanceof Promise) {throw new TypeError("1st input argument in function 'eraseFromKey' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key != "string") {throw new TypeError("1st input argument '"+key+"' in function 'eraseFromKey' is of type '"+(typeof key)+"'. Expected type 'string'. Function Signature: eraseFromKey(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.eraseFromKey', {"o": this.id, "key": key}, this.userPriority);
	},

	/**
	* Removes an element in the dictionary from specified position.
	* @exception An Exception is thrown if this is not a dictionary or a stream.
	*/
		PDFNet.Obj.prototype.erase = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'erase'. Expected "+1+" argument. Function Signature: erase(DictIterator)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'erase' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(pos instanceof PDFNet.DictIterator)) {
			if(typeof pos == "object") {throw new TypeError("1st input argument in function 'erase' is of type '"+pos.name+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
			else {throw new TypeError("1st input argument '"+pos+"' in function 'erase' is of type '"+(typeof pos)+"'. Expected type 'DictIterator'. Function Signature: erase(DictIterator).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.erase', {"o": this.id, "pos": pos.id}, this.userPriority);
	},

	/**
	* Change the key value of a dictionary entry.
	* The key can't be renamed if another key with the same name already exists
	* in the dictionary. In this case Rename returns false.
	*
	* @exception An Exception is thrown if this is not a dictionary or a stream.
	*/
		PDFNet.Obj.prototype.rename = function(old_key, new_key)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'rename'. Expected "+2+" arguments. Function Signature: rename(string, string)")};
		if(old_key instanceof Promise) {throw new TypeError("1st input argument in function 'rename' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof old_key != "string") {throw new TypeError("1st input argument '"+old_key+"' in function 'rename' is of type '"+(typeof old_key)+"'. Expected type 'string'. Function Signature: rename(string, string).");}
		if(new_key instanceof Promise) {throw new TypeError("2nd input argument in function 'rename' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof new_key != "string") {throw new TypeError("2nd input argument '"+new_key+"' in function 'rename' is of type '"+(typeof new_key)+"'. Expected type 'string'. Function Signature: rename(string, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.rename', {"o": this.id, "old_key": old_key, "new_key": new_key}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is an Array, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isArray'. Expected "+0+" arguments. Function Signature: isArray()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isArray', {"o": this.id}, this.userPriority);
	},

	/**
	* @param index - The array element to obtain. The first element in an array has an index of zero.
	*
	* @exception throws an Exception if index is outside the array bounds.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array.
	*/
		PDFNet.Obj.prototype.getAt = function(index)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAt'. Expected "+1+" argument. Function Signature: getAt(number)")};
		if(index instanceof Promise) {throw new TypeError("1st input argument in function 'getAt' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof index != "number") {throw new TypeError("1st input argument '"+index+"' in function 'getAt' is of type '"+(typeof index)+"'. Expected type 'number'. Function Signature: getAt(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.getAt', {"o": this.id, "index": index}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_name object in the array.
	* @return A promise that resolves to a newly created name object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param name The value of the Obj::Type::e_name object to be inserted.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertName = function(pos, name)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertName'. Expected "+2+" arguments. Function Signature: insertName(number, string)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertName' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertName(number, string).");}
		if(name instanceof Promise) {throw new TypeError("2nd input argument in function 'insertName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("2nd input argument '"+name+"' in function 'insertName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: insertName(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertName', {"o": this.id, "pos": pos, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_array object in the array.
	* @return A promise that resolves to a newly created array object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertArray = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertArray'. Expected "+1+" argument. Function Signature: insertArray(number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertArray' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertArray' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertArray(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertArray', {"o": this.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_bool object in the array.
	* @return A promise that resolves to a newly created boolean object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param value The value of the Obj::Type::e_bool object to be inserted.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertBool = function(pos, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertBool'. Expected "+2+" arguments. Function Signature: insertBool(number, boolean)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertBool' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertBool(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'insertBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'insertBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: insertBool(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertBool', {"o": this.id, "pos": pos, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_dict object in the array.
	* @return A promise that resolves to a newly created dictionary object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertDict = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertDict'. Expected "+1+" argument. Function Signature: insertDict(number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertDict' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertDict' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertDict(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertDict', {"o": this.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_number object in the array.
	* @return A promise that resolves to a newly created number object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param value The value of the Obj::Type::e_number object to be inserted.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertNumber = function(pos, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertNumber'. Expected "+2+" arguments. Function Signature: insertNumber(number, number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertNumber' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertNumber(number, number).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'insertNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("2nd input argument '"+value+"' in function 'insertNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: insertNumber(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertNumber', {"o": this.id, "pos": pos, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_string object in the array.
	* @return A promise that resolves to a newly created string object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param value The value of the Obj::Type::e_string object to be inserted.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertString = function(pos, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertString'. Expected "+2+" arguments. Function Signature: insertString(number, string)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertString' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertString(number, string).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'insertString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("2nd input argument '"+value+"' in function 'insertString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: insertString(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertString', {"o": this.id, "pos": pos, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_string object in the array.
	* @return A promise that resolves to a newly created string object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param value The buffer used to set the value of the Obj::Type::e_string
	* object to be inserted.
	* @param size The number of bytes to copy from the 'value' buffer parameter.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertStringWithSize = function(pos, value, size)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'insertStringWithSize'. Expected "+3+" arguments. Function Signature: insertStringWithSize(number, string, number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertStringWithSize' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertStringWithSize(number, string, number).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'insertStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("2nd input argument '"+value+"' in function 'insertStringWithSize' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: insertStringWithSize(number, string, number).");}
		if(size instanceof Promise) {throw new TypeError("3rd input argument in function 'insertStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("3rd input argument '"+size+"' in function 'insertStringWithSize' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: insertStringWithSize(number, string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertStringWithSize', {"o": this.id, "pos": pos, "value": value, "size": size}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_string object in the array.
	* @return A promise that resolves to a newly created string object.
	*
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param value The value of the Obj::Type::e_string object to be inserted.
	*
	* @note InsertText will create the string object as a 'PDF Text' object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertText = function(pos, t)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertText'. Expected "+2+" arguments. Function Signature: insertText(number, string)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertText' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertText(number, string).");}
		if(t instanceof Promise) {throw new TypeError("2nd input argument in function 'insertText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t != "string") {throw new TypeError("2nd input argument '"+t+"' in function 'insertText' is of type '"+(typeof t)+"'. Expected type 'string'. Function Signature: insertText(number, string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertText', {"o": this.id, "pos": pos, "t": t}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an Obj::Type::e_null object in the array.
	* @return A promise that resolves to a newly created null object.
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertNull = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'insertNull'. Expected "+1+" argument. Function Signature: insertNull(number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertNull' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertNull' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertNull(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertNull', {"o": this.id, "pos": pos}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an existing Obj in this array.
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	* @param obj The value to be inserted into the dictionary. If 'obj' is
	* indirect (i.e. is a shared) object it will be inserted by reference,
	* otherwise the object will be cloned and then inserted.
	* @return A promise that resolves to a newly inserted object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insert = function(pos, input_obj)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insert'. Expected "+2+" arguments. Function Signature: insert(number, Obj)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insert' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insert(number, Obj).");}
		if(input_obj instanceof Promise) {throw new TypeError("2nd input argument in function 'insert' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(input_obj instanceof PDFNet.Obj)) {
			if(typeof input_obj == "object") {throw new TypeError("2nd input argument in function 'insert' is of type '"+input_obj.name+"'. Expected type 'Obj'. Function Signature: insert(number, Obj).");}
			else {throw new TypeError("2nd input argument '"+input_obj+"' in function 'insert' is of type '"+(typeof input_obj)+"'. Expected type 'Obj'. Function Signature: insert(number, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.insert', {"o": this.id, "pos": pos, "input_obj": input_obj.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an array of 4 numbers in this array.
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	*
	* @param x1,y1,x2,y2 - The values for an array of four numbers to be
	* inserted in this array.
	* @return A promise that resolves to a newly created array object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertRect = function(pos, x1, y1, x2, y2)
	{
		if(arguments.length != 5) {throw new RangeError(arguments.length+" arguments passed into function 'insertRect'. Expected "+5+" arguments. Function Signature: insertRect(number, number, number, number, number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertRect' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertRect(number, number, number, number, number).");}
		if(x1 instanceof Promise) {throw new TypeError("2nd input argument in function 'insertRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x1 != "number") {throw new TypeError("2nd input argument '"+x1+"' in function 'insertRect' is of type '"+(typeof x1)+"'. Expected type 'number'. Function Signature: insertRect(number, number, number, number, number).");}
		if(y1 instanceof Promise) {throw new TypeError("3rd input argument in function 'insertRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y1 != "number") {throw new TypeError("3rd input argument '"+y1+"' in function 'insertRect' is of type '"+(typeof y1)+"'. Expected type 'number'. Function Signature: insertRect(number, number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("4th input argument in function 'insertRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("4th input argument '"+x2+"' in function 'insertRect' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: insertRect(number, number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("5th input argument in function 'insertRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("5th input argument '"+y2+"' in function 'insertRect' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: insertRect(number, number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.insertRect', {"o": this.id, "pos": pos, "x1": x1, "y1": y1, "x2": x2, "y2": y2}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Inserts an array of 6 numbers in this array.
	* @param pos - The location in the array to insert the object . The object is inserted
	*          before the specified location. The first element in an array has a pos of
	*	        zero. If pos >= Array->Length(), appends obj to array.
	*
	* @param value - A matrix used to set the values in an array of six numbers.
	* The resulting array will be then inserted in this array.
	* @return A promise that resolves to a newly created array object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.insertMatrix = function(pos, mtx)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'insertMatrix'. Expected "+2+" arguments. Function Signature: insertMatrix(number, Matrix2D)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'insertMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'insertMatrix' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: insertMatrix(number, Matrix2D).");}
		if(mtx instanceof Promise) {throw new TypeError("2nd input argument in function 'insertMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("2nd input argument in function 'insertMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: insertMatrix(number, Matrix2D).");}
			else {throw new TypeError("2nd input argument '"+mtx+"' in function 'insertMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: insertMatrix(number, Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 2nd input argument in function 'insertMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Obj.insertMatrix"; // TRN_Matrix2D* mtx
		return PDFNet.messageHandler.sendWithPromise('Obj.insertMatrix', {"o": this.id, "pos": pos, "mtx": mtx}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.mtx, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* Appends a new Obj::Type::e_name object at the end of the array.
	* @return A promise that resolves to the new array object.
	* @param name - The value of the Obj::Type::e_name object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackName = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackName'. Expected "+1+" argument. Function Signature: pushBackName(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'pushBackName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: pushBackName(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackName', {"o": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_array object at the end of the array.
	* @return A promise that resolves to the new array object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackArray'. Expected "+0+" arguments. Function Signature: pushBackArray()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackArray', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_bool object at the end of the array.
	* @return A promise that resolves to the new boolean object.
	* @param name - The value of the Obj::Type::e_bool object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackBool = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackBool'. Expected "+1+" argument. Function Signature: pushBackBool(boolean)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("1st input argument '"+value+"' in function 'pushBackBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: pushBackBool(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackBool', {"o": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_dict object at the end of the array.
	* @return A promise that resolves to the new dictionary object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackDict'. Expected "+0+" arguments. Function Signature: pushBackDict()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackDict', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_number object at the end of the array.
	* @return A promise that resolves to the new number object.
	* @param value - The value of the Obj::Type::e_number object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackNumber = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackNumber'. Expected "+1+" argument. Function Signature: pushBackNumber(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'pushBackNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: pushBackNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackNumber', {"o": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_string object at the end of the array.
	* @return A promise that resolves to the new string object.
	* @param value - The value of the Obj::Type::e_string object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackString = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackString'. Expected "+1+" argument. Function Signature: pushBackString(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'pushBackString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: pushBackString(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackString', {"o": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_string object at the end of the array.
	* @return A promise that resolves to the new string object.
	* @param value The buffer used to set the value of the Obj::Type::e_string
	* object to be inserted.
	* @param size The number of bytes to copy from the 'value' buffer parameter.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackStringWithSize = function(value, size)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackStringWithSize'. Expected "+2+" arguments. Function Signature: pushBackStringWithSize(string, number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'pushBackStringWithSize' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: pushBackStringWithSize(string, number).");}
		if(size instanceof Promise) {throw new TypeError("2nd input argument in function 'pushBackStringWithSize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof size != "number") {throw new TypeError("2nd input argument '"+size+"' in function 'pushBackStringWithSize' is of type '"+(typeof size)+"'. Expected type 'number'. Function Signature: pushBackStringWithSize(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackStringWithSize', {"o": this.id, "value": value, "size": size}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_string object at the end of the array.
	* @return A promise that resolves to the new string object.
	* @param value The value of the Obj::Type::e_string object to be inserted.
	* @note InsertText will create the string object as a 'PDF Text' object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackText = function(t)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackText'. Expected "+1+" argument. Function Signature: pushBackText(string)")};
		if(t instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackText' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof t != "string") {throw new TypeError("1st input argument '"+t+"' in function 'pushBackText' is of type '"+(typeof t)+"'. Expected type 'string'. Function Signature: pushBackText(string).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackText', {"o": this.id, "t": t}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends a new Obj::Type::e_null object at the end of the array.
	* @return A promise that resolves to the new null object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackNull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackNull'. Expected "+0+" arguments. Function Signature: pushBackNull()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackNull', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends an existing Obj at the end of the array.
	* @param obj The value to be inserted into the dictionary. If 'obj' is
	* indirect (i.e. is a shared) object it will be inserted by reference,
	* otherwise the object will be cloned and then appended.
	* @return A promise that resolves to a newly appended object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBack = function(input_obj)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBack'. Expected "+1+" argument. Function Signature: pushBack(Obj)")};
		if(input_obj instanceof Promise) {throw new TypeError("1st input argument in function 'pushBack' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(input_obj instanceof PDFNet.Obj)) {
			if(typeof input_obj == "object") {throw new TypeError("1st input argument in function 'pushBack' is of type '"+input_obj.name+"'. Expected type 'Obj'. Function Signature: pushBack(Obj).");}
			else {throw new TypeError("1st input argument '"+input_obj+"' in function 'pushBack' is of type '"+(typeof input_obj)+"'. Expected type 'Obj'. Function Signature: pushBack(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBack', {"o": this.id, "input_obj": input_obj.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends an array of 4 numbers at the end of the array.
	* @param x1,y1,x2,y2 - The values for an array of four numbers to be
	* appended.
	* @return A promise that resolves to a newly appended array object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackRect = function(x1, y1, x2, y2)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackRect'. Expected "+4+" arguments. Function Signature: pushBackRect(number, number, number, number)")};
		if(x1 instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x1 != "number") {throw new TypeError("1st input argument '"+x1+"' in function 'pushBackRect' is of type '"+(typeof x1)+"'. Expected type 'number'. Function Signature: pushBackRect(number, number, number, number).");}
		if(y1 instanceof Promise) {throw new TypeError("2nd input argument in function 'pushBackRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y1 != "number") {throw new TypeError("2nd input argument '"+y1+"' in function 'pushBackRect' is of type '"+(typeof y1)+"'. Expected type 'number'. Function Signature: pushBackRect(number, number, number, number).");}
		if(x2 instanceof Promise) {throw new TypeError("3rd input argument in function 'pushBackRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof x2 != "number") {throw new TypeError("3rd input argument '"+x2+"' in function 'pushBackRect' is of type '"+(typeof x2)+"'. Expected type 'number'. Function Signature: pushBackRect(number, number, number, number).");}
		if(y2 instanceof Promise) {throw new TypeError("4th input argument in function 'pushBackRect' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof y2 != "number") {throw new TypeError("4th input argument '"+y2+"' in function 'pushBackRect' is of type '"+(typeof y2)+"'. Expected type 'number'. Function Signature: pushBackRect(number, number, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackRect', {"o": this.id, "x1": x1, "y1": y1, "x2": x2, "y2": y2}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Appends an array of 6 numbers at the end of the array.
	* @param value - A matrix used to set the values in an array of six numbers.
	* The resulting array will be then inserted in this array.
	* @return A promise that resolves to a newly appended array object.
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.pushBackMatrix = function(mtx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'pushBackMatrix'. Expected "+1+" argument. Function Signature: pushBackMatrix(Matrix2D)")};
		if(mtx instanceof Promise) {throw new TypeError("1st input argument in function 'pushBackMatrix' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(mtx instanceof PDFNet.Matrix2D) && mtx.name != "Matrix2D") {
			if(typeof mtx == "object") {throw new TypeError("1st input argument in function 'pushBackMatrix' is of type '"+mtx.name+"'. Expected type 'Matrix2D'. Function Signature: pushBackMatrix(Matrix2D).");}
			else {throw new TypeError("1st input argument '"+mtx+"' in function 'pushBackMatrix' is of type '"+(typeof mtx)+"'. Expected type 'Matrix2D'. Function Signature: pushBackMatrix(Matrix2D).");}
		}
		if(typeof mtx.yieldFunction != "undefined") {throw new Error("Function '"+mtx.yieldFunction+"' recently altered a struct object without yielding. That object is now being accessed by the 1st input argument in function 'pushBackMatrix'. Perhaps a yield statement is required for '"+mtx.yieldFunction+"'?");}
		var me = this;
		this.yieldFunction = "Obj.pushBackMatrix"; // TRN_Matrix2D* mtx
		return PDFNet.messageHandler.sendWithPromise('Obj.pushBackMatrix', {"o": this.id, "mtx": mtx}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				me.yieldFunction = undefined;
				return null;
			}
			copyFunc(id.mtx, me);
			me.yieldFunction = undefined;
			return new PDFNet.Obj(id.result);
		});
	},

	/**
	* Checks whether the position is within the array bounds and then removes it from the
	* array and moves each subsequent element to the slot with the next smaller index and
	* decrements the arrays length by 1.
	*
	* @param idx The index for the array member to remove. Array indexes start at 0.
	*
	* @exception An Exception is thrown if this is not an Obj::Type::e_array
	*/
		PDFNet.Obj.prototype.eraseAt = function(pos)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'eraseAt'. Expected "+1+" argument. Function Signature: eraseAt(number)")};
		if(pos instanceof Promise) {throw new TypeError("1st input argument in function 'eraseAt' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pos != "number") {throw new TypeError("1st input argument '"+pos+"' in function 'eraseAt' is of type '"+(typeof pos)+"'. Expected type 'number'. Function Signature: eraseAt(number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.eraseAt', {"o": this.id, "pos": pos}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if this is a Stream, false otherwise.
	* @note this method can be invoked on any Obj.
	*/
		PDFNet.Obj.prototype.isStream = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isStream'. Expected "+0+" arguments. Function Signature: isStream()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.isStream', {"o": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the length of the raw/encoded stream equal to the Length parameter
	* @exception An Exception is thrown if this is not a Obj::Type::e_stream
	*/
		PDFNet.Obj.prototype.getRawStreamLength = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRawStreamLength'. Expected "+0+" arguments. Function Signature: getRawStreamLength()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getRawStreamLength', {"o": this.id}, this.userPriority);
	},

		PDFNet.Obj.prototype.setStreamData = function(data, data_size)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setStreamData'. Expected "+2+" arguments. Function Signature: setStreamData(string, number)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'setStreamData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'setStreamData' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: setStreamData(string, number).");}
		if(data_size instanceof Promise) {throw new TypeError("2nd input argument in function 'setStreamData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data_size != "number") {throw new TypeError("2nd input argument '"+data_size+"' in function 'setStreamData' is of type '"+(typeof data_size)+"'. Expected type 'number'. Function Signature: setStreamData(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.setStreamData', {"obj": this.id, "data": data, "data_size": data_size}, this.userPriority);
	},

	/**
	* allows to replace the content stream with a new one
	* without creating a new object
	*/
		PDFNet.Obj.prototype.setStreamDataWithFilter = function(data, data_size, filter_chain)
	{
		if(typeof filter_chain === "undefined") {filter_chain = new PDFNet.Filter("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'setStreamDataWithFilter'. Expected "+2+" to "+3+" arguments. Function Signature: setStreamDataWithFilter(string, number, Filter)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'setStreamDataWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'setStreamDataWithFilter' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: setStreamDataWithFilter(string, number, Filter).");}
		if(data_size instanceof Promise) {throw new TypeError("2nd input argument in function 'setStreamDataWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data_size != "number") {throw new TypeError("2nd input argument '"+data_size+"' in function 'setStreamDataWithFilter' is of type '"+(typeof data_size)+"'. Expected type 'number'. Function Signature: setStreamDataWithFilter(string, number, Filter).");}
		if(filter_chain instanceof Promise) {throw new TypeError("3rd input argument in function 'setStreamDataWithFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter_chain instanceof PDFNet.Filter)) {
			if(typeof filter_chain == "object") {throw new TypeError("3rd input argument in function 'setStreamDataWithFilter' is of type '"+filter_chain.name+"'. Expected type 'Filter'. Function Signature: setStreamDataWithFilter(string, number, Filter).");}
			else {throw new TypeError("3rd input argument '"+filter_chain+"' in function 'setStreamDataWithFilter' is of type '"+(typeof filter_chain)+"'. Expected type 'Filter'. Function Signature: setStreamDataWithFilter(string, number, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('Obj.setStreamDataWithFilter', {"obj": this.id, "data": data, "data_size": data_size, "filter_chain": filter_chain.id}, this.userPriority);
	},

	/**
	* @param decrypt - If true decrypt the stream if the stream is encrypted.
	* @return A promise that resolves to - A filter to the encoded stream
	* @exception An Exception is thrown if this is not a Obj::Type::e_stream
	*/
		PDFNet.Obj.prototype.getRawStream = function(decrypt)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getRawStream'. Expected "+1+" argument. Function Signature: getRawStream(boolean)")};
		if(decrypt instanceof Promise) {throw new TypeError("1st input argument in function 'getRawStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof decrypt != "boolean") {throw new TypeError("1st input argument '"+decrypt+"' in function 'getRawStream' is of type '"+(typeof decrypt)+"'. Expected type 'boolean'. Function Signature: getRawStream(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('Obj.getRawStream', {"o": this.id, "decrypt": decrypt}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

	/**
	* @return A promise that resolves to - A filter to the decoded stream
	* @exception An Exception is thrown if this is not a Obj::Type::e_stream
	*/
		PDFNet.Obj.prototype.getDecodedStream = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getDecodedStream'. Expected "+0+" arguments. Function Signature: getDecodedStream()")};
		return PDFNet.messageHandler.sendWithPromise('Obj.getDecodedStream', {"o": this.id}, this.userPriority).then(function(id){
			//there is a return type Filter
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	},

		PDFNet.ObjSet.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('objSetCreate', {}, this.userPriority).then(function(id){
			//there is a return type ObjSet
			if(id == "0"){
				return null;
			}
			return new PDFNet.ObjSet(id);
		});
	},

	/**
	* Frees the native memory of the object.
	*/
		PDFNet.ObjSet.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('ObjSet.destroy', {"set": this.id}, this.userPriority);
	},

	/**
	* Create a new name object in this object set.
	*/
		PDFNet.ObjSet.prototype.createName = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createName'. Expected "+1+" argument. Function Signature: createName(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'createName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'createName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: createName(string).");}
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createName', {"set": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new array object in this object set.
	*/
		PDFNet.ObjSet.prototype.createArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createArray'. Expected "+0+" arguments. Function Signature: createArray()")};
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createArray', {"set": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new boolean object in this object set.
	*/
		PDFNet.ObjSet.prototype.createBool = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createBool'. Expected "+1+" argument. Function Signature: createBool(boolean)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("1st input argument '"+value+"' in function 'createBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: createBool(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createBool', {"set": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new dictionary object in this object set.
	*/
		PDFNet.ObjSet.prototype.createDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createDict'. Expected "+0+" arguments. Function Signature: createDict()")};
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createDict', {"set": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new null object in this object set.
	*/
		PDFNet.ObjSet.prototype.createNull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createNull'. Expected "+0+" arguments. Function Signature: createNull()")};
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createNull', {"set": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new number object in this object set.
	*/
		PDFNet.ObjSet.prototype.createNumber = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createNumber'. Expected "+1+" argument. Function Signature: createNumber(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'createNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: createNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createNumber', {"set": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Create a new string object in this object set.
	*/
		PDFNet.ObjSet.prototype.createString = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createString'. Expected "+1+" argument. Function Signature: createString(string)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "string") {throw new TypeError("1st input argument '"+value+"' in function 'createString' is of type '"+(typeof value)+"'. Expected type 'string'. Function Signature: createString(string).");}
		return PDFNet.messageHandler.sendWithPromise('ObjSet.createString', {"set": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Default constructor. Creates a new document.
	* The new document contains only trailer and Info dictionary.
	* To build the rest of the document get document's root dictionary using GetTrailer() and
	* populate it with new key/value pairs.
	*/
		PDFNet.SDFDoc.create = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: create()")};
		return PDFNet.messageHandler.sendWithPromise('sdfDocCreate', {}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

	/**
	* Open a SDF/Cos document from a file.
	*
	* @param filepath - path name to the file.
	*
	* @note Make sure to call InitStdSecurityHandler() or InitSecurityHandler() after SDFDoc(...)
	* in case the document is encrypted.
	*/
		PDFNet.SDFDoc.createFromFileUString = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFileUString'. Expected "+1+" argument. Function Signature: createFromFileUString(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFileUString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromFileUString' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromFileUString(string).");}
		return PDFNet.messageHandler.sendWithPromise('sdfDocCreateFromFileUString', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

		PDFNet.SDFDoc.createFromFileString = function(filepath)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFileString'. Expected "+1+" argument. Function Signature: createFromFileString(string)")};
		if(filepath instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFileString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filepath != "string") {throw new TypeError("1st input argument '"+filepath+"' in function 'createFromFileString' is of type '"+(typeof filepath)+"'. Expected type 'string'. Function Signature: createFromFileString(string).");}
		return PDFNet.messageHandler.sendWithPromise('sdfDocCreateFromFileString', {"filepath": filepath}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

	/**
	* Open a SDF/Cos document from a Filter (i.e. a data stream) object.
	*
	* @param stream - input stream containing a serialized document. The input stream may be a
	* random-access file, memory buffer, slow HTTP connection etc.
	*
	* @note if the input stream doesn't support Seek() operation the document will load whole
	* data stream in memory before parsing. In case of linearized PDF, the document may be parsed
	* on-the-fly while it is being loaded in memory. Note that since StdFile implements Seek()
	* interface, the document does not have to be fully in memory before it is used.
	*
	* @note Make sure to call InitStdSecurityHandler() or InitSecurityHandler() after SDFDoc(...)
	* in case the document is encrypted.
	*/
		PDFNet.SDFDoc.createFromFilter = function(stream)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFilter'. Expected "+1+" argument. Function Signature: createFromFilter(Filter)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Filter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'createFromFilter' is of type '"+stream.name+"'. Expected type 'Filter'. Function Signature: createFromFilter(Filter).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'createFromFilter' is of type '"+(typeof stream)+"'. Expected type 'Filter'. Function Signature: createFromFilter(Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('sdfDocCreateFromFilter', {"stream": stream.id}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

		PDFNet.SDFDoc.createFromMemoryBuffer = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromMemoryBuffer'. Expected "+1+" argument. Function Signature: createFromMemoryBuffer(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'createFromMemoryBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'createFromMemoryBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemoryBuffer(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'createFromMemoryBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromMemoryBuffer(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('sdfDocCreateFromMemoryBuffer', {"buf": buf.buffer}, this.userPriority).then(function(id){
			//there is a return type SDFDoc
			if(id == "0"){
				return null;
			}
			return new PDFNet.SDFDoc(id);
		});
	},

		PDFNet.SDFDoc.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.destroy', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the document is/was originally encrypted false otherwise.
	*/
		PDFNet.SDFDoc.prototype.isEncrypted = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isEncrypted'. Expected "+0+" arguments. Function Signature: isEncrypted()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.isEncrypted', {"doc": this.id}, this.userPriority);
	},

		PDFNet.SDFDoc.prototype.initSecurityHandler = function(custom_data)
	{
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'initSecurityHandler'. Expected at most "+1+" arguments. Function Signature: initSecurityHandler(void*)")};
		// [UNKNOWNTYPE] Cannot match type void(void*) from custom_data
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.initSecurityHandler', {"doc": this.id, "custom_data": custom_data}, this.userPriority);
	},

	/**
	* Initializes document's SecurityHandler using the supplied
	* password. This version of InitSecurityHandler() assumes that
	* document uses Standard security and that a password is specified
	* directly.
	*
	* This function should be called immediately after an encrypted
	* document is opened. The function does not have any side effects on
	* documents that are not encrypted.
	*
	* If the security handler was successfully initialized, it can be later
	* obtained using GetSecurityHandler() method.
	*
	* @return A promise that resolves to true if the given password successfully unlocked the document,
	* false otherwise.
	*
	* @exception An exception is thrown if the document's security Filter is
	* not 'Standard'. In this case, you need to register additional custom
	* security handlers with the global SecurityManager (SecurityManagerSingleton).
	*
	* @param password Specifies the password used to open the document without
	* any user feedback. If you would like to dynamically obtain the password,
	* you need to derive a custom class from StdSecurityHandler() and use
	* InitSecurityHandler() without any parameters. See EncTest sample
	* for example code.
	*
	* @param password_len An optional parameter used to specify the size of
	* the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter
	* is not specified, the function assumes that the string is null terminated.
	*/
		PDFNet.SDFDoc.prototype.initStdSecurityHandler = function(password, password_sz)
	{
		if(typeof password_sz === "undefined") {password_sz = 0;};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'initStdSecurityHandler'. Expected "+1+" to "+2+" arguments. Function Signature: initStdSecurityHandler(string, number)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'initStdSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'initStdSecurityHandler' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: initStdSecurityHandler(string, number).");}
		if(password_sz instanceof Promise) {throw new TypeError("2nd input argument in function 'initStdSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password_sz != "number") {throw new TypeError("2nd input argument '"+password_sz+"' in function 'initStdSecurityHandler' is of type '"+(typeof password_sz)+"'. Expected type 'number'. Function Signature: initStdSecurityHandler(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.initStdSecurityHandler', {"doc": this.id, "password": password, "password_sz": password_sz}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - true if document was modified, false otherwise
	*/
		PDFNet.SDFDoc.prototype.isModified = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isModified'. Expected "+0+" arguments. Function Signature: isModified()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.isModified', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - true if the document requires full save.
	*/
		PDFNet.SDFDoc.prototype.isFullSaveRequired = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isFullSaveRequired'. Expected "+0+" arguments. Function Signature: isFullSaveRequired()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.isFullSaveRequired', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - A dictionary representing the root of the document (i.e.
	* a document trailer dictionary)
	*/
		PDFNet.SDFDoc.prototype.getTrailer = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getTrailer'. Expected "+0+" arguments. Function Signature: getTrailer()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getTrailer', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @param - obj_num object number of the object to retrieve.
	* @return A promise that resolves to - the latest version of the object matching specified object number.
	* @exception - exception is thrown if the object is not found.
	*/
		PDFNet.SDFDoc.prototype.getObj = function(obj_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getObj'. Expected "+1+" argument. Function Signature: getObj(number)")};
		if(obj_num instanceof Promise) {throw new TypeError("1st input argument in function 'getObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof obj_num != "number") {throw new TypeError("1st input argument '"+obj_num+"' in function 'getObj' is of type '"+(typeof obj_num)+"'. Expected type 'number'. Function Signature: getObj(number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getObj', {"doc": this.id, "obj_num": obj_num}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @param obj - an object to import.
	* @param deep_copy - a boolean indicating whether to perform a deep or shallow copy.
	* In case of shallow copy all indirect references will be set to null.
	*
	* If the object belongs to a document the function will perform deep or shallow
	* clone depending whether deep_copy flag was specified.
	*
	* If the object does not belong to any document ImportObj does not take the
	* object ownership. ImportObj copies the source object and it is users
	* responsibility to delete free objects.
	*
	* @return A promise that resolves to - a pointer to the root indirect object in this document
	*/
		PDFNet.SDFDoc.prototype.importObj = function(obj, deep_copy)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'importObj'. Expected "+2+" arguments. Function Signature: importObj(Obj, boolean)")};
		if(obj instanceof Promise) {throw new TypeError("1st input argument in function 'importObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(obj instanceof PDFNet.Obj)) {
			if(typeof obj == "object") {throw new TypeError("1st input argument in function 'importObj' is of type '"+obj.name+"'. Expected type 'Obj'. Function Signature: importObj(Obj, boolean).");}
			else {throw new TypeError("1st input argument '"+obj+"' in function 'importObj' is of type '"+(typeof obj)+"'. Expected type 'Obj'. Function Signature: importObj(Obj, boolean).");}
		}
		if(deep_copy instanceof Promise) {throw new TypeError("2nd input argument in function 'importObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof deep_copy != "boolean") {throw new TypeError("2nd input argument '"+deep_copy+"' in function 'importObj' is of type '"+(typeof deep_copy)+"'. Expected type 'boolean'. Function Signature: importObj(Obj, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.importObj', {"doc": this.id, "obj": obj.id, "deep_copy": deep_copy}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @return A promise that resolves to - The size of cross reference table
	*/
		PDFNet.SDFDoc.prototype.xRefSize = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'xRefSize'. Expected "+0+" arguments. Function Signature: xRefSize()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.xRefSize', {"doc": this.id}, this.userPriority);
	},

	/**
	* Removes 'marked' flag from all objects in cross reference table.
	*/
		PDFNet.SDFDoc.prototype.clearMarks = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'clearMarks'. Expected "+0+" arguments. Function Signature: clearMarks()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.clearMarks', {"doc": this.id}, this.userPriority);
	},

	/**
	* Saves the document to a file.
	*
	* If a full save is requested to the original path, the file is saved to a file
	* system-determined temporary file, the old file is deleted, and the temporary file
	* is renamed to path.
	*
	* A full save with remove unused or linearization option may re-arrange object in
	* the cross reference table. Therefore all pointers and references to document objects
	* and resources should be re acquired in order to continue document editing.
	*
	* In order to use incremental save the specified path must match original path and
	* e_incremental flag bit should be set.
	*
	* @param path - The full path name to which the file is saved.
	* @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
	* @param progress - A pointer to the progress interface. NULL if progress tracking is not required.
	* @param header - File header. A new file header is set only during full save.
	*
	* @exception - if the file can't be opened for saving or if there is a problem during Save
	*	an Exception object will be thrown.
	*
	* @note - Save will modify the SDFDoc object's internal representation.  As such,
	*			  the user should acquire a write lock before calling save.
	*/
		PDFNet.SDFDoc.prototype.save = function(path, flags, progress, header)
	{
		if(arguments.length != 4) {throw new RangeError(arguments.length+" arguments passed into function 'save'. Expected "+4+" arguments. Function Signature: save(string, number, ProgressMonitor, string)")};
		if(path instanceof Promise) {throw new TypeError("1st input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof path != "string") {throw new TypeError("1st input argument '"+path+"' in function 'save' is of type '"+(typeof path)+"'. Expected type 'string'. Function Signature: save(string, number, ProgressMonitor, string).");}
		if(flags instanceof Promise) {throw new TypeError("2nd input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("2nd input argument '"+flags+"' in function 'save' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: save(string, number, ProgressMonitor, string).");}
		if(progress instanceof Promise) {throw new TypeError("3rd input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(progress instanceof PDFNet.ProgressMonitor)) {
			if(typeof progress == "object") {throw new TypeError("3rd input argument in function 'save' is of type '"+progress.name+"'. Expected type 'ProgressMonitor'. Function Signature: save(string, number, ProgressMonitor, string).");}
			else {throw new TypeError("3rd input argument '"+progress+"' in function 'save' is of type '"+(typeof progress)+"'. Expected type 'ProgressMonitor'. Function Signature: save(string, number, ProgressMonitor, string).");}
		}
		if(header instanceof Promise) {throw new TypeError("4th input argument in function 'save' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof header != "string") {throw new TypeError("4th input argument '"+header+"' in function 'save' is of type '"+(typeof header)+"'. Expected type 'string'. Function Signature: save(string, number, ProgressMonitor, string).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.save', {"doc": this.id, "path": path, "flags": flags, "progress": progress.id, "header": header}, this.userPriority);
	},

		PDFNet.SDFDoc.prototype.saveMemory = function(flags, progress, header)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'saveMemory'. Expected "+3+" arguments. Function Signature: saveMemory(number, ProgressMonitor, string)")};
		if(flags instanceof Promise) {throw new TypeError("3rd input argument in function 'saveMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("3rd input argument '"+flags+"' in function 'saveMemory' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: saveMemory(number, ProgressMonitor, string).");}
		if(progress instanceof Promise) {throw new TypeError("4th input argument in function 'saveMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(progress instanceof PDFNet.ProgressMonitor)) {
			if(typeof progress == "object") {throw new TypeError("4th input argument in function 'saveMemory' is of type '"+progress.name+"'. Expected type 'ProgressMonitor'. Function Signature: saveMemory(number, ProgressMonitor, string).");}
			else {throw new TypeError("4th input argument '"+progress+"' in function 'saveMemory' is of type '"+(typeof progress)+"'. Expected type 'ProgressMonitor'. Function Signature: saveMemory(number, ProgressMonitor, string).");}
		}
		if(header instanceof Promise) {throw new TypeError("5th input argument in function 'saveMemory' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof header != "string") {throw new TypeError("5th input argument '"+header+"' in function 'saveMemory' is of type '"+(typeof header)+"'. Expected type 'string'. Function Signature: saveMemory(number, ProgressMonitor, string).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.saveMemory', {"doc": this.id, "flags": flags, "progress": progress.id, "header": header}, this.userPriority).then(function(id){
			return new Uint8Array(id);
		});
	},

	/**
	* Saves the document to a stream.
	*
	* @param stream The output stream where to write data.
	* @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
	* @param progress - A pointer to the progress interface. NULL if progress tracking is not required.
	* @param header - File header. A new file header is set only during full save. See also GetHeader()
	*
	* @exception - if there is a problem during Save an Exception object will be thrown.
	*
	* @note - Save will modify the SDFDoc object's internal representation.  As such,
	*			  the user should acquire a write lock before calling save.
	*/
		PDFNet.SDFDoc.prototype.saveStream = function(stream, flags, header)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'saveStream'. Expected "+3+" arguments. Function Signature: saveStream(Filter, number, string)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'saveStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Filter)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'saveStream' is of type '"+stream.name+"'. Expected type 'Filter'. Function Signature: saveStream(Filter, number, string).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'saveStream' is of type '"+(typeof stream)+"'. Expected type 'Filter'. Function Signature: saveStream(Filter, number, string).");}
		}
		if(flags instanceof Promise) {throw new TypeError("2nd input argument in function 'saveStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof flags != "number") {throw new TypeError("2nd input argument '"+flags+"' in function 'saveStream' is of type '"+(typeof flags)+"'. Expected type 'number'. Function Signature: saveStream(Filter, number, string).");}
		if(header instanceof Promise) {throw new TypeError("3rd input argument in function 'saveStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof header != "string") {throw new TypeError("3rd input argument '"+header+"' in function 'saveStream' is of type '"+(typeof header)+"'. Expected type 'string'. Function Signature: saveStream(Filter, number, string).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.saveStream', {"doc": this.id, "stream": stream.id, "flags": flags, "header": header}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the header string identifying the document version to which the file conforms.
	* For a file conforming to PDF version 1.4, the header should be %PDF-1.4.
	* In general header strings have the following syntax: %AAA-N.n where AAA identifies
	* document specification (such as PDF, FDF, PJTF etc), N is the major version and
	* n is the minor version. The new header string can be set during a full save (see SDFDoc::Save()).
	* For a document that is not serialized the function returns an empty string.
	*/
		PDFNet.SDFDoc.prototype.getHeader = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHeader'. Expected "+0+" arguments. Function Signature: getHeader()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getHeader', {"doc": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to currently selected SecurityHandler.
	*
	* @note InitSecurityHandler() should be called before GetSecurityHandler()
	* in order to initialize the handler.
	*
	* @note Returned security handler can be modified in order to change the
	* security settings of the existing document. Changes to the current handler
	* will not invalidate the access to the original file and will take effect
	* during document Save().
	*
	* @note If the security handler is modified, document will perform a full save
	* even if e_incremental was given as a flag in Save() method.
	*/
		PDFNet.SDFDoc.prototype.getSecurityHandler = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getSecurityHandler'. Expected "+0+" arguments. Function Signature: getSecurityHandler()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getSecurityHandler', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

	/**
	* The function sets a new SecurityHandler as the current security handler.
	*
	* @param - new SecurityHandler
	*
	* @note Setting a new security handler will not invalidate the access to
	* the original file and will take effect during document Save().
	*
	* @note If the security handler is modified, document will perform a full save
	* even if e_incremental was given as a flag in Save() method.
	*/
		PDFNet.SDFDoc.prototype.setSecurityHandler = function(handler)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setSecurityHandler'. Expected "+1+" argument. Function Signature: setSecurityHandler(SecurityHandler)")};
		if(handler instanceof Promise) {throw new TypeError("1st input argument in function 'setSecurityHandler' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(handler instanceof PDFNet.SecurityHandler)) {
			if(typeof handler == "object") {throw new TypeError("1st input argument in function 'setSecurityHandler' is of type '"+handler.name+"'. Expected type 'SecurityHandler'. Function Signature: setSecurityHandler(SecurityHandler).");}
			else {throw new TypeError("1st input argument '"+handler+"' in function 'setSecurityHandler' is of type '"+(typeof handler)+"'. Expected type 'SecurityHandler'. Function Signature: setSecurityHandler(SecurityHandler).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.setSecurityHandler', {"doc": this.id, "handler": handler.id}, this.userPriority);
	},

	/**
	* This function removes document security.
	*/
		PDFNet.SDFDoc.prototype.removeSecurity = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'removeSecurity'. Expected "+0+" arguments. Function Signature: removeSecurity()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.removeSecurity', {"doc": this.id}, this.userPriority);
	},

	/**
	* Sometimes it is desirable to modify all indirect references to a given
	* indirect object. It would be inefficient to manually search for all
	* indirect references to a given indirect object.
	*
	* A more efficient and less error prone method is to replace the indirect
	* object in the cross reference table with a new object. This way the object
	* that is referred to is modified (or replaced) and indirect references do
	* not have to be changed.
	*
	* @param - obj_num1 & obj_num2 are object numbers of objects to be swapped.
	*
	* @exception the function throws exception in case the swap can't be
	* performed.
	*/
		PDFNet.SDFDoc.prototype.swap = function(obj_num1, obj_num2)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'swap'. Expected "+2+" arguments. Function Signature: swap(number, number)")};
		if(obj_num1 instanceof Promise) {throw new TypeError("1st input argument in function 'swap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof obj_num1 != "number") {throw new TypeError("1st input argument '"+obj_num1+"' in function 'swap' is of type '"+(typeof obj_num1)+"'. Expected type 'number'. Function Signature: swap(number, number).");}
		if(obj_num2 instanceof Promise) {throw new TypeError("2nd input argument in function 'swap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof obj_num2 != "number") {throw new TypeError("2nd input argument '"+obj_num2+"' in function 'swap' is of type '"+(typeof obj_num2)+"'. Expected type 'number'. Function Signature: swap(number, number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.swap', {"doc": this.id, "obj_num1": obj_num1, "obj_num2": obj_num2}, this.userPriority);
	},

	/**
	* Call this function to determine whether the document is represented in
	* linearized (fast web view) format.
	*
	* @return A promise that resolves to - true if document is stored in fast web view format, false otherwise.
	*
	* @note any changes to the document can invalidate linearization. The function will
	* return 'true' only if the original document is linearized and if it is not
	* modified.
	*
	* In order to provide good performance over relatively slow communication links,
	* PDFNet can generate PDF documents with linearized objects and hint tables that
	* can allow a PDF viewer application to download and view one page of a PDF file
	* at a time, rather than requiring the entire file (including fonts and images) to
	* be downloaded before any of it can be viewed.
	*
	* To save a document in linearized (fast web view) format you only need to pass
	* 'SDFDoc.SaveOptions.e_linearized' flag in the Save method.
	*/
		PDFNet.SDFDoc.prototype.isLinearized = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isLinearized'. Expected "+0+" arguments. Function Signature: isLinearized()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.isLinearized', {"doc": this.id}, this.userPriority);
	},

	/**
	* Returns document's initial linearization dictionary if it is available.
	*
	* @return A promise that resolves to - the linearization dictionary of the original document or NULL
	* if the dictionary is not available.
	*/
		PDFNet.SDFDoc.prototype.getLinearizationDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getLinearizationDict'. Expected "+0+" arguments. Function Signature: getLinearizationDict()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getLinearizationDict', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Returns document's initial linearization hint stream if it is available.
	*
	* @return A promise that resolves to - the linearization hint stream of the original document or NULL
	* if the hint stream is not available.
	*/
		PDFNet.SDFDoc.prototype.getHintStream = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHintStream'. Expected "+0+" arguments. Function Signature: getHintStream()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getHintStream', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* A document uses a temporary file which is used to cache the contents
	* of any new stream object created in the document (that is the default behavior).
	* Use this function to enable to disable this feature dynamically.
	*/
		PDFNet.SDFDoc.prototype.enableDiskCaching = function(use_cache_flag)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'enableDiskCaching'. Expected "+1+" argument. Function Signature: enableDiskCaching(boolean)")};
		if(use_cache_flag instanceof Promise) {throw new TypeError("1st input argument in function 'enableDiskCaching' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof use_cache_flag != "boolean") {throw new TypeError("1st input argument '"+use_cache_flag+"' in function 'enableDiskCaching' is of type '"+(typeof use_cache_flag)+"'. Expected type 'boolean'. Function Signature: enableDiskCaching(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.enableDiskCaching', {"doc": this.id, "use_cache_flag": use_cache_flag}, this.userPriority);
	},

	/**
	* Locks the document to prevent competing threads from accessing the document
	* at the same time. Threads attempting to access the document will wait in
	* suspended state until the thread that owns the lock calls doc.Unlock().
	*/
		PDFNet.SDFDoc.prototype.lock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'lock'. Expected "+0+" arguments. Function Signature: lock()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.lock', {"doc": this.id}, this.userPriority);
	},

	/**
	* Removes the lock from the document.
	*/
		PDFNet.SDFDoc.prototype.unlock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'unlock'. Expected "+0+" arguments. Function Signature: unlock()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.unlock', {"doc": this.id}, this.userPriority);
	},

	/**
	* Locks the document to prevent competing write threads (using Lock()) from accessing the document
	* at the same time. Other reader threads however, will be allowed to access the document.
	* Threads attempting to obtain write access to the document will wait in
	* suspended state until the thread that owns the lock calls doc.UnlockRead().
	* Note: To avoid deadlocks obtaining a write lock while holding
	* a read lock is not permitted and will throw an exception. If this situation is encountered
	* please either unlock the read lock before the write lock is obtained
	* or acquire a write lock (rather than read lock) in the first place.
	*/
		PDFNet.SDFDoc.prototype.lockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'lockRead'. Expected "+0+" arguments. Function Signature: lockRead()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.lockRead', {"doc": this.id}, this.userPriority);
	},

	/**
	* Removes the lock from the document.
	*/
		PDFNet.SDFDoc.prototype.unlockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'unlockRead'. Expected "+0+" arguments. Function Signature: unlockRead()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.unlockRead', {"doc": this.id}, this.userPriority);
	},

		PDFNet.SDFDoc.prototype.tryLock = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tryLock'. Expected "+0+" arguments. Function Signature: tryLock()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.tryLock', {"doc": this.id}, this.userPriority);
	},

	/**
	* Try locking the document, waiting no longer than specified number of milliseconds.
	* @return A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
	*/
		PDFNet.SDFDoc.prototype.timedLock = function(milliseconds)
	{
		if(typeof doc === "undefined") {doc = new PDFNet.SDFDoc("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'timedLock'. Expected at most "+1+" arguments. Function Signature: timedLock(number)")};
		if(milliseconds instanceof Promise) {throw new TypeError("1st input argument in function 'timedLock' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof milliseconds != "number") {throw new TypeError("1st input argument '"+milliseconds+"' in function 'timedLock' is of type '"+(typeof milliseconds)+"'. Expected type 'number'. Function Signature: timedLock(number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.timedLock', {"doc": this.id, "milliseconds": milliseconds}, this.userPriority);
	},

		PDFNet.SDFDoc.prototype.tryLockRead = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'tryLockRead'. Expected "+0+" arguments. Function Signature: tryLockRead()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.tryLockRead', {"doc": this.id}, this.userPriority);
	},

	/**
	* Try locking the document, waiting no longer than specified number of milliseconds.
	* @return A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
	*/
		PDFNet.SDFDoc.prototype.timedLockRead = function(milliseconds)
	{
		if(typeof doc === "undefined") {doc = new PDFNet.SDFDoc("0");};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'timedLockRead'. Expected at most "+1+" arguments. Function Signature: timedLockRead(number)")};
		if(milliseconds instanceof Promise) {throw new TypeError("1st input argument in function 'timedLockRead' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof milliseconds != "number") {throw new TypeError("1st input argument '"+milliseconds+"' in function 'timedLockRead' is of type '"+(typeof milliseconds)+"'. Expected type 'number'. Function Signature: timedLockRead(number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.timedLockRead', {"doc": this.id, "milliseconds": milliseconds}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the filename of the document if the document is loaded from disk,
	* or empty string if the document is not yet saved or is loaded from a memory
	* buffer.
	*/
		PDFNet.SDFDoc.prototype.getFileName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFileName'. Expected "+0+" arguments. Function Signature: getFileName()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.getFileName', {"doc": this.id}, this.userPriority);
	},

	/**
	* The following list of methods is used to create SDF/Cos indirect objects.
	*
	* Unlike direct objects, indirect objects can be referenced by more than one
	* object (i.e. indirect objects they can be shared).
	*
	* @note In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
	*/
		PDFNet.SDFDoc.prototype.createIndirectName = function(name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectName'. Expected "+1+" argument. Function Signature: createIndirectName(string)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectName' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'createIndirectName' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: createIndirectName(string).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectName', {"doc": this.id, "name": name}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectArray = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectArray'. Expected "+0+" arguments. Function Signature: createIndirectArray()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectArray', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectBool = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectBool'. Expected "+1+" argument. Function Signature: createIndirectBool(boolean)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectBool' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("1st input argument '"+value+"' in function 'createIndirectBool' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: createIndirectBool(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectBool', {"doc": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectDict = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectDict'. Expected "+0+" arguments. Function Signature: createIndirectDict()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectDict', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectNull = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectNull'. Expected "+0+" arguments. Function Signature: createIndirectNull()")};
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectNull', {"doc": this.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectNumber = function(value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectNumber'. Expected "+1+" argument. Function Signature: createIndirectNumber(number)")};
		if(value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "number") {throw new TypeError("1st input argument '"+value+"' in function 'createIndirectNumber' is of type '"+(typeof value)+"'. Expected type 'number'. Function Signature: createIndirectNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectNumber', {"doc": this.id, "value": value}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectString = function(buf_value)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectString'. Expected "+1+" argument. Function Signature: createIndirectString(ArrayBuffer)")};
		if(buf_value instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf_value.buffer instanceof ArrayBuffer)) {
			if(typeof buf_value == "object") {throw new TypeError("1st input argument in function 'createIndirectString' is of type '"+buf_value.name+"'. Expected type 'ArrayBuffer'. Function Signature: createIndirectString(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf_value+"' in function 'createIndirectString' is of type '"+(typeof buf_value)+"'. Expected type 'ArrayBuffer'. Function Signature: createIndirectString(ArrayBuffer).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectString', {"doc": this.id, "buf_value": buf_value.buffer}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectStringFromUString = function(str)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStringFromUString'. Expected "+1+" argument. Function Signature: createIndirectStringFromUString(string)")};
		if(str instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStringFromUString' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof str != "string") {throw new TypeError("1st input argument '"+str+"' in function 'createIndirectStringFromUString' is of type '"+(typeof str)+"'. Expected type 'string'. Function Signature: createIndirectStringFromUString(string).");}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectStringFromUString', {"doc": this.id, "str": str}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* @note After calling the following methods the filter object is invalidated and should not be used
	*/
		PDFNet.SDFDoc.prototype.createIndirectStreamFromFilter = function(data, filter_chain)
	{
		if(typeof filter_chain === "undefined") {filter_chain = new PDFNet.Filter("0");};
		if((arguments.length < 1) || (arguments.length > 2)) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStreamFromFilter'. Expected "+1+" to "+2+" arguments. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStreamFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(data instanceof PDFNet.FilterReader)) {
			if(typeof data == "object") {throw new TypeError("1st input argument in function 'createIndirectStreamFromFilter' is of type '"+data.name+"'. Expected type 'FilterReader'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
			else {throw new TypeError("1st input argument '"+data+"' in function 'createIndirectStreamFromFilter' is of type '"+(typeof data)+"'. Expected type 'FilterReader'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
		}
		if(filter_chain instanceof Promise) {throw new TypeError("2nd input argument in function 'createIndirectStreamFromFilter' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter_chain instanceof PDFNet.Filter)) {
			if(typeof filter_chain == "object") {throw new TypeError("2nd input argument in function 'createIndirectStreamFromFilter' is of type '"+filter_chain.name+"'. Expected type 'Filter'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
			else {throw new TypeError("2nd input argument '"+filter_chain+"' in function 'createIndirectStreamFromFilter' is of type '"+(typeof filter_chain)+"'. Expected type 'Filter'. Function Signature: createIndirectStreamFromFilter(FilterReader, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectStreamFromFilter', {"doc": this.id, "data": data.id, "filter_chain": filter_chain.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SDFDoc.prototype.createIndirectStream = function(data, data_size, filter_chain)
	{
		if(typeof filter_chain === "undefined") {filter_chain = new PDFNet.Filter("0");};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createIndirectStream'. Expected "+2+" to "+3+" arguments. Function Signature: createIndirectStream(string, number, Filter)")};
		if(data instanceof Promise) {throw new TypeError("1st input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data != "string") {throw new TypeError("1st input argument '"+data+"' in function 'createIndirectStream' is of type '"+(typeof data)+"'. Expected type 'string'. Function Signature: createIndirectStream(string, number, Filter).");}
		if(data_size instanceof Promise) {throw new TypeError("2nd input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof data_size != "number") {throw new TypeError("2nd input argument '"+data_size+"' in function 'createIndirectStream' is of type '"+(typeof data_size)+"'. Expected type 'number'. Function Signature: createIndirectStream(string, number, Filter).");}
		if(filter_chain instanceof Promise) {throw new TypeError("3rd input argument in function 'createIndirectStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(filter_chain instanceof PDFNet.Filter)) {
			if(typeof filter_chain == "object") {throw new TypeError("3rd input argument in function 'createIndirectStream' is of type '"+filter_chain.name+"'. Expected type 'Filter'. Function Signature: createIndirectStream(string, number, Filter).");}
			else {throw new TypeError("3rd input argument '"+filter_chain+"' in function 'createIndirectStream' is of type '"+(typeof filter_chain)+"'. Expected type 'Filter'. Function Signature: createIndirectStream(string, number, Filter).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SDFDoc.createIndirectStream', {"doc": this.id, "data": data, "data_size": data_size, "filter_chain": filter_chain.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

		PDFNet.SecurityHandler.prototype.clone = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'clone'. Expected "+0+" arguments. Function Signature: clone()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.clone', {"sh": this.id}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

		PDFNet.SecurityHandler.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.destroy', {"sh": this.id}, this.userPriority);
	},

		PDFNet.SecurityHandler.prototype.initialize = function(doc, encrypt_dict, custom_data)
	{
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'initialize'. Expected "+2+" to "+3+" arguments. Function Signature: initialize(SDFDoc, Obj, void*)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'initialize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'initialize' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: initialize(SDFDoc, Obj, void*).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'initialize' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: initialize(SDFDoc, Obj, void*).");}
		}
		if(encrypt_dict instanceof Promise) {throw new TypeError("2nd input argument in function 'initialize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encrypt_dict instanceof PDFNet.Obj)) {
			if(typeof encrypt_dict == "object") {throw new TypeError("2nd input argument in function 'initialize' is of type '"+encrypt_dict.name+"'. Expected type 'Obj'. Function Signature: initialize(SDFDoc, Obj, void*).");}
			else {throw new TypeError("2nd input argument '"+encrypt_dict+"' in function 'initialize' is of type '"+(typeof encrypt_dict)+"'. Expected type 'Obj'. Function Signature: initialize(SDFDoc, Obj, void*).");}
		}
		// [UNKNOWNTYPE] Cannot match type void(void*) from custom_data
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.initialize', {"sh": this.id, "doc": doc.id, "encrypt_dict": encrypt_dict.id, "custom_data": custom_data}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the SecurityHandler permits the specified action (Permission p)
	* on the document, or false if the permission was not granted.
	*
	* @param p A Permission to be granted.
	*
	* @note in order to check for permission the method will repeatedly (up to three
	* times) attempt to GetAuthorizationData() and Authorize() permission. If the
	* permission is not granted AuthorizeFailed() callback will be called. This callback
	* method allows derived class to provide UI feedback for failed authorization.
	*/
		PDFNet.SecurityHandler.prototype.getPermission = function(p)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPermission'. Expected "+1+" argument. Function Signature: getPermission(number)")};
		if(p instanceof Promise) {throw new TypeError("1st input argument in function 'getPermission' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof p != "number") {throw new TypeError("1st input argument '"+p+"' in function 'getPermission' is of type '"+(typeof p)+"'. Expected type 'number'. Function Signature: getPermission(number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getPermission', {"sh": this.id, "p": p}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the length of the encryption key in bytes.
	* @note The returned key length is given in bytes.
	*/
		PDFNet.SecurityHandler.prototype.getKeyLength = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getKeyLength'. Expected "+0+" arguments. Function Signature: getKeyLength()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getKeyLength', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the encryption algorithm identifier. A code specifying the algorithm
	* to be used in encrypting and decrypting the document. Returned number corresponds
	* to V entry in encryption dictionary. Currently allowed values are from 0-4.
	* See PDF Reference Manual for more details.
	*/
		PDFNet.SecurityHandler.prototype.getEncryptionAlgorithmID = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getEncryptionAlgorithmID'. Expected "+0+" arguments. Function Signature: getEncryptionAlgorithmID()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getEncryptionAlgorithmID', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the name of the security handler as it appears in the serialized file
	* as the value of /Filter key in /Encrypt dictionary.
	*/
		PDFNet.SecurityHandler.prototype.getHandlerDocName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getHandlerDocName'. Expected "+0+" arguments. Function Signature: getHandlerDocName()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getHandlerDocName', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to - true if the SecurityHandler was modified (by calling SetModified())
	* or false otherwise.
	*
	* If the user changes SecurityHandler's settings (e.g. by changing a password),
	* IsModified() should return true.
	*/
		PDFNet.SecurityHandler.prototype.isModified = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isModified'. Expected "+0+" arguments. Function Signature: isModified()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isModified', {"sh": this.id}, this.userPriority);
	},

	/**
	* The method allows derived classes to set SecurityHandler is modified flag.
	* This method should be called whenever there are changes (e.g. a password change)
	* to the SecurityHandler
	*/
		PDFNet.SecurityHandler.prototype.setModified = function(is_modified)
	{
		if(typeof is_modified === "undefined") {is_modified = true;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'setModified'. Expected at most "+1+" arguments. Function Signature: setModified(boolean)")};
		if(is_modified instanceof Promise) {throw new TypeError("1st input argument in function 'setModified' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof is_modified != "boolean") {throw new TypeError("1st input argument '"+is_modified+"' in function 'setModified' is of type '"+(typeof is_modified)+"'. Expected type 'boolean'. Function Signature: setModified(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.setModified', {"sh": this.id, "is_modified": is_modified}, this.userPriority);
	},

	/**
	* create a Standard Security Handler.
	*
	* @param crypt_type The encryption algorithm identifier.
	*/
		PDFNet.SecurityHandler.create = function(crypt_type)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+1+" argument. Function Signature: create(number)")};
		if(crypt_type instanceof Promise) {throw new TypeError("1st input argument in function 'create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof crypt_type != "number") {throw new TypeError("1st input argument '"+crypt_type+"' in function 'create' is of type '"+(typeof crypt_type)+"'. Expected type 'number'. Function Signature: create(number).");}
		return PDFNet.messageHandler.sendWithPromise('securityHandlerCreate', {"crypt_type": crypt_type}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

	/**
	* create a Standard Security Handler.
	*
	* @param key_len The bit length of the encryption key (40 or 128 bit).
	* @param enc_code The encryption algorithm identifier. The number corresponds
	* to the V entry in encryption dictionary. Currently allowed values are (see
	* Table 3.18 in PDF Reference Manual v1.6 for more details):
	*   - 1 : Encryption using 40-bit RC4 algorithm.
	*   - 2 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
	*   - 3 : This algorithm was deprecated by PDF standard and is not supported.
	*   - 4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
	*         Standard) algorithm. Available in PDF 1.6 and above.
	*
	* @default values for key_len and enc_code are 128 and 2 respectively.
	*/
		PDFNet.SecurityHandler.createFromEncCode = function(name, key_len, enc_code)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'createFromEncCode'. Expected "+3+" arguments. Function Signature: createFromEncCode(string, number, number)")};
		if(name instanceof Promise) {throw new TypeError("1st input argument in function 'createFromEncCode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof name != "string") {throw new TypeError("1st input argument '"+name+"' in function 'createFromEncCode' is of type '"+(typeof name)+"'. Expected type 'string'. Function Signature: createFromEncCode(string, number, number).");}
		if(key_len instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromEncCode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof key_len != "number") {throw new TypeError("2nd input argument '"+key_len+"' in function 'createFromEncCode' is of type '"+(typeof key_len)+"'. Expected type 'number'. Function Signature: createFromEncCode(string, number, number).");}
		if(enc_code instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromEncCode' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof enc_code != "number") {throw new TypeError("3rd input argument '"+enc_code+"' in function 'createFromEncCode' is of type '"+(typeof enc_code)+"'. Expected type 'number'. Function Signature: createFromEncCode(string, number, number).");}
		return PDFNet.messageHandler.sendWithPromise('securityHandlerCreateFromEncCode', {"name": name, "key_len": key_len, "enc_code": enc_code}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

		PDFNet.SecurityHandler.createDefault = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createDefault'. Expected "+0+" arguments. Function Signature: createDefault()")};
		return PDFNet.messageHandler.sendWithPromise('securityHandlerCreateDefault', {}, this.userPriority).then(function(id){
			//there is a return type SecurityHandler
			if(id == "0"){
				return null;
			}
			return new PDFNet.SecurityHandler(id);
		});
	},

	/**
	* Set the new user password to an ASCII text string
	* @param password the new user password
	*/
		PDFNet.SecurityHandler.prototype.changeUserPassword = function(password)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'changeUserPassword'. Expected "+1+" argument. Function Signature: changeUserPassword(string)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'changeUserPassword' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'changeUserPassword' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: changeUserPassword(string).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.changeUserPassword', {"sh": this.id, "password": password}, this.userPriority);
	},

	/**
	* Set the new user password to a binary string
	* @param password the new user password
	*/
		PDFNet.SecurityHandler.prototype.changeUserPasswordNonAscii = function(password, pwd_length)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'changeUserPasswordNonAscii'. Expected "+2+" arguments. Function Signature: changeUserPasswordNonAscii(string, number)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'changeUserPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'changeUserPasswordNonAscii' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: changeUserPasswordNonAscii(string, number).");}
		if(pwd_length instanceof Promise) {throw new TypeError("2nd input argument in function 'changeUserPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pwd_length != "number") {throw new TypeError("2nd input argument '"+pwd_length+"' in function 'changeUserPasswordNonAscii' is of type '"+(typeof pwd_length)+"'. Expected type 'number'. Function Signature: changeUserPasswordNonAscii(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.changeUserPasswordNonAscii', {"sh": this.id, "password": password, "pwd_length": pwd_length}, this.userPriority);
	},

	/**
	* Set the new master password to an ASCII text string
	* @param password the new master/owner password
	*/
		PDFNet.SecurityHandler.prototype.changeMasterPassword = function(password)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'changeMasterPassword'. Expected "+1+" argument. Function Signature: changeMasterPassword(string)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'changeMasterPassword' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'changeMasterPassword' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: changeMasterPassword(string).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.changeMasterPassword', {"sh": this.id, "password": password}, this.userPriority);
	},

	/**
	* Set the new master password to a binary string
	* @param password the new user password
	*/
		PDFNet.SecurityHandler.prototype.changeMasterPasswordNonAscii = function(password, pwd_length)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'changeMasterPasswordNonAscii'. Expected "+2+" arguments. Function Signature: changeMasterPasswordNonAscii(string, number)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'changeMasterPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'changeMasterPasswordNonAscii' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: changeMasterPasswordNonAscii(string, number).");}
		if(pwd_length instanceof Promise) {throw new TypeError("2nd input argument in function 'changeMasterPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pwd_length != "number") {throw new TypeError("2nd input argument '"+pwd_length+"' in function 'changeMasterPasswordNonAscii' is of type '"+(typeof pwd_length)+"'. Expected type 'number'. Function Signature: changeMasterPasswordNonAscii(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.changeMasterPasswordNonAscii', {"sh": this.id, "password": password, "pwd_length": pwd_length}, this.userPriority);
	},

	/**
	* Set the permission setting of the StdSecurityHandler.
	* @param perm indicates a permission to set or clear. It can be any of the
	* following values:
	*
	*	e_print				// print the document.
	*	e_doc_modify		// edit the document more than adding or modifying text notes.
	*	e_extract_content	// enable content extraction
	*	e_mod_annot			// allow modifications to annotations
	*	e_fill_forms		// allow changes to fill in forms
	*	e_access_support	// content access for the visually impaired.
	*	e_assemble_doc		// allow document assembly
	*	e_print_high		// high resolution print.
	*
	* @param value true if the permission/s should be granted, false otherwise.
	*/
		PDFNet.SecurityHandler.prototype.setPermission = function(perm, value)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'setPermission'. Expected "+2+" arguments. Function Signature: setPermission(number, boolean)")};
		if(perm instanceof Promise) {throw new TypeError("1st input argument in function 'setPermission' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof perm != "number") {throw new TypeError("1st input argument '"+perm+"' in function 'setPermission' is of type '"+(typeof perm)+"'. Expected type 'number'. Function Signature: setPermission(number, boolean).");}
		if(value instanceof Promise) {throw new TypeError("2nd input argument in function 'setPermission' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof value != "boolean") {throw new TypeError("2nd input argument '"+value+"' in function 'setPermission' is of type '"+(typeof value)+"'. Expected type 'boolean'. Function Signature: setPermission(number, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.setPermission', {"sh": this.id, "perm": perm, "value": value}, this.userPriority);
	},

	/**
	* Change the revision number and the encryption algorithm of the
	* standard security handler.
	*
	* @param rev_num the new revision number of the standard security
	* algorithm. Currently allowed values for the revision number are
	* (see Table 3.18 in PDF Reference Manual v1.6 for more details):
	*   - 2 : Encryption using 40-bit RC4 algorithm.
	*   - 3 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
	*   - 4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
	*         Standard) algorithm. Available in PDF 1.6 and above.
	*/
		PDFNet.SecurityHandler.prototype.changeRevisionNumber = function(rev_num)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'changeRevisionNumber'. Expected "+1+" argument. Function Signature: changeRevisionNumber(number)")};
		if(rev_num instanceof Promise) {throw new TypeError("1st input argument in function 'changeRevisionNumber' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rev_num != "number") {throw new TypeError("1st input argument '"+rev_num+"' in function 'changeRevisionNumber' is of type '"+(typeof rev_num)+"'. Expected type 'number'. Function Signature: changeRevisionNumber(number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.changeRevisionNumber', {"sh": this.id, "rev_num": rev_num}, this.userPriority);
	},

	/**
	* Indicates whether the document-level metadata stream is to
	* be encrypted.
	*
	* @param encrypt_metadata true if metadata stream should be
	* encrypted, false otherwise.
	*
	* @note EncryptMetadata flag affects only Crypt filters available
	* in PDF 1.5 (Acrobat 6) and later. By default, metadata stream
	* will be encrypted.
	*/
		PDFNet.SecurityHandler.prototype.setEncryptMetadata = function(encrypt_metadata)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'setEncryptMetadata'. Expected "+1+" argument. Function Signature: setEncryptMetadata(boolean)")};
		if(encrypt_metadata instanceof Promise) {throw new TypeError("1st input argument in function 'setEncryptMetadata' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof encrypt_metadata != "boolean") {throw new TypeError("1st input argument '"+encrypt_metadata+"' in function 'setEncryptMetadata' is of type '"+(typeof encrypt_metadata)+"'. Expected type 'boolean'. Function Signature: setEncryptMetadata(boolean).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.setEncryptMetadata', {"sh": this.id, "encrypt_metadata": encrypt_metadata}, this.userPriority);
	},

	/**
	* @return A promise that resolves to the revision number of the standard security algorithm.
	*/
		PDFNet.SecurityHandler.prototype.getRevisionNumber = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getRevisionNumber'. Expected "+0+" arguments. Function Signature: getRevisionNumber()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getRevisionNumber', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the SecurityHandler requires a user password.
	*/
		PDFNet.SecurityHandler.prototype.isUserPasswordRequired = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isUserPasswordRequired'. Expected "+0+" arguments. Function Signature: isUserPasswordRequired()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isUserPasswordRequired', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true if the SecurityHandler requires a master (owner) password.
	*/
		PDFNet.SecurityHandler.prototype.isMasterPasswordRequired = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isMasterPasswordRequired'. Expected "+0+" arguments. Function Signature: isMasterPasswordRequired()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isMasterPasswordRequired', {"sh": this.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true is this security handler uses 128 bit AES (Advanced Encryption Standard)
	* algorithm to encrypt strings or streams.
	*/
		PDFNet.SecurityHandler.prototype.isAES = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isAES'. Expected "+0+" arguments. Function Signature: isAES()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isAES', {"sh": this.id}, this.userPriority);
	},

	/**
	* The following function can be used to verify whether a given stream is
	* encrypted using AES.
	*
	* @return A promise that resolves to true if the given stream is encrypted using AES encryption.
	* @param stream A pointer to an SDF::Stream object
	*/
		PDFNet.SecurityHandler.prototype.isAESObj = function(stream)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'isAESObj'. Expected "+1+" argument. Function Signature: isAESObj(Obj)")};
		if(stream instanceof Promise) {throw new TypeError("1st input argument in function 'isAESObj' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(stream instanceof PDFNet.Obj)) {
			if(typeof stream == "object") {throw new TypeError("1st input argument in function 'isAESObj' is of type '"+stream.name+"'. Expected type 'Obj'. Function Signature: isAESObj(Obj).");}
			else {throw new TypeError("1st input argument '"+stream+"' in function 'isAESObj' is of type '"+(typeof stream)+"'. Expected type 'Obj'. Function Signature: isAESObj(Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isAESObj', {"sh": this.id, "stream": stream.id}, this.userPriority);
	},

	/**
	* @return A promise that resolves to true is this security handler uses RC4 algorithm to encrypt strings or streams.
	*/
		PDFNet.SecurityHandler.prototype.isRC4 = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'isRC4'. Expected "+0+" arguments. Function Signature: isRC4()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.isRC4', {"sh": this.id}, this.userPriority);
	},

	/**
	* the method can be called in GetAuthorizationData() callback to
	* specify user supplied ASCII password.
	*/
		PDFNet.SecurityHandler.prototype.initPassword = function(password)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'initPassword'. Expected "+1+" argument. Function Signature: initPassword(string)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'initPassword' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'initPassword' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: initPassword(string).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.initPassword', {"sh": this.id, "password": password}, this.userPriority);
	},

	/**
	* the method can be called in GetAuthorizationData() callback to
	* specify user supplied non-ASCII password.
	*/
		PDFNet.SecurityHandler.prototype.initPasswordNonAscii = function(password, pwd_length)
	{
		if(arguments.length != 2) {throw new RangeError(arguments.length+" arguments passed into function 'initPasswordNonAscii'. Expected "+2+" arguments. Function Signature: initPasswordNonAscii(string, number)")};
		if(password instanceof Promise) {throw new TypeError("1st input argument in function 'initPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof password != "string") {throw new TypeError("1st input argument '"+password+"' in function 'initPasswordNonAscii' is of type '"+(typeof password)+"'. Expected type 'string'. Function Signature: initPasswordNonAscii(string, number).");}
		if(pwd_length instanceof Promise) {throw new TypeError("2nd input argument in function 'initPasswordNonAscii' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pwd_length != "number") {throw new TypeError("2nd input argument '"+pwd_length+"' in function 'initPasswordNonAscii' is of type '"+(typeof pwd_length)+"'. Expected type 'number'. Function Signature: initPasswordNonAscii(string, number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.initPasswordNonAscii', {"sh": this.id, "password": password, "pwd_length": pwd_length}, this.userPriority);
	},

	/**
	* The method is called when a user tries to set security for an encrypted
	* document and when a user tries to open a file. It must decide, based on
	* the contents of the authorization data structure, whether or not the
	* user is permitted to open the file, and what permissions the user has
	* for this file.
	*
	* @note - This callback must not obtain the authorization data (e.g. by
	* displaying a user interface into which a user can type a password).
	* This is handled by the security handler's GetAuthorizationData(), which
	* must be called before this callback. Instead, Authorize() should work
	* with authorization data it has access to.
	*
	* @param p - permission to authorize
	*/
		PDFNet.SecurityHandler.prototype.authorize = function(req_opr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'authorize'. Expected "+1+" argument. Function Signature: authorize(number)")};
		if(req_opr instanceof Promise) {throw new TypeError("1st input argument in function 'authorize' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof req_opr != "number") {throw new TypeError("1st input argument '"+req_opr+"' in function 'authorize' is of type '"+(typeof req_opr)+"'. Expected type 'number'. Function Signature: authorize(number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.authorize', {"sh": this.id, "req_opr": req_opr}, this.userPriority);
	},

	/**
	* A callback method indicating repeated failed authorization.
	* Override this callback in order to provide a UI feedback for failed
	* authorization. Default implementation returns immediately.
	*/
		PDFNet.SecurityHandler.prototype.authorizeFailed = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'authorizeFailed'. Expected "+0+" arguments. Function Signature: authorizeFailed()")};
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.authorizeFailed', {"sh": this.id}, this.userPriority);
	},

	/**
	* This method is invoked in case Authorize() failed. The callback must
	* determine the user's authorization properties for the document by
	* obtaining authorization data (e.g. a password through a GUI dialog).
	*
	* The authorization data is subsequently used by the security handler's Authorize()
	* to determine whether or not the user is authorized to open the file.
	*
	* @return A promise that resolves to false if the operation was canceled, true otherwise.
	* @param req_opr - the permission for which authorization data is requested.
	*/
		PDFNet.SecurityHandler.prototype.getAuthorizationData = function(req_opr)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getAuthorizationData'. Expected "+1+" argument. Function Signature: getAuthorizationData(number)")};
		if(req_opr instanceof Promise) {throw new TypeError("1st input argument in function 'getAuthorizationData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof req_opr != "number") {throw new TypeError("1st input argument '"+req_opr+"' in function 'getAuthorizationData' is of type '"+(typeof req_opr)+"'. Expected type 'number'. Function Signature: getAuthorizationData(number).");}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.getAuthorizationData', {"sh": this.id, "req_opr": req_opr}, this.userPriority);
	},

	/**
	* Called when the security handler should activate a dialog box
	* with the current security settings that may be modified.
	*
	* @return A promise that resolves to true if the operation was successful false otherwise.
	*/
		PDFNet.SecurityHandler.prototype.editSecurityData = function(doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'editSecurityData'. Expected "+1+" argument. Function Signature: editSecurityData(SDFDoc)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'editSecurityData' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'editSecurityData' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: editSecurityData(SDFDoc).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'editSecurityData' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: editSecurityData(SDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.editSecurityData', {"sh": this.id, "doc": doc.id}, this.userPriority);
	},

	/**
	* Called when an encrypted document is saved. Fills the document's Encryption
	* dictionary with whatever information the security handler wants to store in
	* the document.
	*
	* The sequence of events during creation of the encrypt_dict is as follows:
	*  - encrypt_dict is created (if it does not exist)
	*  - Filter attribute is added to the dictionary
	*  - call this method to allow the security handler to add its own attributes
	*  - call the GetCryptKey to get the algorithm version, key, and key length
	*  - checks if the V attribute has been added to the dictionary and, if not,
	*    then sets V to the algorithm version
	*  - set the Length attribute if V is 2 or greater
	*  - add the encrypt_dict to the document
	*
	*	@param doc - The document to save.
	*  @return A promise that resolves to - encrypt_dict
	*
	* @warning - Unlike all other strings and streams, direct object elements of
	* the encrypt_dict are not encrypted automatically. If you want them encrypted,
	* you must encrypt them before inserting them into the dictionary.
	*/
		PDFNet.SecurityHandler.prototype.fillEncryptDict = function(doc)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'fillEncryptDict'. Expected "+1+" argument. Function Signature: fillEncryptDict(SDFDoc)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'fillEncryptDict' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'fillEncryptDict' is of type '"+doc.name+"'. Expected type 'SDFDoc'. Function Signature: fillEncryptDict(SDFDoc).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'fillEncryptDict' is of type '"+(typeof doc)+"'. Expected type 'SDFDoc'. Function Signature: fillEncryptDict(SDFDoc).");}
		}
		return PDFNet.messageHandler.sendWithPromise('SecurityHandler.fillEncryptDict', {"sh": this.id, "doc": doc.id}, this.userPriority).then(function(id){
			//there is a return type Obj
			if(id == "0"){
				return null;
			}
			return new PDFNet.Obj(id);
		});
	},

	/**
	* Gets the name of this SignatureHandler. The name of the SignatureHandler is what identifies this SignatureHandler
	* from all others. This name is also added to the PDF as the value of /Filter entry in the signature dictionary.
	* @return A promise that resolves to the name of this SignatureHandler.
	*/
		PDFNet.SignatureHandler.prototype.getName = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getName'. Expected "+0+" arguments. Function Signature: getName()")};
		return PDFNet.messageHandler.sendWithPromise('SignatureHandler.getName', {"signature_handler": this.id}, this.userPriority);
	},

	/**
	* Resets any data appending and signature calculations done so far. This method should allow PDFNet to restart the
	* whole signature calculation process. It is important that when this method is invoked, any data processed with
	* the AppendData method should be discarded.
	* @return A promise that resolves to true if there are no errors, otherwise false.
	*/
		PDFNet.SignatureHandler.prototype.reset = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'reset'. Expected "+0+" arguments. Function Signature: reset()")};
		return PDFNet.messageHandler.sendWithPromise('SignatureHandler.reset', {"signature_handler": this.id}, this.userPriority);
	},

	/**
	* Calculates the actual signature using client implemented signing methods. The returned value (byte array) will
	* be written as the /Contents entry in the signature dictionary.
	* @return A promise that resolves to the calculated signature data.
	*/
		PDFNet.SignatureHandler.prototype.createSignature = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'createSignature'. Expected "+0+" arguments. Function Signature: createSignature()")};
		return PDFNet.messageHandler.sendWithPromise('SignatureHandler.createSignature', {"signature_handler": this.id}, this.userPriority);
	},

		PDFNet.SignatureHandler.prototype.destructor = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destructor'. Expected "+0+" arguments. Function Signature: destructor()")};
		return PDFNet.messageHandler.sendWithPromise('SignatureHandler.destructor', {"signature_handler": this.id}, this.userPriority);
	},

	exports.PDFNet = PDFNet;
})((typeof window === 'undefined') ? this : window);

//User Written Functions
//------------------------------------------------
(function(exports){
	var finishedInitializeCapability;
	exports.PDFNet.initialize = function(l, pdfBackendType)
	{
	   if (!finishedInitializeCapability) {
			var workerHandlers = {
				pnaclCrashError: function(msg, genericMsg) {
					console.log('PNaClCrashError: ' + msg + ', ' + genericMsg);
				},
				pnaclLoadError: function(msg, genericMsg) {
					console.log('PNaClLoadError: ' + msg + ', ' + genericMsg);
				},
				emsWorkerError: function(msg, genericMsg) {
					console.log('EmsWorkerError: ' + msg + ', ' + genericMsg);
				}
			};
	   		finishedInitializeCapability = createPromiseCapability();
			var finishInit = function(pdfBackendType) {
				var workerTransportPromise = exports.CoreControls.initPDFWorkerTransports(pdfBackendType, workerHandlers, l);
				workerTransportPromise.then(function(transport){
					exports.PDFNet.messageHandler = transport;
					finishedInitializeCapability.resolve();
			   	});
	   		}
	       	if(!pdfBackendType || pdfBackendType == "auto")
	       	{
		       	var getBackendPromise = CoreControls.getDefaultPdfBackendType();
		       	getBackendPromise.then(finishInit);
	    	}
	    	else
	    	{
            	exports.CoreControls.preloadPDFWorker(pdfBackendType, workerHandlers, false);
	    		finishInit(pdfBackendType);
	    	}
		}
	   return finishedInitializeCapability.promise;
	}

	copyFunc = function(obj, me)
	{
		//console.log("Setting Value for the object:");
		for(var attr in obj){
			me[attr] = obj[attr];
			//console.log("Orig:" + obj[attr]);
			//console.log("Me:" + me[attr]);
		}
	}

	exports.PDFNet.Iterator = function(id, type)
	{
		this.id = id;
		this.type = type;
	}
	PDFNet.Iterator.prototype.current = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'fillEncryptDict'. Expected "+0+" argument.")};
		var me = this;
		var promise = PDFNet.messageHandler.sendWithPromise('Iterator.current', {"itr": this.id, "type": this.type}, this.userPriority);
		if(this.type != 'Int')
		{
			promise = promise.then(function(id){
				var foo = new PDFNet[me.type](id);
				return foo;
			});
		}
		return promise;
	}

	// Temporarily adding for tutorial
	PDFNet.Redactor.redact = function(doc, red_arr, appearance, ext_neg_mode, page_coord_sys)
	{
		if(typeof appearance.redaction_overlay === "undefined"){
			appearance.redaction_overlay = true;
		}if(typeof appearance.positive_overlay_color === "undefined"){
			appearance.positive_overlay_color = PDFNet.ColorPt.init(1, 1, 1, 0);
		}if(typeof appearance.negative_overlay_color === "undefined"){
			appearance.negative_overlay_color = PDFNet.ColorPt.init(1, 1, 1, 0);
		}if(typeof appearance.border === "undefined"){
			appearance.border = true;
		}if(typeof appearance.font === "undefined"){
			appearance.font = PDFNet.Font.createFromObj(new PDFNet.Obj("0"));
		}if(typeof appearance.min_font_size === "undefined"){
			appearance.min_font_size = 2;
		}if(typeof appearance.max_font_size === "undefined"){
			appearance.max_font_size = 24;
		}if(typeof appearance.text_color === "undefined"){
			appearance.text_color = PDFNet.ColorPt.init(0, 0.5, 0, 0);
		}if(typeof appearance.horiz_text_alignment === "undefined"){
			appearance.horiz_text_alignment = -1;
		}if(typeof appearance.vert_text_alignment === "undefined"){
			appearance.vert_text_alignment = -1;
		}if(typeof appearance.show_redacted_content_regions === "undefined"){
			appearance.show_redacted_content_regions = false;
		}if(typeof appearance.redacted_content_color === "undefined"){
			appearance.redacted_content_color = PDFNet.ColorPt.init(0.3, 0.3, 0.3, 0);
		}

		if(arguments.length != 6) {throw new RangeError(arguments.length+" arguments passed into function 'redact'. Expected "+6+" arguments. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc || doc instanceof PDFNet.SDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'redact' is of type '"+doc.name+"'. Expected type 'PDFDoc'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'redact' is of type '"+(typeof doc)+"'. Expected type 'PDFDoc'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		/*
		if(!(red_arr instanceof PDFNet.Redaction)) {
			if(typeof red_arr == "object") {throw new TypeError("2nd input argument in function 'redact' is of type '"+red_arr.name+"'. Expected type 'Redaction'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("2nd input argument '"+red_arr+"' in function 'redact' is of type '"+(typeof red_arr)+"'. Expected type 'Redaction'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		*/
		var buf_size = red_arr.length;

		if(appearance instanceof Promise) {throw new TypeError("4th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(appearance instanceof PDFNet.RedactionAppearance)) {
			if(typeof appearance == "object") {throw new TypeError("4th input argument in function 'redact' is of type '"+appearance.name+"'. Expected type 'RedactionAppearance'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
			else {throw new TypeError("4th input argument '"+appearance+"' in function 'redact' is of type '"+(typeof appearance)+"'. Expected type 'RedactionAppearance'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		}
		if(ext_neg_mode instanceof Promise) {throw new TypeError("5th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof ext_neg_mode != "boolean") {throw new TypeError("5th input argument '"+ext_neg_mode+"' in function 'redact' is of type '"+(typeof ext_neg_mode)+"'. Expected type 'boolean'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		if(page_coord_sys instanceof Promise) {throw new TypeError("6th input argument in function 'redact' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_coord_sys != "boolean") {throw new TypeError("6th input argument '"+page_coord_sys+"' in function 'redact' is of type '"+(typeof page_coord_sys)+"'. Expected type 'boolean'. Function Signature: redact(PDFDoc, Redaction, number, RedactionAppearance, boolean, boolean).");}
		return PDFNet.messageHandler.sendWithPromise('redactorRedact', {"doc": doc.id, "red_arr": red_arr, "buf_size": buf_size, "appearance": appearance.id, "ext_neg_mode": ext_neg_mode, "page_coord_sys": page_coord_sys}, this.userPriority);
	},

	// don't expose, add additional functionality to .redact for handling optionsobj.
	/*
	PDFNet.RedactionAppearance.create = function(redaction_overlay, positive_overlay_color, negative_overlay_color, border, use_overlay_text, font, min_font_size, max_font_size, text_color, horiz_text_alignment, vert_text_alignment, show_redacted_content_regions, redacted_content_color)
	{
		var redaction_overlay = true;
		var positive_overlay_color = PDFNet.ColorPt.init(1, 1, 1, 0);
		var negative_overlay_color = PDFNet.ColorPt.init(1, 1, 1, 0);
		var border = true;
		var use_overlay_text = true;
		var font = PDFNet.Font.createFromObj(new PDFNet.obj(0));
		var min_font_size = 2;
		var max_font_size = 24;
		var text_color = true;
		var horiz_text_alignment = true;
		var vert_text_alignment = true;
		var show_redacted_content_regions = true;
		var redacted_content_color = true;

		return PDFNet.messageHandler.sendWithPromise('redactionAppearanceCreate', {"redaction_overlay": redaction_overlay, "positive_overlay_color": positive_overlay_color.id, "negative_overlay_color": negative_overlay_color.id, "border": border, "use_overlay_text": use_overlay_text, "font": font.id, "min_font_size": min_font_size, "max_font_size": max_font_size, "text_color": text_color.id, "horiz_text_alignment": horiz_text_alignment, "vert_text_alignment": vert_text_alignment, "show_redacted_content_regions": show_redacted_content_regions, "redacted_content_color": redacted_content_color.id}, this.userPriority).then(function(id){
			//there is a return type RedactionAppearance
			return new PDFNet.RedactionAppearance(id);
		});
	},
*/
	// Iterators have an extra "type" element.
	PDFNet.Iterator.prototype.hasNext = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'hasNext'. Expected "+0+" arguments. Function Signature: hasNext()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.hasNext', {"itr": this.id, "type": this.type}, this.userPriority);
	}

	PDFNet.Iterator.prototype.next = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'next'. Expected "+0+" arguments. Function Signature: next()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.next', {"itr": this.id, "type": this.type}, this.userPriority);
	}

	PDFNet.Iterator.prototype.destroy = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'destroy'. Expected "+0+" arguments. Function Signature: destroy()")};
		return PDFNet.messageHandler.sendWithPromise('Iterator.destroy', {"itr": this.id, "type": this.type}, this.userPriority);
	}

	// TEMPORARILY ADDING IN THESE ITERATORS UNTIL I CAN AUTOGEN THEM
	PDFNet.PDFDoc.prototype.getPageIterator = function(page_number)
	{
		if(typeof page_number === "undefined") {page_number = 1;};
		if(arguments.length > 1) {throw new RangeError(arguments.length+" arguments passed into function 'getPageIterator'. Expected at most "+1+" argument. Function Signature: getPageIterator(number)")};
		if(page_number instanceof Promise) {throw new TypeError("1st input argument in function 'getPageIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof page_number != "number") {throw new TypeError("1st input argument '"+page_number+"' in function 'getPageIterator' is of type '"+(typeof page_number)+"'. Expected type 'number'. Function Signature: getPageIterator(number).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getPageIterator', {"doc": this.id, "page_number": page_number}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id, "Page");
		});
	}
	PDFNet.PDFDoc.prototype.getFieldIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIteratorBegin'. Expected "+0+" arguments. Function Signature: getFieldIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getFieldIteratorBegin', {"doc": this.id}, this.userPriority).then(function(id){
			return new PDFNet.Iterator(id, "Field");
		});
	}
	PDFNet.PDFDoc.prototype.getFieldIterator = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIterator'. Expected "+1+" argument. Function Signature: getFieldIterator(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getFieldIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+url+"' in function 'getFieldIterator' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: getFieldIterator(string).");}
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.getFieldIterator', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id, "Field");
		});
	}
	PDFNet.FDFDoc.prototype.getFieldIteratorBegin = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIteratorBegin'. Expected "+0+" arguments. Function Signature: getFieldIteratorBegin()")};
		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getFieldIteratorBegin', {"doc": this.id}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id, "Field");
		});
	}
	PDFNet.FDFDoc.prototype.getFieldIterator = function(field_name)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getFieldIterator'. Expected "+1+" argument. Function Signature: getFieldIterator(string)")};
		if(field_name instanceof Promise) {throw new TypeError("1st input argument in function 'getFieldIterator' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof field_name != "string") {throw new TypeError("1st input argument '"+url+"' in function 'getFieldIterator' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: getFieldIterator(string).");}

		return PDFNet.messageHandler.sendWithPromise('FDFDoc.getFieldIterator', {"doc": this.id, "field_name": field_name}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id, "Field");
		});
	}
	PDFNet.ElementReader.prototype.getChangesIterator = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getChangesIterator'. Expected "+0+" arguments. Function Signature: getChangesIterator()")};
		return PDFNet.messageHandler.sendWithPromise('ElementReader.getChangesIterator', {"r": this.id}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Iterator(id, "Int");
		});
	}

	PDFNet.beginOperation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'beginOperation'. Expected "+0+" arguments. Function Signature: beginOperation()")};
		return PDFNet.messageHandler.sendWithPromise('BeginOperation', {}, this.userPriority);
	},

	PDFNet.finishOperation = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'finishOperation'. Expected "+0+" arguments. Function Signature: finishOperation()")};
		return PDFNet.messageHandler.sendWithPromise('FinishOperation', {}, this.userPriority);
	},

/*
	PDFNet.FilterReader.create = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: readerCreate()")};
		return PDFNet.messageHandler.sendWithPromise('filterReaderCreate', {"filter": filter.id}, this.userPriority).then(function(id){
			//there is a return type FilterReader
			return new PDFNet.FilterReader(id);
		});
	},

	PDFNet.FilterWriter.create = function(filter)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'create'. Expected "+0+" arguments. Function Signature: writerCreate()")};
		return PDFNet.messageHandler.sendWithPromise('filterWriterCreate', {"filter": filter.id}, this.userPriority).then(function(id){
			//there is a return type FilterWriter
			return new PDFNet.FilterWriter(id);
		});
	},
*/
	// END TEMP

/*
TEMPORARILY CANNOT WORK.
	exports.PDFNet.FileAttachmentAnnot.createDefault = function(doc, pos, path)
	{
		var capability = createPromiseCapability();
		var partRetriever = new exports.CoreControls.PartRetrievers.ExternalPdfPartRetriever(url);
		partRetriever.getFileData(function(data) {
			PDFNet.PDFDoc.	// create from ArrayBuffer
		}
			)
		return PDFNet.messageHandler.sendWithPromise('fileAttachmentAnnotCreateDefault', {"doc": doc.id, "pos": pos, "path": path}, this.userPriority).then(function(id){
			//there is a return type FileAttachmentAnnot
			return new PDFNet.FileAttachmentAnnot(id);
		});
	},
*/
	exports.PDFNet.PDFDoc.createFromURL = function(url)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromURL'. Expected "+1+" argument. Function Signature: createFromURL(string)")};
		if(url instanceof Promise) {throw new TypeError("1st input argument in function 'createFromURL' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof url != "string") {throw new TypeError("1st input argument '"+url+"' in function 'createFromURL' is of type '"+(typeof url)+"'. Expected type 'string'. Function Signature: createFromURL(string).");}
	    var capability = createPromiseCapability();
	    var partRetriever = new exports.CoreControls.PartRetrievers.ExternalPdfPartRetriever(url);
	    partRetriever.getFileData(function(data) {
	        PDFNet.PDFDoc.createFromBuffer(data).then(function(doc){
	            capability.resolve(doc);
	        })
	    });
	    return capability.promise;
	}

	PDFNet.PDFDraw.prototype.exportStream = function(page, format, encoder_params)
	{
		if(typeof format == "undefined") {format = "PNG";};
		if(typeof encoder_params == "undefined") {encoder_params = new PDFNet.Obj("0");};
		if((arguments.length < 1) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'exportStream'. Expected "+1+" to "+3+" arguments. Function Signature: exportStream(Page, string, Obj)")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'exportStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'exportStream' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: exportStream(Page, string, Obj).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'exportStream' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: exportStream(Page, string, Obj).");}
		}
		if(format instanceof Promise) {throw new TypeError("2nd input argument in function 'exportStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof format != "string") {throw new TypeError("2nd input argument '"+format+"' in function 'exportStream' is of type '"+(typeof format)+"'. Expected type 'string'. Function Signature: exportStream(Page, string, Obj).");}
		if(encoder_params instanceof Promise) {throw new TypeError("3rd input argument in function 'exportStream' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_params instanceof PDFNet.Obj)) {
			if(typeof encoder_params == "object") {throw new TypeError("3rd input argument in function 'exportStream' is of type '"+encoder_params.name+"'. Expected type 'Obj'. Function Signature: exportStream(Page, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+encoder_params+"' in function 'exportStream' is of type '"+(typeof encoder_params)+"'. Expected type 'Obj'. Function Signature: exportStream(Page, string, Obj).");}
		}
		return PDFNet.messageHandler.sendWithPromise('PDFDraw.exportStream', {"d": this.id, "page": page.id, "format": format, "encoder_params": encoder_params.id}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new Uint8Array(id);
		})
	},


	exports.PDFNet.Image.createFromFile = function(doc, filename, encoder_hints)
	{
		if(typeof encoder_hints === "undefined"){encoder_hints = new PDFNet.Obj("0")};
		if((arguments.length < 2) || (arguments.length > 3)) {throw new RangeError(arguments.length+" arguments passed into function 'createFromFile'. Expected "+2+" to "+3+" arguments. Function Signature: createFromFile(PDFDoc, string, Obj)")};
		if(doc instanceof Promise) {throw new TypeError("1st input argument in function 'createFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(doc instanceof PDFNet.PDFDoc)) {
			if(typeof doc == "object") {throw new TypeError("1st input argument in function 'createFromFile' is of type '"+doc.name+"'. Expected type 'Page'. Function Signature: createFromFile(PDFDoc, string, Obj).");}
			else {throw new TypeError("1st input argument '"+doc+"' in function 'createFromFile' is of type '"+(typeof doc)+"'. Expected type 'Page'. Function Signature: createFromFile(PDFDoc, string, Obj).");}
		}
		if(filename instanceof Promise) {throw new TypeError("2nd input argument in function 'createFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof filename != "string") {throw new TypeError("2nd input argument '"+filename+"' in function 'createFromFile' is of type '"+(typeof filename)+"'. Expected type 'string'. Function Signature: createFromFile(PDFDoc, string, Obj).");}
		if(encoder_hints instanceof Promise) {throw new TypeError("3rd input argument in function 'createFromFile' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(encoder_hints instanceof PDFNet.Obj)) {
			if(typeof encoder_hints == "object") {throw new TypeError("3rd input argument in function 'createFromFile' is of type '"+encoder_hints.name+"'. Expected type 'Obj'. Function Signature: createFromFile(PDFDoc, string, Obj).");}
			else {throw new TypeError("3rd input argument '"+encoder_hints+"' in function 'createFromFile' is of type '"+(typeof encoder_hints)+"'. Expected type 'Obj'. Function Signature: createFromFile(PDFDoc, string, Obj).");}
		}

		var capability = createPromiseCapability();
	    var partRetriever = new exports.CoreControls.PartRetrievers.ExternalPdfPartRetriever(filename);
	    partRetriever.getFileData(function(data) {
	        PDFNet.Image.createFromMemory2(doc, data, encoder_hints).then(function(img){
	            capability.resolve(img);
	        })
	    });
	    return capability.promise;
	}

	exports.PDFNet.PDFDoc.createFromBuffer = function(buf)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'createFromBuffer'. Expected "+1+" argument. Function Signature: createFromBuffer(ArrayBuffer)")};
		if(buf instanceof Promise) {throw new TypeError("1st input argument in function 'createFromBuffer' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(buf.buffer instanceof ArrayBuffer)) {
			if(typeof buf == "object") {throw new TypeError("1st input argument in function 'createFromBuffer' is of type '"+buf.name+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(ArrayBuffer).");}
			else {throw new TypeError("1st input argument '"+buf+"' in function 'createFromBuffer' is of type '"+(typeof buf)+"'. Expected type 'ArrayBuffer'. Function Signature: createFromBuffer(ArrayBuffer).");}
		}
		return exports.PDFNet.messageHandler.sendWithPromise('pdfDocCreateFromBuffer', {"buf": buf.buffer}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	}

	PDFNet.Element.prototype.getPathData = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getPathData'. Expected "+0+" arguments. Function Signature: getPathData()")};
		//var pathData = PDFNet.messageHandler.sendWithPromise('Element.getPathData', {"e": this.id}, this.userPriority);
		return PDFNet.messageHandler.sendWithPromise('Element.getPathData', {"e": this.id}, this.userPriority);
	}

	PDFNet.PDFDoc.prototype.convertToXod = function(optionsObj)
	{
		if(typeof optionsObj === "undefined"){optionsObj = {}};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.convertToXod', {"doc": this.id, "optionsObject": optionsObj}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new Uint8Array(id);
		});
	}

	PDFNet.PDFDoc.prototype.convertToXodStream = function(optionsObj)
	{
		if(typeof optionsObj === "undefined"){optionsObj = {}};
		return PDFNet.messageHandler.sendWithPromise('PDFDoc.convertToXodStream', {"doc": this.id, "optionsObject": optionsObj}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.Filter(id);
		});
	}

	PDFNet.FilterReader.prototype.read = function(buf_size)
	{
		// make buffer, fill buffer bit by bit...
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'read'. Expected "+1+" argument. Function Signature: read(number).")};
		if(buf_size instanceof Promise) {throw new TypeError("1st input argument in function 'read' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof buf_size != "number") {throw new TypeError("1st input argument '"+buf_size+"' in function 'read' is of type '"+(typeof buf_size)+"'. Expected type 'number'. Function Signature: read(number).");}

		return PDFNet.messageHandler.sendWithPromise('FilterReader.read', {"reader": this.id, "buf_size": buf_size}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new Uint8Array(id);
		});
	}


	PDFNet.bitmapInfo = function(id)
	{
		copyFunc(id, this);
	}

	PDFNet.PDFDraw.prototype.getBitmap = function(page, pix_fmt, demult)
	{
		if(arguments.length != 3) {throw new RangeError(arguments.length+" arguments passed into function 'getBitmap'. Expected "+3+" arguments. Function Signature: getBitmap(Page, PixelFormat, boolean).")};
		if(page instanceof Promise) {throw new TypeError("1st input argument in function 'getBitmap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(!(page instanceof PDFNet.Page)) {
			if(typeof page == "object") {throw new TypeError("1st input argument in function 'getBitmap' is of type '"+page.name+"'. Expected type 'Page'. Function Signature: getBitmap(Page, PixelFormat, boolean).");}
			else {throw new TypeError("1st input argument '"+page+"' in function 'getBitmap' is of type '"+(typeof page)+"'. Expected type 'Page'. Function Signature: getBitmap(Page, PixelFormat, boolean).");}
		}
		if(pix_fmt instanceof Promise) {throw new TypeError("2nd input argument in function 'getBitmap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof pix_fmt != "number") {throw new TypeError("2nd input argument '"+pix_fmt+"' in function 'getBitmap' is of type '"+(typeof pix_fmt)+"'. Expected type 'number'. Function Signature: getBitmap(Page, PixelFormat, boolean).");}
		if(demult instanceof Promise) {throw new TypeError("3rd input argument in function 'getBitmap' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof demult != "boolean") {throw new TypeError("3rd input argument '"+demult+"' in function 'getBitmap' is of type '"+(typeof demult)+"'. Expected type 'boolean'. Function Signature: getBitmap(Page, PixelFormat, boolean).");}

		return PDFNet.messageHandler.sendWithPromise('PDFDraw.getBitmap', {"d": this.id, "page": page.id, "pix_fmt": pix_fmt, "demult": demult}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.bitmapInfo(id);
		});
	}

	PDFNet.Matrix2D.create = function(a, b, c, d, h, v)
	{
		if(a == undefined) {a = 0};
		if(b == undefined) {b = 0};
		if(c == undefined) {c = 0};
		if(d == undefined) {d = 0};
		if(h == undefined) {h = 0};
		if(v == undefined) {v = 0};

		if(arguments.length > 6) {throw new RangeError(arguments.length+" arguments passed into function 'Matrix2D.create'. Expected "+0+" to "+6+" arguments. Function Signature: create(number, number, number, number, number, number).")};
		if(a instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof a != "number") {throw new TypeError("1st input argument '"+a+"' in function 'Matrix2D.create' is of type '"+(typeof a)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}
		if(b instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof b != "number") {throw new TypeError("1st input argument '"+b+"' in function 'Matrix2D.create' is of type '"+(typeof b)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}
		if(c instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof c != "number") {throw new TypeError("1st input argument '"+c+"' in function 'Matrix2D.create' is of type '"+(typeof c)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}
		if(d instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof d != "number") {throw new TypeError("1st input argument '"+d+"' in function 'Matrix2D.create' is of type '"+(typeof d)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}
		if(h instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof h != "number") {throw new TypeError("1st input argument '"+h+"' in function 'Matrix2D.create' is of type '"+(typeof h)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}
		if(v instanceof Promise) {throw new TypeError("1st input argument in function 'Matrix2D.create' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof v != "number") {throw new TypeError("1st input argument '"+v+"' in function 'Matrix2D.create' is of type '"+(typeof v)+"'. Expected type 'number'. Function Signature: create(number, number, number, number, number, number).");}

		var capability = createPromiseCapability();
		var matrix = new PDFNet.Matrix2D({"m_a":a, "m_b":b, "m_c":c, "m_d":d, "m_h":h, "m_v":v});
		capability.resolve(matrix);
		return capability.promise;
	}

	PDFNet.Point = function(x, y){
		return {x: x, y: y, name: "Point"};
	}

	PDFNet.QuadPoint = function(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y){
		return {p1x: p1x, p1y: p1y, p2x: p2x, p2y: p2y, p3x: p3x, p3y: p3y, p4x: p4x, p4y: p4y, name: "QuadPoint"};
	}

	PDFNet.PDFDoc.prototype.getPDFDoc = function()
	{
		console.log("In PDFNetUser.js getPDFDoc");
		return PDFNet.messageHandler.sendWithPromise('GetPDFDoc', {"doc": this.id}, this.userPriority).then(function(id){
			if(id == "0"){
				return null;
			}
			return new PDFNet.PDFDoc(id);
		});
	}

	PDFNet.TextExtractorLine.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getBBox'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorLine.getBBox"; // TRN_TextExtractorLine* line
		return PDFNet.messageHandler.sendWithPromise('TextExtractorLine.getBBox', {"line": this}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
			return new PDFNet.Rect(id.result.x1, id.result.y1, id.result.x2, id.result.y2, id.result.mp_rect);
		});
	},

	PDFNet.TextExtractorWord.prototype.getBBox = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getBBox'. Expected "+0+" arguments. Function Signature: getBBox()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getBBox'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getBBox"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getBBox', {"tew": this}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
			return new PDFNet.Rect(id.result.x1, id.result.y1, id.result.x2, id.result.y2, id.result.mp_rect);
		});
	},

	PDFNet.TextExtractorWord.prototype.getQuad = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getQuad'. Expected "+0+" arguments. Function Signature: getQuad()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getQuad'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getQuad"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getQuad', {"tew": this}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
			return new PDFNet.QuadPoint(id.result.p1x, id.result.p1y, id.result.p2x, id.result.p2y, id.result.p3x, id.result.p3y, id.result.p4x, id.result.p4y);
		});
	},

	PDFNet.TextExtractorWord.prototype.getGlyphQuad = function(glyph_idx)
	{
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getGlyphQuad'. Expected "+1+" argument. Function Signature: getGlyphQuad(number)")};
		if(glyph_idx instanceof Promise) {throw new TypeError("1st input argument in function 'getGlyphQuad' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof glyph_idx != "number") {throw new TypeError("1st input argument '"+glyph_idx+"' in function 'getGlyphQuad' is of type '"+(typeof glyph_idx)+"'. Expected type 'number'. Function Signature: getGlyphQuad(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getGlyphQuad'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getGlyphQuad"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getGlyphQuad', {"tew": this, "glyph_idx": glyph_idx}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
			return new PDFNet.QuadPoint(id.result.p1x, id.result.p1y, id.result.p2x, id.result.p2y, id.result.p3x, id.result.p3y, id.result.p4x, id.result.p4y);
		});
	},

	PDFNet.TextExtractorStyle.prototype.getColor = function(rgb)
	{
		console.log("TextExtractorStyle.getColor currently not implemented.");
		if(arguments.length != 1) {throw new RangeError(arguments.length+" arguments passed into function 'getColor'. Expected "+1+" argument. Function Signature: getColor(number)")};
		if(rgb instanceof Promise) {throw new TypeError("1st input argument in function 'getColor' is a Promise object. Promises require a 'yield' statement before being accessed.");}
		if(typeof rgb != "number") {throw new TypeError("1st input argument '"+rgb+"' in function 'getColor' is of type '"+(typeof rgb)+"'. Expected type 'number'. Function Signature: getColor(number).");}
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getColor'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorStyle.getColor"; // TRN_TextExtractorStyle* tes
		return PDFNet.messageHandler.sendWithPromise('TextExtractorStyle.getColor', {"tes": this, "rgb": rgb}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
		});
	},

	PDFNet.TextExtractorWord.prototype.getString = function()
	{
		if(arguments.length != 0) {throw new RangeError(arguments.length+" arguments passed into function 'getString'. Expected "+0+" arguments. Function Signature: getString()")};
		if(typeof this.yieldFunction !== "undefined") {throw new Error("Function "+this.yieldFunction+" recently altered a struct object without yielding. That object is now being accessed by function 'getString'. Perhaps a yield statement is required for "+this.yieldFunction+"?");}
		var me = this;
		this.yieldFunction = "TextExtractorWord.getString"; // TRN_TextExtractorWord* tew
		return PDFNet.messageHandler.sendWithPromise('TextExtractorWord.getString', {"tew": this}, this.userPriority).then(function(id){
			me.yieldFunction = undefined;
			return id;
		});
	}
/*
	PDFNet.Obj.create = function()
	{
		return PDFNet.messageHandler.sendWithPromise('pdfDocCreate', {}, this.userPriority).then(function(id){
			//there is a return type PDFDoc
			return new PDFNet.PDFDoc(id);
		});
	},
*/
}) ((typeof window === 'undefined') ? this: window);